<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Your Cart - Guildite</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* ===== Enhanced Base Styles ===== */
    :root {
      --primary-color: #2563eb;
      --primary-dark: #1d4ed8;
      --primary-light: #93c5fd;
      --primary-extra-light: #e0f2fe;
      --dark-bg: #0f172a;
      --dark-secondary: #1e293b;
      --dark-tertiary: #334155;
      --light-bg: #f8fafc;
      --light-secondary: #e2e8f0;
      --light-tertiary: #f1f5f9;
      --light-text: #f8fafc;
      --dark-text: #0f172a;
      --gray-text: #64748b;
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --error-color: #ef4444;
      --card-bg: #ffffff;
      --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --card-shadow-hover: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --border-radius: 12px;
      --border-radius-sm: 8px;
    }
    
    /* ===== Reset & Enhanced Base ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html {
      scroll-behavior: smooth;
    }
    
    body {
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      background-color: var(--light-bg);
      color: var(--dark-text);
      line-height: 1.6;
      transition: var(--transition);
      min-height: 100vh;
    }
    
    body.dark-mode {
      background-color: var(--dark-bg);
      color: var(--light-text);
    }
    
    /* ===== Enhanced Animations ===== */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes slideIn {
      from { transform: translateX(-10px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    
    .animate-fade {
      animation: fadeIn 0.4s ease forwards;
    }
    
    .animate-slide {
      animation: slideIn 0.3s ease forwards;
    }
    
    .animate-pulse {
      animation: pulse 1.5s infinite;
    }
    
    .animate-bounce {
      animation: bounce 0.5s ease;
    }
    
    .animate-shake {
      animation: shake 0.3s ease;
    }
    
    /* ===== Enhanced Header Styles ===== */
    .site-header {
      position: sticky;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      background-color: rgba(15, 23, 42, 0.98);
      padding: 1rem 2rem;
      transition: var(--transition);
      backdrop-filter: blur(8px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    body.dark-mode .site-header {
      background-color: rgba(15, 23, 42, 0.98);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
      gap: 1rem;
    }
    
    .brand {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      transition: var(--transition);
      text-decoration: none;
    }
    
    .brand:hover {
      transform: translateY(-1px);
    }
    
    .brand-icon {
      width: 2.5rem;
      height: 2.5rem;
      border-radius: var(--border-radius-sm);
      transition: var(--transition);
    }
    
    .brand-name {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary-light);
      letter-spacing: 0.5px;
      transition: var(--transition);
    }
    
    .brand:hover .brand-name {
      color: white;
    }
    
    .main-nav {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .nav-link {
      color: var(--light-text);
      font-weight: 500;
      font-size: 1rem;
      transition: var(--transition);
      position: relative;
      padding: 0.5rem 0;
      text-decoration: none;
      white-space: nowrap;
    }
    
    .nav-link::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease;
    }
    
    .nav-link:hover::after {
      width: 100%;
    }
    
    .nav-link.active {
      font-weight: 600;
    }
    
    .nav-link.active::after {
      width: 100%;
    }
    
    .user-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .icon-btn {
      background: transparent;
      border: none;
      color: var(--light-text);
      font-size: 1.2rem;
      cursor: pointer;
      transition: var(--transition);
      position: relative;
      padding: 0.5rem;
      border-radius: 50%;
      width: 2.5rem;
      height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .icon-btn:hover {
      color: var(--primary-color);
      background-color: rgba(255, 255, 255, 0.1);
      transform: translateY(-1px);
    }
    
    .icon-btn:focus {
      outline: 2px solid var(--primary-light);
      outline-offset: 2px;
    }
    
    .cart-btn {
      position: relative;
    }
    
    .cart-badge {
      position: absolute;
      top: -0.25rem;
      right: -0.25rem;
      background-color: var(--primary-color);
      color: white;
      border-radius: 50%;
      width: 1.25rem;
      height: 1.25rem;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      transition: var(--transition);
    }
    
    .profile-dropdown {
      position: relative;
    }
    
    .user-avatar {
      width: 2.25rem;
      height: 2.25rem;
      border-radius: 50%;
      object-fit: cover;
      cursor: pointer;
      border: 2px solid transparent;
      transition: var(--transition);
    }
    
    .user-avatar:hover {
      border-color: var(--primary-color);
      transform: scale(1.05);
    }
    
    .dropdown-content {
      display: none;
      position: absolute;
      right: 0;
      top: 100%;
      background-color: var(--dark-secondary);
      min-width: 12rem;
      box-shadow: var(--card-shadow-hover);
      z-index: 100;
      border-radius: var(--border-radius-sm);
      overflow: hidden;
      animation: fadeIn 0.2s ease-out;
      margin-top: 0.5rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .dropdown-content a {
      color: var(--light-text);
      padding: 0.75rem 1rem;
      text-decoration: none;
      display: block;
      font-size: 0.9rem;
      transition: var(--transition);
    }
    
    .dropdown-content a:hover {
      background-color: var(--primary-dark);
      padding-left: 1.25rem;
    }
    
    .dropdown-content a i {
      margin-right: 0.5rem;
      width: 1rem;
      text-align: center;
    }
    
    .profile-dropdown:hover .dropdown-content {
      display: block;
    }
    
    /* ===== Enhanced Main Content ===== */
    .main-content {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 2rem;
      display: grid;
      grid-template-columns: 1fr minmax(300px, 350px);
      gap: 2rem;
      min-height: calc(100vh - 10rem);
    }
    
    @media (max-width: 1024px) {
      .main-content {
        grid-template-columns: 1fr;
      }
      
      .order-summary {
    /* Disable sticky behavior when it moves to grid-row: 1 */
    position: static; 
  }
    }
    
    /* ===== Enhanced Cart Items ===== */
    .cart-section {
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      box-shadow: var(--card-shadow);
      transition: var(--transition);
    }
    
    body.dark-mode .cart-section {
      background-color: var(--dark-secondary);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1);
    }
    
    .section-title {
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }
    
    body.dark-mode .section-title {
      border-bottom-color: rgba(255, 255, 255, 0.1);
    }
    
    .cart-items {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }
    
    .cart-item {
      display: flex;
      gap: 1.25rem;
      padding: 1.25rem;
      border-radius: var(--border-radius-sm);
      transition: var(--transition);
      border: 1px solid rgba(0, 0, 0, 0.05);
      background-color: var(--card-bg);
      position: relative;
    }
    
    body.dark-mode .cart-item {
      border-color: rgba(255, 255, 255, 0.05);
      background-color: var(--dark-tertiary);
    }
    
    .cart-item:hover {
      box-shadow: var(--card-shadow-hover);
      transform: translateY(-2px);
    }
    
    .cart-item-image {
      width: 7.5rem;
      height: 7.5rem;
      border-radius: var(--border-radius-sm);
      object-fit: cover;
      flex-shrink: 0;
      align-self: center;
      transition: transform 0.3s ease;
    }
    
    .cart-item:hover .cart-item-image {
      transform: scale(1.03);
    }
    
    .cart-item-details {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 0.5rem;
    }
    
    .cart-item-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
      color: var(--dark-text);
      transition: color 0.3s ease;
    }
    
    body.dark-mode .cart-item-title {
      color: var(--light-text);
    }
    
    .cart-item-seller {
      font-size: 0.9rem;
      color: var(--gray-text);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .seller-avatar {
      width: 1.25rem;
      height: 1.25rem;
      border-radius: 50%;
      object-fit: cover;
      transition: transform 0.3s ease;
    }
    
    .cart-item-seller:hover .seller-avatar {
      transform: scale(1.1);
    }
    
    .cart-item-price {
      font-weight: 700;
      color: var(--primary-color);
      margin: 0.5rem 0;
      font-size: 1.1rem;
      transition: color 0.3s ease;
    }
    
    .original-price {
      text-decoration: line-through;
      color: var(--gray-text);
      font-size: 0.9rem;
      margin-left: 0.5rem;
    }
    
    .cart-item-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .quantity-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .quantity-btn {
      width: 2rem;
      height: 2rem;
      border-radius: var(--border-radius-sm);
      background-color: var(--light-secondary);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 600;
    }
    
    body.dark-mode .quantity-btn {
      background-color: var(--dark-secondary);
      color: var(--light-text);
    }
    
    .quantity-btn:hover {
      background-color: var(--primary-light);
      color: var(--dark-text);
    }
    
    body.dark-mode .quantity-btn:hover {
      color: var(--light-text);
    }
    
    .quantity-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .quantity-btn:disabled:hover {
      background-color: var(--light-secondary);
    }
    
    body.dark-mode .quantity-btn:disabled:hover {
      background-color: var(--dark-secondary);
    }
    
    .quantity-input {
      width: 2.5rem;
      text-align: center;
      border: none;
      background: transparent;
      font-weight: 600;
      font-size: 1rem;
      padding: 0.25rem;
      border-radius: var(--border-radius-sm);
      border: 1px solid rgba(0, 0, 0, 0.1);
      transition: var(--transition);
    }
    
    body.dark-mode .quantity-input {
      color: var(--light-text);
      border-color: rgba(255, 255, 255, 0.1);
    }
    
    .quantity-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    
    .remove-btn {
      background: none;
      border: none;
      color: var(--error-color);
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: var(--transition);
      padding: 0.5rem;
      border-radius: var(--border-radius-sm);
    }
    
    .remove-btn:hover {
      background-color: rgba(239, 68, 68, 0.1);
      transform: translateX(-2px);
    }
    
    body.dark-mode .remove-btn:hover {
      background-color: rgba(239, 68, 68, 0.2);
    }
    
    .save-btn {
      background: none;
      border: none;
      color: var(--warning-color);
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: var(--transition);
      padding: 0.5rem;
      border-radius: var(--border-radius-sm);
    }
    
    .save-btn:hover {
      background-color: rgba(245, 158, 11, 0.1);
      transform: translateX(-2px);
    }
    
    body.dark-mode .save-btn:hover {
      background-color: rgba(245, 158, 11, 0.2);
    }
    
    /* ===== Enhanced Empty Cart ===== */
    .empty-cart {
      text-align: center;
      padding: 3rem 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      animation: fadeIn 0.5s ease;
    }
    
    .empty-cart-icon {
      font-size: 3.5rem;
      color: var(--gray-text);
      margin-bottom: 0.5rem;
      opacity: 0.7;
      animation: bounce 2s infinite;
    }
    
    .empty-cart-message {
      font-size: 1.25rem;
      color: var(--dark-text);
      font-weight: 500;
    }
    
    body.dark-mode .empty-cart-message {
      color: var(--light-text);
    }
    
    .empty-cart-submessage {
      color: var(--gray-text);
      max-width: 30rem;
      margin: 0 auto;
    }
    
    .continue-shopping {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem;
      background-color: var(--primary-color);
      color: white;
      border-radius: var(--border-radius-sm);
      text-decoration: none;
      transition: var(--transition);
      font-weight: 500;
      margin-top: 1rem;
    }
    
    .continue-shopping:hover {
      background-color: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.3), 0 2px 4px -1px rgba(37, 99, 235, 0.1);
    }
    
    /* ===== Enhanced Order Summary ===== */
    .order-summary {
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      box-shadow: var(--card-shadow);
      height: fit-content;
      position: sticky;
      top: 6rem;
      transition: var(--transition);
    }
    
    body.dark-mode .order-summary {
      background-color: var(--dark-secondary);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1);
    }
    
    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.75rem;
      font-size: 0.95rem;
      transition: var(--transition);
    }
    
    .summary-label {
      color: var(--gray-text);
    }
    
    .summary-value {
      font-weight: 500;
    }
    
    .summary-total {
      font-weight: 700;
      font-size: 1.2rem;
      margin: 1.5rem 0;
      padding-top: 1rem;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    body.dark-mode .summary-total {
      border-top-color: rgba(255, 255, 255, 0.1);
    }
    
    .checkout-btn {
      width: 100%;
      padding: 0.875rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius-sm);
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      font-size: 1rem;
    }
    
    .checkout-btn:hover:not(:disabled) {
      background-color: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.3), 0 2px 4px -1px rgba(37, 99, 235, 0.1);
    }
    
    .checkout-btn:disabled {
      background-color: var(--gray-text);
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    .payment-methods {
      margin-top: 1.5rem;
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .payment-method {
      width: 2.5rem;
      height: 1.75rem;
      object-fit: contain;
      filter: grayscale(30%);
      opacity: 0.7;
      transition: var(--transition);
    }
    
    .payment-method:hover {
      filter: grayscale(0);
      opacity: 1;
      transform: translateY(-2px);
    }
    
    /* ===== Enhanced Coupon Section ===== */
    .coupon-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px dashed rgba(0, 0, 0, 0.15);
    }
    
    body.dark-mode .coupon-section {
      border-top-color: rgba(255, 255, 255, 0.15);
    }
    
    .coupon-title {
      font-size: 0.95rem;
      color: var(--gray-text);
      margin-bottom: 0.5rem;
    }
    
    .coupon-input {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    
    .coupon-input input {
      flex: 1;
      padding: 0.75rem;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: var(--border-radius-sm);
      font-size: 0.9rem;
      transition: var(--transition);
      background-color: var(--light-tertiary);
    }
    
    body.dark-mode .coupon-input input {
      background-color: var(--dark-tertiary);
      color: var(--light-text);
    }
    
    .coupon-input input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    
    .apply-coupon {
      padding: 0 1rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius-sm);
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
      white-space: nowrap;
    }
    
    .apply-coupon:hover {
      background-color: var(--primary-dark);
      transform: translateY(-1px);
    }
    
    .coupon-success {
      color: var(--success-color);
      font-size: 0.85rem;
      margin-top: 0.5rem;
      display: none;
      align-items: center;
      gap: 0.5rem;
      animation: fadeIn 0.3s ease;
    }
    
    .discount-badge {
      background-color: var(--success-color);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 1rem;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 0.5rem;
      animation: pulse 2s infinite;
    }
    
    /* ===== Enhanced Toast Notification ===== */
    .toast {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      background-color: var(--primary-color);
      color: white;
      padding: 1rem 1.25rem;
      border-radius: var(--border-radius-sm);
      box-shadow: var(--card-shadow-hover);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      z-index: 1000;
      transform: translateY(100px);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      max-width: 24rem;
    }
    
    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .toast i {
      font-size: 1.25rem;
    }
    
    .toast.success {
      background-color: var(--success-color);
    }
    
    .toast.error {
      background-color: var(--error-color);
    }
    
    .toast.warning {
      background-color: var(--warning-color);
    }
    
    .toast-close {
      margin-left: auto;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      opacity: 0.8;
      transition: var(--transition);
    }
    
    .toast-close:hover {
      opacity: 1;
      transform: rotate(90deg);
    }
    
    /* ===== Save for Later Section ===== */
    .save-for-later {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    body.dark-mode .save-for-later {
      border-top-color: rgba(255, 255, 255, 0.1);
    }
    
    /* ===== Responsive Design Improvements ===== */
    @media (max-width: 768px) {
      .main-content {
        padding: 0 1rem;
        margin: 1rem auto;
      }
      
      .site-header {
        padding: 0.75rem 1rem;
      }
      
      .header-content {
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      
      .main-nav {
        order: 3;
        width: 100%;
        justify-content: space-around;
        gap: 0.5rem;
        padding: 0.5rem 0;
      }
      
      .user-controls {
        margin-left: auto;
      }
      
      .cart-item {
        flex-direction: column;
      }
      
      .cart-item-image {
        width: 100%;
        height: auto;
        max-height: 12rem;
      }
      
      .cart-item-actions {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }
      
      .quantity-control {
        width: 100%;
        justify-content: space-between;
      }
    }
    
    @media (max-width: 480px) {
      .brand-name {
        font-size: 1.25rem;
      }
      
      .user-controls {
        gap: 0.5rem;
      }
      
      .icon-btn {
        width: 2rem;
        height: 2rem;
        font-size: 1rem;
      }
      
      .user-avatar {
        width: 2rem;
        height: 2rem;
      }
      
      .coupon-input {
        flex-direction: column;
      }
      
      .apply-coupon {
        padding: 0.75rem;
      }
    }
    
    /* ===== Accessibility Improvements ===== */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }
    
    /* ===== Loading State ===== */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .loading-overlay.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .loading-spinner {
      width: 3rem;
      height: 3rem;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* ===== Tooltip ===== */
    .tooltip {
      position: relative;
    }
    
    .tooltip-text {
      visibility: hidden;
      width: 120px;
      background-color: var(--dark-bg);
      color: var(--light-text);
      text-align: center;
      border-radius: var(--border-radius-sm);
      padding: 0.5rem;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.8rem;
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    /* ===== Floating Action Button ===== */
    .fab {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 3.5rem;
      height: 3.5rem;
      border-radius: 50%;
      background-color: var(--primary-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      z-index: 100;
      transition: var(--transition);
      animation: pulse 2s infinite;
    }
    
    .fab:hover {
      background-color: var(--primary-dark);
      transform: translateY(-3px) scale(1.05);
    }
    
    /* ===== Price Change Animation ===== */
    @keyframes priceChange {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    .price-change {
      animation: priceChange 0.5s ease;
    }
    
    /* ===== Confetti Effect ===== */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f00;
      opacity: 0;
      z-index: 9999;
      animation: confettiFall 3s ease-in-out forwards;
    }
    
    @keyframes confettiFall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* ===== Delivery Options Styles ===== */
.delivery-options {
  margin: 1rem 0;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.delivery-option {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem;
  border: 2px solid var(--light-secondary);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  transition: var(--transition);
  background-color: var(--light-tertiary);
}

body.dark-mode .delivery-option {
  background-color: var(--dark-tertiary);
  border-color: var(--dark-secondary);
}

.delivery-option:hover {
  border-color: var(--primary-light);
  transform: translateY(-1px);
}

.delivery-option input[type="radio"] {
  margin: 0;
}

.delivery-option i {
  color: var(--primary-color);
  width: 1rem;
  text-align: center;
}

.delivery-option input[type="radio"]:checked + i + span {
  font-weight: 600;
  color: var(--primary-color);
}

.delivery-option:has(input[type="radio"]:checked) {
  border-color: var(--primary-color);
  background-color: var(--primary-extra-light);
}

body.dark-mode .delivery-option:has(input[type="radio"]:checked) {
  background-color: rgba(37, 99, 235, 0.2);
  border-color: var(--primary-color);
}

/* ===== Enhanced Delivery Options Styles ===== */
.delivery-options {
    margin: 1rem 0;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.delivery-option {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    border: 2px solid var(--light-secondary);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: var(--transition);
    background-color: var(--light-tertiary);
    position: relative;
}

body.dark-mode .delivery-option {
    background-color: var(--dark-tertiary);
    border-color: var(--dark-secondary);
}

.delivery-option:hover {
    border-color: var(--primary-light);
    transform: translateY(-1px);
}

.delivery-option input[type="radio"] {
    margin: 0;
    opacity: 0;
    position: absolute;
}

.delivery-option i {
    color: var(--gray-text);
    width: 1rem;
    text-align: center;
    transition: var(--transition);
}

/* Selected state */
.delivery-option:has(input[type="radio"]:checked) {
    border-color: var(--primary-color);
    background-color: var(--primary-extra-light);
}

body.dark-mode .delivery-option:has(input[type="radio"]:checked) {
    background-color: rgba(37, 99, 235, 0.2);
    border-color: var(--primary-color);
}

.delivery-option:has(input[type="radio"]:checked) i {
    color: var(--primary-color);
}

/* Required field indicator */
.delivery-options::before {
    content: "Required *";
    font-size: 0.8rem;
    color: var(--error-color);
    font-weight: 500;
    margin-bottom: -0.5rem;
}

/* Checkout button disabled state */
.checkout-btn:disabled {
    background-color: var(--gray-text);
    cursor: not-allowed;
    opacity: 0.6;
    transform: none !important;
    box-shadow: none !important;
}

.checkout-btn:disabled:hover {
    background-color: var(--gray-text);
    transform: none !important;
    box-shadow: none !important;
}
/* ===== Enhanced Delivery Options Styles ===== */
.delivery-options {
    margin: 1rem 0;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.delivery-option {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    border: 2px solid var(--light-secondary);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: var(--transition);
    background-color: var(--light-tertiary);
    position: relative;
}

body.dark-mode .delivery-option {
    background-color: var(--dark-tertiary);
    border-color: var(--dark-secondary);
}

.delivery-option:hover {
    border-color: var(--primary-light);
    transform: translateY(-1px);
}

.delivery-option input[type="radio"] {
    margin: 0;
    opacity: 0;
    position: absolute;
    width: 100%;
    height: 100%;
    cursor: pointer;
}

.delivery-option i {
    color: var(--gray-text);
    width: 1rem;
    text-align: center;
    transition: var(--transition);
}

.delivery-option span {
    transition: var(--transition);
}

/* Selected state */
.delivery-option:has(input[type="radio"]:checked) {
    border-color: var(--primary-color);
    background-color: var(--primary-extra-light);
    box-shadow: 0 2px 8px rgba(37, 99, 235, 0.15);
}

body.dark-mode .delivery-option:has(input[type="radio"]:checked) {
    background-color: rgba(37, 99, 235, 0.2);
    border-color: var(--primary-color);
}

.delivery-option:has(input[type="radio"]:checked) i,
.delivery-option:has(input[type="radio"]:checked) span {
    color: var(--primary-color);
    font-weight: 600;
}

/* Required field indicator */
.delivery-options::before {
    content: "Required *";
    font-size: 0.8rem;
    color: var(--error-color);
    font-weight: 500;
    margin-bottom: -0.5rem;
}

/* Checkout button disabled state */
.checkout-btn:disabled {
    background-color: var(--gray-text);
    cursor: not-allowed;
    opacity: 0.6;
    transform: none !important;
    box-shadow: none !important;
}

.checkout-btn:disabled:hover {
    background-color: var(--gray-text);
    transform: none !important;
    box-shadow: none !important;
}
  </style>
</head>

<body class="light-mode">

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
  </div>

  <!-- Header -->
  <header class="site-header">
    <div class="header-content">
      <a href="../../market/market.html" class="brand">
        <img src="../../../images/logo ssi.png" alt="Guildite Logo" class="brand-icon">
        <span class="brand-name">Guildite</span>
      </a>
      
      <nav class="main-nav">
        <a href="../../market/market.html" class="nav-link">Home</a>
      </nav>
      
      <div class="user-controls">
        <button id="darkModeToggle" class="icon-btn tooltip" aria-label="Toggle Dark Mode">
          <i class="fas fa-moon"></i>
          <span class="tooltip-text">Toggle Dark Mode</span>
        </button>
        <a href="../wishlist/wishlist.html" class="icon-btn tooltip" aria-label="Wishlist">
          <span>
          <i class="fas fa-heart"></i>
          </span>
          <span class="tooltip-text">Wishlist</span>
        </a>
        
        <div class="profile-dropdown">
          <img src="../../../images/no profile pic.jpg" alt="User Profile" class="user-avatar">
          <div class="dropdown-content">
            <a href="../../profile/profile.html"><i class="fas fa-user"></i> Profile</a>
            <a href="../orders/orders.html"><i class="fas fa-box"></i> Orders</a>
            <a href="../../delivery/delivery.html"><i class="fas fa-shipping-fast"></i>Carriers</a>
            <a href="../../seller/testsell.html"><i class="fas fa-plus-circle"></i> Seller Workshop</a>
            <a href="../../community/community.html"><i class="fas fa-users"></i>Guild Hall</a>
            <a href="../../map/map.html"><i class="fas fa-map-marker-alt"></i>Map</a>
            <a href="../../home.html" id="logoutBtn"><i class="fas fa-sign-out-alt"></i>Leave Guildite</a>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="main-content">
    <!-- Cart Items Section -->
    <section class="cart-section">
      <h2 class="section-title">
        Your Shopping Cart
        <span id="item-count">0 items</span>
      </h2>
      
      <div class="cart-items" id="cart-items">
        <!-- Cart items will be inserted here by JavaScript -->
      </div>
      
      <!-- Empty Cart Message -->
      <div class="empty-cart" id="empty-cart">
        <div class="empty-cart-icon">
          <i class="fas fa-shopping-cart"></i>
        </div>
        <h3 class="empty-cart-message">Your cart is empty</h3>
        <p class="empty-cart-submessage">Looks like you haven't added anything to your Guild cart yet. Let's get shopping!</p>
        <a href="../../market/market.html" class="continue-shopping">
          <i class="fas fa-arrow-left"></i> Continue Shopping
        </a>
      </div>
      
      <!-- Save for Later Section -->
      <div class="save-for-later" id="save-for-later">
        <h2 class="section-title">Saved for Later</h2>
        <div class="cart-items" id="saved-items">
          <!-- Saved items will be inserted here by JavaScript -->
        </div>
        
        <!-- Empty Saved Items Message -->
        <div class="empty-cart" id="empty-saved">
          <div class="empty-cart-icon">
            <i class="fas fa-bookmark"></i>
          </div>
          <h3 class="empty-cart-message">No saved items</h3>
          <p class="empty-cart-submessage">Items you save for later will appear here</p>
        </div>
      </div>
    </section>
    
    <!-- Order Summary Section -->
    <aside class="order-summary">
  <h2 class="section-title">Order Summary</h2>
  
  <div class="summary-row">
    <span class="summary-label">Subtotal</span>
    <span class="summary-value" id="subtotal">GHC 0.00</span>
  </div>

  <!-- Delivery Options -->
  <div class="delivery-options">
    <label class="delivery-option">
        <input type="radio" name="delivery" value="delivery">
        <i class="fas fa-truck"></i>
        <span>Delivery (GHC 5.00)</span>
    </label>
    <label class="delivery-option">
        <input type="radio" name="delivery" value="pickup">
        <i class="fas fa-store"></i>
        <span>Pickup (FREE)</span>
    </label>
</div>

  <div class="summary-row">
    <span class="summary-label">Delivery Fee</span>
    <span class="summary-value" id="delivery-fee">GHC 5.00</span>
  </div>

  <div class="summary-row">
    <span class="summary-label">Estimated Tax</span>
    <span class="summary-value" id="tax">GHC 0.00</span>
  </div>
      
      <div class="coupon-section">
        <p class="coupon-title">Have a coupon code?</p>
        <div class="coupon-input">
          <input type="text" id="couponCode" placeholder="Enter coupon code">
          <button class="apply-coupon" id="applyCoupon">Apply</button>
        </div>
        <div class="coupon-success" id="couponSuccess">
          <i class="fas fa-check-circle"></i>
          <span>Coupon applied successfully! <span class="discount-badge">10% OFF</span></span>
        </div>
      </div>
      
      <div class="summary-row summary-total">
        <span>Total</span>
        <span id="total">GHC 0.00</span>
      </div>
      
      <button class="checkout-btn" id="checkout-btn" disabled>
        <i class="fas fa-lock"></i> Proceed to Checkout
      </button>
      
      <div class="payment-methods">
        <i class="fa-brands fa-cc-visa payment-method"></i>
        <i class="fa-brands fa-cc-mastercard payment-method"></i>
        <i class="fa-brands fa-cc-paypal payment-method"></i>
        <i class="fa-brands fa-apple-pay payment-method"></i>
      </div>      
    </aside>
  </main>

  <!-- Floating Action Button -->
  <div class="fab" id="fab" title="Back to top">
    <i class="fas fa-arrow-up"></i>
  </div>

  <!-- Toast Notification -->
  <div class="toast" id="toast">
    <i class="fas fa-check-circle"></i>
    <span id="toast-message">Item added to cart</span>
    <button class="toast-close" id="toastClose">
      <i class="fas fa-times"></i>
    </button>
  </div>

 <script type="module">
// --- Firebase Imports ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-database.js";
import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-auth.js";
import { getFirestore, doc, collection, getDoc, setDoc, updateDoc, getDocs } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

// --- Firebase Config ---
const firebaseConfig = {
  apiKey: "AIzaSyBzPa671GH71UvTcZ3dECFPrW4xe1vS9ds",
  authDomain: "marketplace-e0bff.firebaseapp.com",
  projectId: "marketplace-e0bff",
  storageBucket: "marketplace-e0bff.appspot.com",
  messagingSenderId: "892936444768",
  appId: "1:892936444768:web:f595b3a3e5d697988e1c05",
  databaseURL: "https://marketplace-e0bff-default-rtdb.europe-west1.firebasedatabase.app"
};

// --- Init ---
const app = initializeApp(firebaseConfig);
const database = getDatabase(app);
const auth = getAuth(app);
const firestore = getFirestore(app); // ✅ ADD THIS

// ✅ ADD: Sync cart to/from Firestore
// ✅ IMPROVED: Sync cart to/from Firestore
// ✅ UPDATE THIS FUNCTION (line ~33):
async function syncCartWithFirestore() {
  const uid = getUid();
  if (!uid || uid === 'anon') {
    const cart = readJsonKey(getCartKey(), []);
    console.log('✅ Cart synced from Firestore: 0 items (anon)');
    return cart;
  }
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    if (userDoc.exists()) {
      const userData = userDoc.data();
      const firestoreCart = userData.cart || [];
      
      // Update localStorage
      localStorage.setItem(getCartKey(), JSON.stringify(firestoreCart));
      console.log('✅ Cart synced from Firestore:', firestoreCart.length, 'items');
      return firestoreCart;
    } else {
      // No user doc in Firestore yet
      console.log('⚠️ No user document in Firestore');
      const cart = readJsonKey(getCartKey(), []);
      return cart;
    }
  } catch (error) {
    console.error('❌ Error syncing cart with Firestore:', error);
    const cart = readJsonKey(getCartKey(), []);
    return cart;
  }
}


// ✅ ADD THIS FUNCTION AFTER syncCartWithFirestore():
async function syncWishlistWithFirestore() {
  const uid = getUid();
  if (!uid || uid === 'anon') {
    const wishlist = readJsonKey(getSavedKey(), []);
    console.log('✅ Wishlist synced from Firestore: 0 items (anon)');
    return wishlist;
  }
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    if (userDoc.exists()) {
      const userData = userDoc.data();
      const firestoreWishlist = userData.wishlist || [];
      
      // Update localStorage (use direct localStorage to avoid recursion)
      localStorage.setItem(getSavedKey(), JSON.stringify(firestoreWishlist || []));
      console.log('✅ Wishlist synced from Firestore:', firestoreWishlist.length, 'items');
      return firestoreWishlist;
    } else {
      console.log('⚠️ No user document in Firestore for wishlist');
      const wishlist = readJsonKey(getSavedKey(), []);
      return wishlist;
    }
  } catch (error) {
    console.error('❌ Error syncing wishlist with Firestore:', error);
    const wishlist = readJsonKey(getSavedKey(), []);
    return wishlist;
  }
}

// ✅ ADD: Sync orders to Firestore
// ✅ IMPROVED: Sync orders to Firestore
// ✅ FIXED: Update Firestore orders (adds to existing array)
async function updateFirestoreOrder(orderData) {
  const uid = getUid();
  if (!uid || uid === 'anon') return false;
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    let buyerOrders = [];
    if (userDoc.exists()) {
      const userData = userDoc.data();
      buyerOrders = userData.orders || [];
    } else {
      // Create user document if it doesn't exist
      await setDoc(userDocRef, { 
        orders: [], 
        cart: [], 
        wishlist: [],
        createdAt: new Date().toISOString()
      });
    }
    
    // Check if order already exists
    const orderExists = buyerOrders.some(order => 
      order.id === orderData.id || order.orderId === orderData.orderId
    );
    
    if (!orderExists) {
      buyerOrders.unshift(orderData);
      await updateDoc(userDocRef, { orders: buyerOrders });
      console.log('✅ Order added to Firestore');
      return true;
    } else {
      console.log('⚠️ Order already exists in Firestore');
      return false;
    }
  } catch (error) {
    console.error('❌ Error saving order to Firestore:', error);
    return false;
  }
}



// ✅ ADD: Sync saved items to/from Firestore
async function syncSavedWithFirestore() {
  const uid = getUid();
  if (!uid || uid === 'anon') return readJsonKey(getSavedKey(), []);
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    if (userDoc.exists()) {
      const userData = userDoc.data();
      // ✅ Use 'wishlist' key (not 'savedItems')
      const firestoreWishlist = userData.wishlist || [];
      
      // ✅ Get current localStorage cache
      const localStorageWishlist = readJsonKey(getSavedKey(), []);
      
      // ✅ Merge strategy: Prefer Firestore
      // But preserve any local items not yet in Firestore?
      // For now, use Firestore as source of truth
      localStorage.setItem(getSavedKey(), JSON.stringify(firestoreWishlist || []));
console.log('✅ Wishlist synced from Firestore:', firestoreWishlist.length, 'items');
      return firestoreWishlist;
    }
  } catch (error) {
    console.error('Error syncing wishlist with Firestore:', error);
  }
  return readJsonKey(getSavedKey(), []);
}

// ✅ ADD: Update Firestore when cart changes
async function updateFirestoreCart(cartData) {
  const uid = getUid();
  if (!uid || uid === 'anon') return;
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    await updateDoc(userDocRef, { cart: cartData });
    console.log('✅ Cart updated in Firestore');
  } catch (error) {
    console.error('Error updating Firestore cart:', error);
  }
}

// ✅ ADD: Update Firestore when saved items change
// ✅ RENAME THIS FUNCTION (line ~88):
async function updateFirestoreWishlist(wishlistData) { // ✅ RENAME from updateFirestoreSaved
  const uid = getUid();
  if (!uid || uid === 'anon') return;
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    await updateDoc(userDocRef, { wishlist: wishlistData });
    console.log('✅ Wishlist updated in Firestore');
  } catch (error) {
    console.error('Error updating Firestore wishlist:', error);
  }
}



// ---------- Namespaced storage helpers (UID-scoped cart/wishlist/orders) ----------
function getUid() {
  return sessionStorage.getItem('uid') || 'anon';
}
function detectPageRole() {
  try { const r = document?.body?.dataset?.role; if (r) return r.toLowerCase(); } catch(e){}
  const p = window.location.pathname.toLowerCase();
  if (p.includes('testsell') || p.includes('/seller') || p.includes('seller')) return 'seller';
  if (p.includes('delivery') || p.includes('courier')) return 'courier';
  return 'buyer';
}
function nsKey(base, { role=null, uid=null } = {}) {
  const finalRole = role || detectPageRole() || 'buyer';
  const finalUid = uid || getUid() || 'anon';
  return `${base}__${finalRole}__${String(finalUid)}`;
}
function readJsonKey(key, fallback = []) {
  try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); }
  catch(e){ return fallback; }
}

// ✅ THEN UPDATE the writeJsonKey function to call updateFirestoreWishlist:
// ✅ UPDATE THIS FUNCTION (line ~110):
function writeJsonKey(key, data) {
  try { 
    // 1. Write to localStorage cache
    localStorage.setItem(key, JSON.stringify(data || [])); 
    
    // 2. Also update Firestore for cart/wishlist keys (if user is logged in)
    const uid = getUid();
    if (uid && uid !== 'anon') {
      if (key === getCartKey()) {
        updateFirestoreCart(data || []);
      } else if (key === getSavedKey()) { // 'wishlist' key
        updateFirestoreWishlist(data || []); // ✅ Fixed function name
      }
    }
  }
  catch(e){
    console.warn('writeJsonKey failed:', e);
  }
}

// convenience for this page
function getCartKey(){ return nsKey('cart'); }
function getSavedKey(){ return nsKey('wishlist'); } // ✅ Match Firestore
function getOrdersKey(){ return nsKey('orders'); }
// products remain global (shared catalog)
function getProductsKey(){ return 'products'; }

// ----------------- GLOBAL ORDERS (shared truth) -----------------
const ORDERS_GLOBAL = "orders_global";
function getGlobalOrders(){
  try { return JSON.parse(localStorage.getItem(ORDERS_GLOBAL) || '[]'); }
  catch(e){ return []; }
}
function saveGlobalOrders(data){
  try { localStorage.setItem(ORDERS_GLOBAL, JSON.stringify(data || [])); }
  catch(e){ console.warn('saveGlobalOrders failed', e); }
}
function updateGlobalOrder(orderId, updates = {}) {
  try {
    const global = getGlobalOrders();
    const idx = global.findIndex(o => String(o.id) === String(orderId) || String(o.orderId) === String(orderId));
    if (idx === -1) {
      const newEntry = { id: orderId, orderId: orderId, ...updates };
      global.unshift(newEntry);
    } else {
      global[idx] = { ...global[idx], ...updates };
    }
    saveGlobalOrders(global);
    // writing to ORDERS_GLOBAL produces a storage event for other tabs
    return true;
  } catch (e) {
    console.warn('updateGlobalOrder failed', e);
    return false;
  }
}

// --- Helper: basic image URL validator
function isValidImage(url){
  const s = String(url || '').trim();
  if(!s) return false;
  return /^(data:|https?:\/\/|\/|\.)/.test(s) || /\.(jpg|jpeg|png|gif|webp|avif|svg)$/i.test(s);
}
// Add this function after the imports:
function nowISO() { return new Date().toISOString(); }

// --- DOM & app logic ---
document.addEventListener('DOMContentLoaded', async () => {
  // DOM Elements (guarded - some pages may not have all)
  const cartItemsContainer = document.getElementById('cart-items');
  const savedItemsContainer = document.getElementById('saved-items');
  const emptyCartMessage = document.getElementById('empty-cart');
  const emptySavedMessage = document.getElementById('empty-saved');
  const itemCount = document.getElementById('item-count');
  const subtotalEl = document.getElementById('subtotal');
  const taxEl = document.getElementById('tax');
  const totalEl = document.getElementById('total');
  const checkoutBtn = document.getElementById('checkout-btn');
  const darkModeToggle = document.getElementById('darkModeToggle');
  const toast = document.getElementById('toast');
  const toastMessage = document.getElementById('toast-message');
  const toastClose = document.getElementById('toastClose');
  const loadingOverlay = document.getElementById('loadingOverlay');
  const applyCouponBtn = document.getElementById('applyCoupon');
  const couponCodeInput = document.getElementById('couponCode');
  const couponSuccess = document.getElementById('couponSuccess');
  const fab = document.getElementById('fab');

  const DEFAULT_PRODUCT_IMAGE = '../../../images/default-product.jpg';
  const DEFAULT_AVATAR = '../../../images/no profile pic.jpg';

  // Sample product data
  const sampleProducts = [];

  // State (UID-scoped) - SYNC FROM FIRESTORE FIRST
// ✅ UPDATE THIS SECTION (line ~175):
// State (UID-scoped) - SYNC FROM FIRESTORE FIRST
let cart = await syncCartWithFirestore(); // ✅ SYNC FROM FIRESTORE
let savedItems = await syncWishlistWithFirestore(); // ✅ USE NEW SYNC FUNCTION (was syncSavedWithFirestore)

// ✅ Ensure state matches localStorage after sync
cart = readJsonKey(getCartKey(), []);
savedItems = readJsonKey(getSavedKey(), []);

  // Coupon state
let appliedCoupon = localStorage.getItem('appliedCoupon') || null;

 
  // ===== DELIVERY/PICKUP OPTIONS =====
  // Delivery options configuration
  const deliveryOptions = {
      delivery: { price: 5.00, type: "delivery" },
      pickup: { price: 0.00, type: "pickup" }
  };

  // Initialize delivery selection
  let selectedDelivery = JSON.parse(localStorage.getItem("selectedDelivery")) || null;

  // Products loaded from localStorage (global catalog)
async function loadAllProductsFromStorage() {
  try {
    // ✅ Load from Firestore products collection ONLY
    const productsCollection = collection(firestore, "products");
    const querySnapshot = await getDocs(productsCollection);
    
    const firestoreProducts = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      if (data.approved !== false) { // Only show approved products
        firestoreProducts.push({
          id: doc.id,
          title: data.title || data.name || 'Untitled',
          price: Number(data.price || 0),
          quantity: Number(data.quantity || data.qty || 0),
          condition: data.condition || '',
          location: data.location || '',
          description: data.description || '',
          image: data.images?.[0] || data.image || data.img || DEFAULT_PRODUCT_IMAGE,
          images: data.images || (data.image ? [data.image] : []),
          seller: data.seller || 'Seller',
          sellerId: data.sellerId || data.ownerId,
          sellerAvatar: data.sellerAvatar || data.sellerProfileUrl || DEFAULT_AVATAR,
          category: (data.category || data.cat || '').toString().trim().toLowerCase(),
          createdAt: data.createdAt || data.timestamp || nowISO(),
          status: data.status || (Number(data.quantity || data.qty || 0) <= 0 ? 'Out of Stock' : 'Active')
        });
      }
    });
    
    console.log('✅ Loaded products from Firestore:', firestoreProducts.length);
    return firestoreProducts;
    
  } catch(error) {
    console.error('❌ Error loading products from Firestore:', error);
    return [];
  }
}

  let products = await loadAllProductsFromStorage(); // ✅ ADD AWAIT

  // Dark mode preference
  function checkDarkModePreference() {
    const theme = localStorage.getItem('theme');
    if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.body.classList.add('dark-mode');
      if (darkModeToggle) {
        darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        darkModeToggle.setAttribute('aria-label', 'Switch to Light Mode');
      }
    } else {
      document.body.classList.remove('dark-mode');
      if (darkModeToggle) {
        darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
        darkModeToggle.setAttribute('aria-label', 'Switch to Dark Mode');
      }
    }
  }
  checkDarkModePreference();

  // Always reload global products from localStorage to stay up-to-date (best-effort)
  async function reloadProducts() { // ✅ MAKE ASYNC
  products = await loadAllProductsFromStorage(); // ✅ ADD AWAIT
}

  // Get available stock (ensure numeric)
  async function getAvailableStock(productId) { // ✅ MAKE ASYNC
  await reloadProducts(); // ✅ ADD AWAIT
  const product = products.find(p => String(p.id) === String(productId));
  return product ? Number(product.quantity || 0) : 0;
}

  // --- NEW: fetch seller info from Firebase users node ---
  async function getSellerInfo(uid){
    if(!uid) return null;
    try {
      const userRef = ref(database, `users/${uid}`);
      const snap = await get(userRef);
      if(!snap.exists()) return null;
      return snap.val();
    } catch (err) {
      console.warn('getSellerInfo error', err);
      return null;
    }
  }

  // Create cart item element (now async so we can fetch seller data live)
  async function createCartItem(item, index, isSaved = false) {
    const availableStock = await getAvailableStock(item.id);
    const isOutOfStock = availableStock == 0;
    const qty = Number(item.quantity || 1);

    // fallbacks
    let sellerName = item.seller || 'Seller';
    let sellerAvatar = item.sellerAvatar || (`https://i.pravatar.cc/150?img=${encodeURIComponent(item.sellerId || 3)}`);

    // If sellerId exists, try to fetch canonical seller name + avatar from DB
    if (item.sellerId) {
      try {
        const s = await getSellerInfo(item.sellerId);
        if (s) {
          if (s.name) sellerName = s.name;
          if (s.profilePictureUrl && isValidImage(s.profilePictureUrl)) sellerAvatar = s.profilePictureUrl;
        }
      } catch (e) {
        // ignore; keep local fallback
      }
    }

    if(!isValidImage(sellerAvatar)) sellerAvatar = DEFAULT_AVATAR;

    // create element
    const itemElement = document.createElement('div');
    itemElement.className = `cart-item ${isSaved ? 'saved-item' : ''} animate-fade`;
    itemElement.dataset.id = item.id;

    // sanitize minimal strings (avoid heavy libs)
    const title = String(item.title || '');
    const price = Number(item.price || 0).toFixed(2);
    const imageSrc = String(item.image || DEFAULT_PRODUCT_IMAGE);
    const originalPriceHtml = item.originalPrice ? `<p class="original-price">GHC${Number(item.originalPrice).toFixed(2)}</p>` : '';

    itemElement.innerHTML = `
      <img src="${imageSrc}" alt="${title}" class="cart-item-image" loading="lazy" onerror="this.onerror=null;this.src='${DEFAULT_PRODUCT_IMAGE}'">
      <div class="cart-item-details">
        <div>
          <h3 class="cart-item-title">${title}</h3>
          <p class="cart-item-seller">
            <img src="${sellerAvatar}" alt="${sellerName}" class="seller-avatar" onerror="this.onerror=null;this.src='${DEFAULT_AVATAR}'">
            Sold by ${sellerName}
          </p>
          <p class="cart-item-price">GHC${price}</p>
          ${originalPriceHtml}
          ${isOutOfStock ? '<p class="stock-warning" style="color: #ef4444; font-weight: bold;">Out of Stock</p>' : ''}
          ${(!isOutOfStock && qty >= availableStock) ? `<p class="stock-warning" style="color: #f59e0b; font-weight: bold;">Only ${availableStock} available</p>` : ''}
        </div>
        <div class="cart-item-actions">
          <div class="quantity-control">
            <button class="quantity-btn minus" ${qty <= 1 ? 'disabled' : ''} aria-label="Decrease quantity">
              <i class="fas fa-minus"></i>
            </button>
            <input type="text" class="quantity-input" value="${qty}" readonly aria-label="Quantity">
            <button class="quantity-btn plus" aria-label="Increase quantity">
              <i class="fas fa-plus"></i>
            </button>
          </div>

          <div class="action-buttons">
            <button class="remove-btn" aria-label="Remove item">
              <i class="fas fa-trash-alt"></i> Remove
            </button>
            <button class="save-btn" aria-label="${isSaved ? 'Move to Cart' : 'Save for Later'}">
              <i class="fas fa-bookmark"></i> ${isSaved ? 'Move to Cart' : 'Save for Later'}
            </button>
          </div>
        </div>
      </div>
    `;
    return itemElement;
  }

  // Update cart display (async because createCartItem is async)
  async function updateCartDisplay() {
    // reload uid-scoped state from storage (defensive)
    // ✅ Sync from Firestore first
    await syncCartWithFirestore();
await syncWishlistWithFirestore();
  
    // Then reload from localStorage cache
    cart = readJsonKey(getCartKey(), []);
    savedItems = readJsonKey(getSavedKey(), []);

    if (cartItemsContainer) cartItemsContainer.innerHTML = '';
    if (savedItemsContainer) savedItemsContainer.innerHTML = '';

    if (!cart || cart.length === 0) {
      if (emptyCartMessage) emptyCartMessage.style.display = 'flex';
      if (checkoutBtn) checkoutBtn.disabled = true;
      if (itemCount) itemCount.textContent = '0 items';
    } else {
      if (emptyCartMessage) emptyCartMessage.style.display = 'none';
      if (checkoutBtn) checkoutBtn.disabled = false;

      for (let i = 0; i < cart.length; i++) {
        try {
          const cartItem = await createCartItem(cart[i], i);
          if (cartItemsContainer) cartItemsContainer.appendChild(cartItem);
        } catch (e) {
          console.warn('Failed to render cart item', e);
        }
      }
    }

    if (!savedItems || savedItems.length === 0) {
      if (emptySavedMessage) emptySavedMessage.style.display = 'block';
    } else {
      if (emptySavedMessage) emptySavedMessage.style.display = 'none';
      for (let i = 0; i < savedItems.length; i++) {
        try {
          const savedItem = await createCartItem(savedItems[i], i, true);
          if (savedItemsContainer) savedItemsContainer.appendChild(savedItem);
        } catch (e) {
          console.warn('Failed to render saved item', e);
        }
      }
    }

    updateOrderSummary();

    // Ensure minus buttons are correctly enabled/disabled after re-render
    document.querySelectorAll('.cart-item').forEach(el => {
      const qtyInput = el.querySelector('.quantity-input');
      const minusBtn = el.querySelector('.quantity-btn.minus');
      if (!qtyInput || !minusBtn) return;
      const qty = parseInt(qtyInput.value, 10) || 1;
      if (qty <= 1) minusBtn.setAttribute('disabled', 'disabled');
      else minusBtn.removeAttribute('disabled');
    });
  }

  // Update order summary
  // Update order summary
// Update order summary
function updateOrderSummary() {
    const currentCart = readJsonKey(getCartKey(), []);
    const subtotal = currentCart.reduce((sum, item) => sum + ((item.price || 0) * (item.quantity || 0)), 0);
    const tax = subtotal * 0.08;
    
    // Get delivery fee based on selection (0 if no selection)
    const deliveryFee = selectedDelivery ? deliveryOptions[selectedDelivery].price : 0;
    
    let total = subtotal + tax + deliveryFee;
    if (appliedCoupon) total *= 0.9;

    if (subtotalEl) subtotalEl.textContent = `GHC ${subtotal.toFixed(2)}`;
    if (taxEl) taxEl.textContent = `GHC ${tax.toFixed(2)}`;
    const deliveryEl = document.getElementById("delivery-fee");
    if (deliveryEl) deliveryEl.textContent = selectedDelivery ? `GHC ${deliveryFee.toFixed(2)}` : 'Select option';
    if (totalEl) totalEl.textContent = `GHC ${total.toFixed(2)}`;

    const totalItems = currentCart.reduce((sum, item) => sum + (item.quantity || 0), 0);
    if (itemCount) itemCount.textContent = `${totalItems} ${totalItems === 1 ? 'item' : 'items'}`;

    // Enable/disable checkout button based on delivery selection AND cart not empty
    if (checkoutBtn) {
        checkoutBtn.disabled = !selectedDelivery || currentCart.length === 0;
    }

    // Persist selection
    if (selectedDelivery) {
        localStorage.setItem("selectedDelivery", JSON.stringify(selectedDelivery));
    }
}

  // Handle delivery option changes
// Handle delivery option changes
// Handle delivery option changes with proper event handling
// Handle delivery option changes with proper toggle behavior
function handleDeliveryChange(event) {
    const clickedRadio = event.target;
    const clickedValue = clickedRadio.value;
    
    console.log('Before change - Clicked:', clickedValue, 'Current selection:', selectedDelivery);
    
    // Check if we're clicking the currently selected option
    if (clickedValue === selectedDelivery) {
        // Clicking the same option - DESELECT it
        clickedRadio.checked = false;
        selectedDelivery = null;
        console.log('Deselected option');
        showToast('Delivery option cleared');
    } else {
        // Clicking a different option - SELECT it
        // First, uncheck all radio buttons
        document.querySelectorAll('input[name="delivery"]').forEach(radio => {
            radio.checked = false;
        });
        // Then check the clicked one
        clickedRadio.checked = true;
        selectedDelivery = clickedValue;
        console.log('Selected new option:', selectedDelivery);
        showToast(`Selected ${selectedDelivery === 'delivery' ? 'Delivery' : 'Pickup'}`);
    }
    
    console.log('After change - Selected:', selectedDelivery);
    
    updateOrderSummary();
    
    // Update localStorage
    if (selectedDelivery) {
        localStorage.setItem("selectedDelivery", JSON.stringify(selectedDelivery));
    } else {
        localStorage.removeItem("selectedDelivery");
    }
}
// Initialize delivery options
// Initialize delivery options
// Initialize delivery options with click handlers
function initializeDeliveryOptions() {
    // Set initial radio button state from saved selection
    if (selectedDelivery) {
        const radio = document.querySelector(`input[name="delivery"][value="${selectedDelivery}"]`);
        if (radio) radio.checked = true;
    }
    
    // Add click event listeners to the LABELS instead of the radio buttons
    document.querySelectorAll('.delivery-option').forEach(option => {
        option.addEventListener('click', function(e) {
            const radio = this.querySelector('input[type="radio"]');
            const value = radio.value;
            
            console.log('Label clicked - Value:', value, 'Current selection:', selectedDelivery);
            
            // If clicking the currently selected option, deselect it
            if (value === selectedDelivery) {
                radio.checked = false;
                selectedDelivery = null;
                console.log('Deselected via label click');
                showToast('Delivery option cleared');
            } else {
                // Select the new option
                selectedDelivery = value;
                console.log('Selected via label click:', selectedDelivery);
                showToast(`Selected ${selectedDelivery === 'delivery' ? 'Delivery' : 'Pickup'}`);
            }
            
            updateOrderSummary();
            
            // Update localStorage
            if (selectedDelivery) {
                localStorage.setItem("selectedDelivery", JSON.stringify(selectedDelivery));
            } else {
                localStorage.removeItem("selectedDelivery");
            }
        });
    });
    
    updateOrderSummary();
}
  // Load delivery options into DOM (GHC)
  initializeDeliveryOptions();

  // When products changed elsewhere (other tabs), reconcile cart quantities to available stock.
  async function refreshProductsData() {
  // ✅ Sync from Firestore first
  await syncCartWithFirestore();
  await reloadProducts();
  
  const curCart = readJsonKey(getCartKey(), []);
  const adjusted = [];
  
  // Need to check stock for each item
  for (const ci of curCart) {
    const available = await getAvailableStock(ci.id);
    if (available === 0) {
      // keep quantity, show warnings elsewhere
    } else if (ci.quantity > available) {
      ci.quantity = available;
      adjusted.push(`${ci.title} → ${available}`);
    }
  }
  
  if (adjusted.length > 0) {
    showToast(`Cart quantities adjusted to current stock: ${adjusted.join('; ')}`, 'error');
    writeJsonKey(getCartKey(), curCart);
  }
  
  await updateCartDisplay();
}

// Quantity logic: minus allowed (but not below 1), plus blocked when exceed stock (toast)
  async function handleQuantityChange(itemId, change) { // ✅ MAKE ASYNC
  await reloadProducts(); // ✅ ADD AWAIT

  const curCart = readJsonKey(getCartKey(), []);
  const index = curCart.findIndex(i => String(i.id) === String(itemId));
  if (index === -1) return;

  const availableStock = await getAvailableStock(itemId); // ✅ ADD AWAIT
  const currentQty = Number(curCart[index].quantity || 1);

  // DECREASE
  if (change < 0) {
    curCart[index].quantity = Math.max(1, currentQty + change);
    writeJsonKey(getCartKey(), curCart);
    updateCartDisplay();
    showToast('Quantity decreased');
    return;
  }

  // INCREASE
  if (change > 0) {
    if (availableStock <= 0) {
      showToast(`Only 0 available in stock. That's all the seller has.`, 'error');
      return;
    }

    const attempted = currentQty + change;
    if (attempted > availableStock) {
      showToast(`Only ${availableStock} available in stock. That's all the seller has.`, 'error');
      return;
    }

    curCart[index].quantity = attempted;
    writeJsonKey(getCartKey(), curCart);
    updateCartDisplay();
    showToast('Quantity increased');
  }
}

  // Save / Remove (namespaced)
  function toggleSaveItem(itemId, isSavedItem) {
    const curCart = readJsonKey(getCartKey(), []);
    const curSaved = readJsonKey(getSavedKey(), []);
    if (isSavedItem) {
      // move from saved -> cart
      const idx = curSaved.findIndex(i => String(i.id) === String(itemId));
      if (idx === -1) return;
      curCart.push(curSaved.splice(idx, 1)[0]);
    } else {
      // move from cart -> saved
      const idx = curCart.findIndex(i => String(i.id) === String(itemId));
      if (idx === -1) return;
      curSaved.push(curCart.splice(idx, 1)[0]);
    }
    writeJsonKey(getCartKey(), curCart);
    writeJsonKey(getSavedKey(), curSaved);
    updateCartDisplay();
    showToast(isSavedItem ? 'Item moved to cart' : 'Item saved for later');
  }

  function removeItem(itemId, isSavedItem) {
    const curCart = readJsonKey(getCartKey(), []);
    const curSaved = readJsonKey(getSavedKey(), []);
    if (isSavedItem) {
      const idx = curSaved.findIndex(i => String(i.id) === String(itemId));
      if (idx === -1) return;
      curSaved.splice(idx, 1);
      writeJsonKey(getSavedKey(), curSaved);
    } else {
      const idx = curCart.findIndex(i => String(i.id) === String(itemId));
      if (idx === -1) return;
      curCart.splice(idx, 1);
      writeJsonKey(getCartKey(), curCart);
    }
    updateCartDisplay();
    showToast('Item removed from ' + (isSavedItem ? 'saved items' : 'cart'));
  }

  // Event delegation for cart actions
  document.addEventListener('click', async e => { // ✅ MAKE ASYNC
  const cartItem = e.target.closest('.cart-item');
  if (!cartItem) return;
  const itemId = cartItem.dataset.id;
  const isSavedItem = cartItem.classList.contains('saved-item');

  if (e.target.closest('.save-btn')) toggleSaveItem(itemId, isSavedItem);
  else if (e.target.closest('.remove-btn')) removeItem(itemId, isSavedItem);
  else if (e.target.closest('.plus')) await handleQuantityChange(itemId, 1); // ✅ ADD AWAIT
  else if (e.target.closest('.minus')) await handleQuantityChange(itemId, -1); // ✅ ADD AWAIT
});

  // Toast helper
  function showToast(message, type = 'success') {
    if (!toast || !toastMessage) {
      if (type === 'error') console.error(message);
      else console.log(message);
      return;
    }
    toastMessage.textContent = message;
    toast.className = `toast show ${type}`;
    if (type === 'success') createConfetti();
    setTimeout(() => { if (toast) toast.classList.remove('show'); }, 3000);
  }

  function createConfetti() {
    const colors = ['#f44336','#e91e63','#9c27b0','#673ab7','#3f51b5','#2196f3','#03a9f4','#00bcd4','#009688','#4CAF50'];
    for (let i = 0; i < 30; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = `${Math.random()*100}vw`;
      confetti.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
      confetti.style.width = `${Math.random()*10+5}px`;
      confetti.style.height = `${Math.random()*10+5}px`;
      confetti.style.animationDuration = `${Math.random()*2+2}s`;
      document.body.appendChild(confetti);
      setTimeout(() => confetti.remove(), 3000);
    }
  }

  // Coupon
  function applyCoupon() {
    if (!couponCodeInput) return;
    const code = couponCodeInput.value.trim();
    if (!code) {
      showToast('Please enter a coupon code', 'error');
      couponCodeInput.focus();
      return;
    }

    if (loadingOverlay) loadingOverlay.classList.add('active');
    setTimeout(() => {
      if (loadingOverlay) loadingOverlay.classList.remove('active');
      if (code.toUpperCase() === 'Guildite10') {
        appliedCoupon = code;
        localStorage.setItem('appliedCoupon', code);
        if (couponSuccess) couponSuccess.style.display = 'flex';
        showToast('Coupon applied successfully! 10% discount added');
        updateOrderSummary();
      } else {
        showToast('Invalid coupon code', 'error');
        couponCodeInput.classList.add('animate-shake');
        setTimeout(() => couponCodeInput.classList.remove('animate-shake'), 300);
      }
    }, 1000);
  }

  if (applyCouponBtn) applyCouponBtn.addEventListener('click', applyCoupon);
  if (couponCodeInput) couponCodeInput.addEventListener('keypress', e => { if (e.key === 'Enter') applyCoupon(); });

  // Dark Mode toggle
  if (darkModeToggle) {
    darkModeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      if (document.body.classList.contains('dark-mode')) {
        darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        localStorage.setItem('theme','dark');
        showToast('Dark mode enabled');
      } else {
        darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
        localStorage.setItem('theme','light');
        showToast('Light mode enabled');
      }
    });
  }

  // Scroll & FAB
  function scrollToTop() { window.scrollTo({top:0,behavior:'smooth'}); }
  function toggleFab() { if (fab) fab.style.display = window.pageYOffset > 300 ? 'flex' : 'none'; }
  if (fab) fab.addEventListener('click', scrollToTop);
  window.addEventListener('scroll', toggleFab);
  toggleFab();

  // Load seller/payment/shipping options
  function loadSellerOptions(sellerId) {
    const paymentData = JSON.parse(localStorage.getItem("paymentMethods")) || {};
    const deliveryData = JSON.parse(localStorage.getItem("deliveryOptions")) || {};
    const paymentMethods = paymentData[sellerId] || {};
    const deliveryOptions = deliveryData[sellerId] || {};

    const paymentContainer = document.getElementById("payment-methods");
    if (paymentContainer) {
      paymentContainer.innerHTML = "";
      if (paymentMethods.mobileMoney) paymentContainer.innerHTML += `<label><input type="radio" name="payment" value="Mobile Money"> Mobile Money</label><br>`;
      if (paymentMethods.cod) paymentContainer.innerHTML += `<label><input type="radio" name="payment" value="Cash on Delivery"> Cash on Delivery</label><br>`;
      if (paymentMethods.bank) paymentContainer.innerHTML += `<label><input type="radio" name="payment" value="Bank Transfer"> Bank Transfer</label><br>`;
    }

    const shippingContainer = document.getElementById("shipping-options");
    if (shippingContainer) {
      shippingContainer.innerHTML = "";
      if (deliveryOptions.standard) {
        shippingContainer.innerHTML += `
          <label>
            <input type="radio" name="shipping" value="standard">
            Standard - GHC${deliveryOptions.standard.price} (${deliveryOptions.standard.time})
          </label><br>`;
      }
      if (deliveryOptions.express) {
        shippingContainer.innerHTML += `
          <label>
            <input type="radio" name="shipping" value="express">
            Express - GHC${deliveryOptions.express.price} (${deliveryOptions.express.time})
          </label><br>`;
      }
    }
  }
  
  // popularity helpers (same as market page)
  function getPopularity(pid){
    try {
      return JSON.parse(localStorage.getItem(`popularity__${pid}`) || '{"views":0,"wishlistCount":0,"purchaseCount":0}');
    } catch { return {views:0,wishlistCount:0,purchaseCount:0}; }
  }
  function setPopularity(pid,data){
    localStorage.setItem(`popularity__${pid}`, JSON.stringify(data));
  }
  function bumpPopularity(pid,field){
    const pop = getPopularity(pid);
    pop[field] = (pop[field]||0)+1;
    setPopularity(pid,pop);
  }
  

  // ----------------------------
  // CHECKOUT (robust buyer + per-seller copies + pings)
  // ----------------------------
  // --- CHECKOUT (Create SEPARATE orders for each seller) ---
// --- CHECKOUT (Create SEPARATE orders for each seller) ---
// --- CHECKOUT (Create SEPARATE orders for each seller) ---
// --- CHECKOUT with FULL Firestore Integration ---
if (checkoutBtn) {
  checkoutBtn.addEventListener('click', async () => {
    const curCart = readJsonKey(getCartKey(), []);
    
    // Validate delivery selection
    if (!selectedDelivery) {
      showToast('Please select delivery or pickup option', 'error');
      return;
    }
    
    if (!curCart || curCart.length === 0) {
      showToast('Your cart is empty', 'error');
      return;
    }

    // Validate stock
    let outOfStockItems = [];
    let exceededStockItems = [];

    const allProducts = await loadAllProductsFromStorage();

    curCart.forEach(item => {
      const prod = allProducts.find(p => String(p.id) === String(item.id));
      const availableStock = prod ? Number(prod.quantity || 0) : 0;

      if (availableStock <= 0) {
        outOfStockItems.push(item.title);
      } else if (item.quantity > availableStock) {
        exceededStockItems.push({
          title: item.title,
          requested: item.quantity,
          available: availableStock
        });
      }
    });

    if (outOfStockItems.length > 0) {
      showToast(`Out of stock: ${outOfStockItems.join(', ')}`, 'error');
      return;
    }
    if (exceededStockItems.length > 0) {
      const msg = exceededStockItems
        .map(i => `${i.title} (only ${i.available} available)`)
        .join(', ');
      showToast(`Quantity exceeds available stock: ${msg}`, 'error');
      return;
    }

    if (loadingOverlay) loadingOverlay.classList.add('active');

    try {
      // --- FETCH buyer profile ---
      let buyerInfo = {};
      const currentUser = auth.currentUser;
      if (currentUser) {
        const snap = await get(ref(database, `users/${currentUser.uid}`));
        const u = snap.exists() ? snap.val() : {};
        buyerInfo = {
          uid: currentUser.uid,
          name: u.name || currentUser.displayName || currentUser.email?.split('@')[0] || 'Buyer',
          email: u.email || currentUser.email || '',
          phone: u.phone || '',
          room: u.room || u.roomnumber || u.roomNumber || '',
          roomNumber: u.roomNumber || u.room || u.roomnumber || '',
          roomnumber: u.roomnumber || u.room || u.roomNumber || '',
          index: u.index || '',
          program: u.program || '',
          profilePictureUrl: u.profilePictureUrl || ''
        };
      } else {
        buyerInfo = { 
          uid: sessionStorage.getItem('uid') || 'anon', 
          name: 'Guest', 
          email: '', 
          phone: '', 
          roomnumber: '' 
        };
      }

      // Group items by sellerId
      const bySeller = {};
      curCart.forEach(item => {
        const sid = item.sellerId ? String(item.sellerId) : 'unknown_seller';
        if (!bySeller[sid]) bySeller[sid] = [];
        bySeller[sid].push(item);
      });

      console.log('📦 Grouped items by seller:', bySeller);

      const sellerIds = Object.keys(bySeller).filter(sid => sid !== 'unknown_seller');
      const createdOrders = [];
      
      // Create SEPARATE order for each seller in Firestore
      for (const sellerId of sellerIds) {
        const sellerItems = bySeller[sellerId];
        
        // Calculate totals for THIS seller only
        const sellerSubtotal = sellerItems.reduce((sum, item) => 
          sum + ((item.price || 0) * (item.quantity || 1)), 0
        );
        
        const sellerTax = sellerSubtotal * 0.08;
        
        // 🔥 UNIQUE ORDER ID
        const uniqueOrderId = `CM-${Date.now()}-${sellerId}-${Math.random().toString(36).substr(2, 5)}`;
        const timestamp = new Date().toISOString();
        
        // 🔥 Create complete order object
        const sellerOrder = {
          id: uniqueOrderId,
          orderId: uniqueOrderId,
          
          // Dates
          createdAt: timestamp,
          updatedAt: timestamp,
          date: new Date().toLocaleDateString('en-GB', { month: 'long', day: 'numeric', year: 'numeric' }),
          timestamp: Date.now(),
          
          // Order status
          status: 'Pending',
          progressStep: 1,
          
          // Items
          items: sellerItems.map(item => ({
            id: item.id,
            name: item.title,
            price: item.price,
            quantity: item.quantity,
            image: item.image,
            seller: item.seller || null,
            sellerId: item.sellerId || null,
            productId: item.id
          })),
          
          // Delivery
          deliveryType: selectedDelivery,
          deliveryOption: selectedDelivery === 'delivery' ? 'Delivery' : 'Pickup',
          deliveryFee: deliveryOptions[selectedDelivery].price,
          deliveryCode: Math.floor(100000 + Math.random() * 900000).toString(),
          
          // Financials
          subtotal: sellerSubtotal,
          tax: sellerTax,
          total: sellerSubtotal + sellerTax + deliveryOptions[selectedDelivery].price,
          
          // People
          buyerId: buyerInfo.uid,
          buyerName: buyerInfo.name || '',
          buyerEmail: buyerInfo.email || '',
          buyerPhone: buyerInfo.phone || '',
          buyerRoom: buyerInfo.roomnumber || '',
          buyerAvatar: buyerInfo.profilePictureUrl || DEFAULT_AVATAR,
          
          sellerId: sellerId,
          sellerName: sellerItems[0]?.seller || 'Seller',
          
          // Metadata
          platform: 'marketplace',
          couponApplied: appliedCoupon || null,
          discount: appliedCoupon ? sellerSubtotal * 0.1 : 0,
          
          // For notifications
          buyerNotified: false,
          sellerNotified: false,
          readBySeller: false,
          readByBuyer: true
        };

        console.log(`🛍️ Creating Firestore order for seller ${sellerId}:`, sellerOrder.id);

        // 🔥 1. SAVE ORDER TO FIRESTORE (Primary Storage)
        try {
          // Save to Firestore orders collection
          const orderDocRef = doc(firestore, "orders", uniqueOrderId);
          await setDoc(orderDocRef, sellerOrder);
          console.log(`✅ Order saved to Firestore: ${uniqueOrderId}`);
          
          // Also add to seller's subcollection
          const sellerOrderRef = doc(collection(firestore, `users/${sellerId}/orders`), uniqueOrderId);
          await setDoc(sellerOrderRef, sellerOrder);
          console.log(`✅ Order saved to seller's subcollection`);
          
          createdOrders.push(sellerOrder);
        } catch (firestoreError) {
          console.error('❌ Firestore save error:', firestoreError);
          throw new Error(`Failed to save order for seller ${sellerId}`);
        }

        // 🔥 2. UPDATE PRODUCT QUANTITIES in Firestore
        for (const item of sellerItems) {
          try {
            const productRef = doc(firestore, "products", item.id);
            const productDoc = await getDoc(productRef);
            
            if (productDoc.exists()) {
              const currentQty = Number(productDoc.data().quantity || 0);
              const newQty = Math.max(0, currentQty - item.quantity);
              
              await updateDoc(productRef, {
                quantity: newQty,
                sold: (productDoc.data().sold || 0) + item.quantity,
                lastSold: timestamp
              });
              
              console.log(`📦 Updated product ${item.id}: ${currentQty} → ${newQty}`);
            }
          } catch (updateError) {
            console.error(`❌ Failed to update product ${item.id}:`, updateError);
          }
        }

        // 🔥 3. UPDATE BUYER'S ORDERS ARRAY in Firestore
        try {
          const uid = getUid();
          if (uid && uid !== 'anon') {
            const userDocRef = doc(firestore, "users", uid);
            const userDoc = await getDoc(userDocRef);
            
            let buyerOrders = [];
            if (userDoc.exists()) {
              const userData = userDoc.data();
              buyerOrders = userData.orders || [];
            }
            
            // Add order to buyer's orders array
            buyerOrders.unshift({
              orderId: uniqueOrderId,
              id: uniqueOrderId,
              date: sellerOrder.date,
              status: 'Pending',
              total: sellerOrder.total,
              sellerName: sellerOrder.sellerName,
              itemCount: sellerItems.length,
              deliveryType: selectedDelivery
            });
            
            await updateDoc(userDocRef, { 
              orders: buyerOrders,
              updatedAt: timestamp
            });
            
            console.log(`✅ Order added to buyer's Firestore profile`);
          }
        } catch (buyerUpdateError) {
          console.error('❌ Failed to update buyer profile:', buyerUpdateError);
        }

        // 🔥 4. UPDATE SELLER'S ORDERS ARRAY in Firestore
        try {
          const sellerDocRef = doc(firestore, "users", sellerId);
          const sellerDoc = await getDoc(sellerDocRef);
          
          if (sellerDoc.exists()) {
            const sellerData = sellerDoc.data();
            let sellerOrders = sellerData.orders || [];
            
            sellerOrders.unshift({
              orderId: uniqueOrderId,
              id: uniqueOrderId,
              date: sellerOrder.date,
              status: 'Pending',
              total: sellerOrder.total,
              buyerName: buyerInfo.name,
              itemCount: sellerItems.length,
              deliveryType: selectedDelivery,
              read: false // Mark as unread for seller
            });
            
            await updateDoc(sellerDocRef, { 
              orders: sellerOrders,
              updatedAt: timestamp,
              hasUnreadOrders: true
            });
            
            console.log(`✅ Order added to seller's Firestore profile`);
          }
        } catch (sellerUpdateError) {
          console.error('❌ Failed to update seller profile:', sellerUpdateError);
        }

        // 🔥 5. SEND REAL-TIME NOTIFICATION
        try {
          // Create notification in Firestore
          const notificationRef = doc(collection(firestore, "notifications"));
          await setDoc(notificationRef, {
            type: 'new_order',
            orderId: uniqueOrderId,
            sellerId: sellerId,
            buyerId: buyerInfo.uid,
            buyerName: buyerInfo.name,
            amount: sellerOrder.total,
            timestamp: timestamp,
            read: false,
            title: 'New Order Received',
            message: `You have a new order from ${buyerInfo.name}`
          });
          console.log(`🔔 Notification created for seller ${sellerId}`);
        } catch (notifyError) {
          console.error('❌ Failed to create notification:', notifyError);
        }
      }

      // 🔥 6. CLEAR CART (Both Local and Firestore)
      writeJsonKey(getCartKey(), []);
      
      // Clear from Firestore
      const uid = getUid();
      if (uid && uid !== 'anon') {
        const userDocRef = doc(firestore, "users", uid);
        await updateDoc(userDocRef, { 
          cart: [],
          updatedAt: new Date().toISOString()
        });
        console.log('✅ Cart cleared from Firestore');
      }

      // 🔥 7. UPDATE POPULARITY COUNTERS
      curCart.forEach(item => {
        bumpPopularity(item.id, 'purchaseCount');
        
        // Also update product popularity in Firestore
        try {
          const productRef = doc(firestore, "products", item.id);
          getDoc(productRef).then(docSnap => {
            if (docSnap.exists()) {
              const current = docSnap.data();
              updateDoc(productRef, {
                purchaseCount: (current.purchaseCount || 0) + 1,
                lastPurchased: new Date().toISOString()
              });
            }
          });
        } catch (e) {
          console.warn('Failed to update product popularity:', e);
        }
      });

      // 🔥 8. UPDATE LOCAL STORAGE (Backup/Offline Support)
      try {
        // Save to global orders (backup)
        const globalOrders = getGlobalOrders();
        createdOrders.forEach(order => {
          if (!globalOrders.some(o => o.id === order.id)) {
            globalOrders.unshift(order);
          }
        });
        saveGlobalOrders(globalOrders);
        
        // Save to seller-specific localStorage (backup)
        sellerIds.forEach(sellerId => {
          const sellerOrdersKey = `orders__seller__${sellerId}`;
          const sellerOrders = JSON.parse(localStorage.getItem(sellerOrdersKey) || '[]');
          const orderForSeller = createdOrders.find(o => o.sellerId === sellerId);
          if (orderForSeller && !sellerOrders.some(o => o.id === orderForSeller.id)) {
            sellerOrders.unshift(orderForSeller);
            localStorage.setItem(sellerOrdersKey, JSON.stringify(sellerOrders));
          }
          
          // Ping for real-time updates
          localStorage.setItem(`orders_ping__seller__${sellerId}`, String(Date.now()));
        });
        
        // Ping for global updates
        localStorage.setItem('orders_global_ping', String(Date.now()));
      } catch (localStorageError) {
        console.warn('LocalStorage backup failed:', localStorageError);
      }

      // 🔥 9. CLEAR COUPON IF APPLIED
      if (appliedCoupon) {
        localStorage.removeItem('appliedCoupon');
        appliedCoupon = null;
        if (couponSuccess) couponSuccess.style.display = 'none';
      }

      // 🔥 10. SUCCESS HANDLING
      if (loadingOverlay) loadingOverlay.classList.remove('active');
      
      await updateCartDisplay();
      
      showToast(`Checkout successful! ${createdOrders.length} order(s) created`, 'success');
      
      // Create confetti celebration
      createConfetti();
      
      // Redirect to orders page
      setTimeout(() => {
        window.location.href = '../orders/orders.html';
      }, 2000);

    } catch (error) {
      console.error('❌ Checkout failed:', error);
      
      if (loadingOverlay) loadingOverlay.classList.remove('active');
      showToast(`Checkout failed: ${error.message}`, 'error');
    }
  });
}
// Helper: Generate order number
function generateOrderNumber(sellerId) {
  const date = new Date();
  const year = date.getFullYear().toString().substr(-2);
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `ORD-${year}${month}${day}-${sellerId.substr(0, 3).toUpperCase()}-${random}`;
}

// Helper: Update product quantities in Firestore
async function updateProductQuantities(items) {
  const batch = writeBatch(firestore);
  
  for (const item of items) {
    const productRef = doc(firestore, "products", item.id);
    const productDoc = await getDoc(productRef);
    
    if (productDoc.exists()) {
      const currentQty = Number(productDoc.data().quantity || 0);
      const newQty = Math.max(0, currentQty - item.quantity);
      
      batch.update(productRef, {
        quantity: newQty,
        sold: (productDoc.data().sold || 0) + item.quantity,
        lastUpdated: new Date().toISOString()
      });
    }
  }
  
  await batch.commit();
  console.log('✅ Product quantities updated in Firestore');
}

// Helper: Create order in Firestore
async function createFirestoreOrder(orderData) {
  try {
    // Save to main orders collection
    const orderRef = doc(firestore, "orders", orderData.id);
    await setDoc(orderRef, orderData);
    
    // Save to buyer's orders subcollection
    const buyerOrderRef = doc(collection(firestore, `users/${orderData.buyerId}/orders`), orderData.id);
    await setDoc(buyerOrderRef, orderData);
    
    // Save to seller's orders subcollection
    const sellerOrderRef = doc(collection(firestore, `users/${orderData.sellerId}/orders`), orderData.id);
    await setDoc(sellerOrderRef, orderData);
    
    return true;
  } catch (error) {
    console.error('❌ Failed to create Firestore order:', error);
    throw error;
  }
}

// Helper: Send notification
async function sendOrderNotification(sellerId, orderId, buyerName) {
  try {
    const notificationRef = doc(collection(firestore, "notifications"));
    await setDoc(notificationRef, {
      type: 'new_order',
      recipientId: sellerId,
      orderId: orderId,
      title: 'New Order Received',
      message: `You have a new order from ${buyerName}`,
      timestamp: new Date().toISOString(),
      read: false,
      actionUrl: `/seller/orders.html?order=${orderId}`
    });
    return true;
  } catch (error) {
    console.error('❌ Failed to send notification:', error);
    return false;
  }
}
  // Toast close handler
  if (toastClose) toastClose.addEventListener('click', ()=> { if (toast) toast.classList.remove('show'); });

  // Initial load - refresh products data (no automatic removal; user can still reduce)
  await refreshProductsData();

  if (appliedCoupon && couponCodeInput) {
    couponCodeInput.value = appliedCoupon;
    if (couponSuccess) couponSuccess.style.display = 'flex';
    updateOrderSummary();
  }

  // small UI touches
  setTimeout(()=>document.querySelectorAll('.cart-item').forEach((item,index)=>item.style.animationDelay=`${index*0.1}s`),100);

  // Watch system dark mode changes
  const m = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
  if (m && m.addEventListener) m.addEventListener('change', e => { if (!localStorage.getItem('theme')) checkDarkModePreference(); });

  // Ensure initial render
  await updateCartDisplay();
});

// --- Auth Handling (outside DOMContentLoaded) ---
const avatarEl = document.querySelector('.user-avatar');
const logoutBtn = document.getElementById('logoutBtn');

onAuthStateChanged(auth, async (user) => {
  if (!user) {
    // If page requires auth, redirect (but don't overwrite sessionStorage if other pages set it)
    window.location.href = "../../../index.html";
    return;
  }

  // ensure sessionStorage uid is set (home sets this too; this is defensive)
  try { sessionStorage.setItem('uid', user.uid); } catch(e){}

  const userRef = ref(database, `users/${user.uid}`);
  try {
    const snapshot = await get(userRef);
    if (!snapshot.exists()) {
      window.location.href = "../../../index.html";
      return;
    }
    const userData = snapshot.val();
    if (userData.declined) { window.location.href = "../../../adminlogic/declined/declined.html"; return; }
    if (userData.banned) { window.location.href = "../../../adminlogic/banned/banned.html"; return; }

    // Update avatar
    if (avatarEl) {
      avatarEl.src = userData.profilePictureUrl || "../../../images/no profile pic.jpg";
      avatarEl.alt = (userData.name || "User") + "'s profile picture";
    }
  } catch(err){
    console.warn('Auth lookup failed', err);
  }
});

// Logout
if (logoutBtn) {
  logoutBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    await signOut(auth);
    sessionStorage.removeItem('uid');
    window.location.href = "../../../index.html";
  });
}

// Storage sync (namespaced keys + orders_ping + global orders)
window.addEventListener('storage', async (e) => { // ✅ ADD ASYNC
  const cartKey = getCartKey();
  const savedKey = getSavedKey();
  const ordersKey = getOrdersKey();
  const productsKey = getProductsKey();

  if (!e.key) return;

  // existing namespaced keys (cart/saved/products/orders) -> re-render
  if (e.key === cartKey || e.key === savedKey || e.key === productsKey || e.key === ordersKey) {
    clearTimeout(window.__cart_render_timeout);
    window.__cart_render_timeout = setTimeout(()=> {
      document.dispatchEvent(new Event('cartStorageUpdated'));
    }, 80);
    return;
  }

  // NEW: respond to order pings from buyer/seller actions on other tabs
  try {
    if (e.key.startsWith('orders_ping__') || e.key === ORDERS_GLOBAL || e.key === 'orders_global_ping') {
      // if a ping happened or global changed, reconcile products and cart and re-render
      try {await reloadProducts(); } catch(_) {}
      // small async fire-and-forget that refreshes quantities and UI
      (async () => {
        try { await refreshProductsData(); }
        catch (err) {
          try { await updateCartDisplay(); } catch(e){ console.warn('cart re-render after ping failed', e); }
        }
      })();
      // debug
      console.info('orders_ping / ORDERS_GLOBAL detected -> refreshProductsData triggered:', e.key);
      return;
    }
  } catch(err) {
    console.warn('orders_ping handler error', err);
  }
});

// allow pages to listen to this event to refresh UI
document.addEventListener('cartStorageUpdated', async ()=> {
  try { await (typeof updateCartDisplay === 'function' ? updateCartDisplay() : Promise.resolve()); } catch(e){}
});
</script>








</body>
</html>