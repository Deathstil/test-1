<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orders | Guildite</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
    /* ===== Base Styles ===== */
        :root {
            --primary-color: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #93c5fd;
            --dark-bg: #0f172a;
            --dark-secondary: #1e293b;
            --light-bg: #f8fafc;
            --light-text: #f8fafc;
            --dark-text: #0f172a;
            --gray-text: #64748b;
            --card-bg: #ffffff;
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --error-color: #ef4444;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --border-radius: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-bg);
            color: var(--dark-text);
            line-height: 1.5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 14px;
        }

        body.dark-mode {
            background-color: var(--dark-bg);
            color: var(--light-text);
        }

        /* ===== Animations ===== */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animate-fade {
            animation: fadeIn 0.5s ease forwards;
        }

        /* ===== Header Styles ===== */
        header {
            background-color: var(--dark-bg);
            padding: 12px 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: white;
            font-weight: 600;
            font-size: 1.2rem;
        }

        .logo img {
            width: 32px;
            height: 32px;
            border-radius: 5px;
            transition: var(--transition);
        }

        .logo:hover img {
            transform: rotate(-5deg);
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .icon-btn {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            transition: var(--transition);
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            position: relative;
        }

        .icon-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .cart-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* ===== Profile Dropdown ===== */
        .profile-dropdown {
            position: relative;
            display: inline-block;
        }

        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            border: 2px solid white;
            transition: var(--transition);
        }

        .user-avatar:hover {
            transform: scale(1.1);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: var(--dark-bg);
            min-width: 160px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 101;
            border-radius: 6px;
            overflow: hidden;
        }

        body.dark-mode .dropdown-content {
            background-color: var(--dark-bg);
            border: 1px solid var(--dark-secondary);
        }

        .dropdown-content a {
            color: var(--light-text);
            padding: 10px 12px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: var(--transition);
            font-size: 0.85rem;
        }

        .dropdown-content a:hover {
            background-color: var(--primary-dark);
        }

        .dropdown-content a i {
            width: 16px;
            text-align: center;
        }

        .dropdown-content .divider {
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            margin: 6px 0;
        }

        .show {
            display: block;
        }

        /* ===== Main Content ===== */
        main {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 16px;
            flex: 1;
        }

        .page-header {
            margin-bottom: 24px;
            text-align: center;
        }

        .page-header h1 {
            font-size: 1.6rem;
            margin-bottom: 8px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .page-header p {
            color: var(--gray-text);
            font-size: 0.95rem;
            max-width: 500px;
            margin: 0 auto;
        }

        /* ===== Order Tracking ===== */
        .tracking-container {
            display: grid;
            gap: 16px;
        }

        .tracking-card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 16px;
            box-shadow: var(--card-shadow);
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
        }

        body.dark-mode .tracking-card {
            background-color: var(--dark-secondary);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .tracking-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
        }

        .tracking-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--primary-color), var(--primary-light));
        }

        .order-header {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 16px;
        }

        .order-info {
            flex: 1;
        }

        .order-id {
            font-weight: 600;
            color: var(--primary-color);
            font-size: 1rem;
            margin-bottom: 4px;
        }

        .order-date {
            color: var(--gray-text);
            font-size: 0.85rem;
        }

        .order-status {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: capitalize;
            gap: 6px;
        }

        .status-processing {
            background-color: rgba(37, 99, 235, 0.1);
            color: var(--primary-color);
        }

        .status-shipped {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
        }

        .status-delivered {
            background-color: rgba(37, 99, 235, 0.1);
            color: var(--primary-color);
        }

        .status-cancelled {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
        }

        /* ===== Progress Tracker ===== */
        .progress-tracker {
            margin: 20px 0;
            position: relative;
        }

        .progress-steps {
            display: flex;
            justify-content: space-between;
            position: relative;
            margin-bottom: 16px;
        }

        .progress-steps::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 3px;
            background-color: #e5e7eb;
            transform: translateY(-50%);
            z-index: 1;
            border-radius: 2px;
        }

        body.dark-mode .progress-steps::before {
            background-color: #374151;
        }

        .progress-bar {
            position: absolute;
            top: 50%;
            left: 0;
            height: 3px;
            background: linear-gradient(to right, var(--primary-color), var(--primary-light));
            transform: translateY(-50%);
            z-index: 2;
            border-radius: 2px;
            width: var(--progress);
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 3;
            position: relative;
        }

        .step-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            transition: var(--transition);
            font-size: 0.9rem;
            color: #9ca3af;
        }

        body.dark-mode .step-icon {
            background-color: #374151;
            color: #6b7280;
        }

        .step.active .step-icon {
            background: linear-gradient(to bottom right, var(--primary-color), var(--primary-light));
            color: white;
        }

        .step.completed .step-icon {
            background-color: var(--success-color);
            color: white;
        }

        .step-label {
            font-size: 0.75rem;
            color: var(--gray-text);
            text-align: center;
            font-weight: 500;
        }

        .step.active .step-label {
            color: var(--primary-color);
            font-weight: 600;
        }

        .step.completed .step-label {
            color: var(--success-color);
            font-weight: 600;
        }

        /* ===== Order Items ===== */
        .order-items {
            margin-top: 16px;
            border-radius: 6px;
            overflow: hidden;
        }

        .order-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            transition: var(--transition);
        }

        body.dark-mode .order-item {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }

        .order-item:hover {
            background-color: rgba(37, 99, 235, 0.03);
        }

        body.dark-mode .order-item:hover {
            background-color: rgba(37, 99, 235, 0.08);
        }

        .order-item:last-child {
            border-bottom: none;
        }

        .item-image {
            width: 70px;
            height: 70px;
            border-radius: 6px;
            object-fit: cover;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .item-image {
            border-color: rgba(255, 255, 255, 0.1);
        }

        .order-item:hover .item-image {
            transform: scale(1.03);
        }

        .item-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .item-name {
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 0.95rem;
        }

        .item-meta {
            display: flex;
            gap: 12px;
            font-size: 0.85rem;
        }

        .item-price {
            color: var(--gray-text);
            font-weight: 500;
        }

        .item-quantity {
            color: var(--gray-text);
        }

        .item-seller {
            color: var(--primary-color);
            font-size: 0.8rem;
            margin-top: 6px;
            font-weight: 500;
        }

        /* ===== Order Summary ===== */
        .order-summary {
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .order-summary {
            border-top-color: rgba(255, 255, 255, 0.1);
        }

        .summary-label {
            color: var(--gray-text);
            font-size: 0.9rem;
        }

        .summary-value {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .total {
            font-size: 1.1rem;
            color: var(--primary-color);
            font-weight: 700;
        }

        /* ===== Order Actions ===== */
        .order-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 10px 16px;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            flex: 1;
            min-width: 120px;
            justify-content: center;
        }

        .primary-btn {
            background: linear-gradient(to right, var(--primary-color), var(--primary-light));
            color: white;
        }

        .primary-btn:hover {
            transform: translateY(-2px);
        }

        .secondary-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: var(--gray-text);
        }

        .secondary-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        body.dark-mode .secondary-btn {
            border-color: #4b5563;
            color: #9ca3af;
        }

        body.dark-mode .secondary-btn:hover {
            border-color: var(--primary-light);
            color: var(--primary-light);
        }

        /* ===== Empty State ===== */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            margin: 20px 0;
        }

        body.dark-mode .empty-state {
            background-color: var(--dark-secondary);
        }

        .empty-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 12px;
            opacity: 0.8;
        }

        .empty-title {
            font-size: 1.4rem;
            color: var(--dark-text);
            font-weight: 700;
        }

        body.dark-mode .empty-title {
            color: var(--light-text);
        }

        .empty-message {
            color: var(--gray-text);
            max-width: 400px;
            margin: 0 auto 20px;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        /* ===== Footer ===== */
        footer {
            background-color: var(--dark-bg);
            color: white;
            text-align: center;
            padding: 24px 16px;
            margin-top: 40px;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .footer-links a {
            color: white;
            text-decoration: none;
            transition: var(--transition);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .footer-links a:hover {
            opacity: 0.8;
        }

        .footer-copyright {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        /* ===== Responsive Design ===== */
        @media (min-width: 480px) {
            .order-header {
                flex-direction: row;
                align-items: flex-start;
                justify-content: space-between;
            }
            
            .order-actions {
                flex-wrap: nowrap;
            }
            
            .action-btn {
                flex: 0 1 auto;
            }
        }

        @media (min-width: 640px) {
            main {
                padding: 0 20px;
            }
            
            .page-header h1 {
                font-size: 1.8rem;
            }
            
            .tracking-card {
                padding: 20px;
            }
            
            .order-item {
                padding: 16px;
            }
            
            .item-image {
                width: 80px;
                height: 80px;
            }
        }

        @media (min-width: 768px) {
            header {
                padding: 12px 20px;
            }
            
            .logo {
                font-size: 1.3rem;
            }
            
            .logo img {
                width: 36px;
                height: 36px;
            }
            
            .page-header h1 {
                font-size: 2rem;
            }
            
            .tracking-container {
                gap: 20px;
            }
            
            .progress-steps {
                margin-bottom: 20px;
            }
            
            .step-icon {
                width: 36px;
                height: 36px;
            }
            
            .step-label {
                font-size: 0.8rem;
            }
        }

        @media (min-width: 1024px) {
            .tracking-container {
                grid-template-columns: 1fr;
            }
            
            .item-image {
                width: 90px;
                height: 90px;
            }
        }

        @media (max-width: 480px) {
            .progress-steps {
                flex-wrap: wrap;
                gap: 12px;
                justify-content: flex-start;
            }

            .step {
                flex: 0 0 calc(33.333% - 8px);
            }

            .step-label {
                font-size: 0.7rem;
            }
            
            .order-item {
                flex-direction: column;
                gap: 10px;
            }

            .item-image {
                width: 100%;
                height: auto;
                max-height: 200px;
            }
            
            .footer-links {
                flex-direction: column;
                gap: 12px;
                align-items: center;
            }
            
            .logo span {
                display: none;
            }
        }

        /* Order Type Styling */
.delivery-order {
    border-left: 4px solid #2563eb;
}

.pickup-order {
    border-left: 4px solid #10b981;
}

.success-btn {
    background: linear-gradient(to right, #10b981, #34d399);
    color: white;
    border: none;
    border-radius: var(--border-radius-sm);
    padding: 0.85rem 1.75rem;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.95rem;
}

.success-btn:hover {
    background: linear-gradient(to right, #059669, #10b981);
    transform: translateY(-2px);
    box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.3), 0 2px 4px -1px rgba(16, 185, 129, 0.1);
}
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <a href="../../market/market.html" class="logo" aria-label="Guildite Home">
                <img src="../../../images/logo ssi.png" alt="Guildite Logo" class="brand-logo" width="40" height="40" loading="eager">
                <span>Guildite</span>
            </a>
            <div class="header-actions">
                <button class="icon-btn" id="darkModeToggle">
                    <i class="fas fa-moon"></i>
                </button>
                <a href="../cart/cart.html" class="icon-btn cart-btn" id="cartBtn">
                    <i class="fas fa-shopping-cart"></i>
                    <span class="cart-badge" id="cartBadge">0</span>
                </a>
                <div class="profile-dropdown">
                    <img src="../../../images/no profile pic.jpg" 
                         alt="User profile" class="user-avatar" width="40" height="40" loading="lazy">
                    <div class="dropdown-content" aria-label="User menu">
                        <a href="../../profile/profile.html"><i class="fas fa-user"></i> Profile</a>
                        <a href="../../delivery/delivery.html"><i class="fas fa-shipping-fast"></i>Carriers</a>
                        <a href="../../seller/testsell.html"><i class="fas fa-plus-circle"></i> Seller Workshop</a>
                        <a href="../../community/community.html"><i class="fas fa-users"></i>Guild Hall</a>
                        <a href="../../map/map.html"><i class="fas fa-map-marker-alt"></i>Map</a>

                        <div class="divider"></div>
                        <a href="#" id="logoutBtn"><i class="fas fa-sign-out-alt"></i>Leave Guildite</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main>
        <div class="page-header animate-fade">
            <h1>Your Orders</h1>
            <p>Track your current and past orders, view order details, and manage your purchases</p>
        </div>

        <div class="tracking-container">
          

            </div>
        </div>

        <!-- Empty State (Hidden by default) -->
        <div class="empty-state" style="display: none;">
            <div class="empty-icon">
                <i class="fas fa-box-open"></i>
            </div>
            <h2 class="empty-title">No Orders Yet</h2>
            <p class="empty-message">You haven't placed any orders yet. Start shopping to see your orders here!</p>
            <button class="action-btn primary-btn" onclick="window.location.href='../../market/market.html'">
                <i class="fas fa-shopping-bag"></i> Start Shopping
            </button>
        </div>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-links">
                <a href="../../../help/about.html">About Us</a>
                <a href="../../../help/Contact.html">Contact</a>
                <a href="../../../help/privacy">Privacy Policy</a>
                <a href="../../../help/terms">Terms of Service</a>
                <a href="../../../help/FAQ.html">FAQ</a>
            </div>
            <div class="footer-copyright">
                &copy; 2023 Guildite. All rights reserved.
            </div>
        </div>
    </footer>

<script type="module">
// --- Firebase Imports ----
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-database.js";
import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-auth.js";
import { getFirestore, doc, getDoc, updateDoc, collection, getDocs, query, where, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js"; // ‚úÖ ADD THIS

// --- Firebase Config ---
const firebaseConfig = {
  apiKey: "AIzaSyBzPa671GH71UvTcZ3dECFPrW4xe1vS9ds",
  authDomain: "marketplace-e0bff.firebaseapp.com",
  projectId: "marketplace-e0bff",
  storageBucket: "marketplace-e0bff.appspot.com",
  messagingSenderId: "892936444768",
  appId: "1:892936444768:web:f595b3a3e5d697988e1c05",
  databaseURL: "https://marketplace-e0bff-default-rtdb.europe-west1.firebasedatabase.app"
};

// ADD THIS AT THE TOP (after your imports)
let isRendering = false;
let refreshTimeout = null;

// --- Init ---
const app = initializeApp(firebaseConfig);
const database = getDatabase(app);
const auth = getAuth(app);
const firestore = getFirestore(app); // ‚úÖ ADD THIS

// ---------- Namespaced helpers (UID-scoped keys) ----------
function getUid() {
  return sessionStorage.getItem('uid') || 'anon';
}
function detectPageRole() {
  try { const r = document?.body?.dataset?.role; if (r) return r.toLowerCase(); } catch(e){}
  const p = window.location.pathname.toLowerCase();
  if (p.includes('testsell') || p.includes('/seller') || p.includes('seller')) return 'seller';
  if (p.includes('delivery') || p.includes('courier')) return 'courier';
  return 'buyer';
}
function nsKey(base, { role=null, uid=null } = {}) {
  const finalRole = role || detectPageRole() || 'buyer';
  const finalUid = uid || getUid() || 'anon';
  return `${base}__${finalRole}__${String(finalUid)}`; // ‚úÖ Use calculated values
}
// ---------- Local Storage JSON Helpers ----------
function readJsonKey(key, fallback = []) {
  try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); }
  catch(e){ return fallback; }
}


// ‚úÖ UPDATE THIS FUNCTION:
// ‚úÖ UPDATE writeJsonKey function in orders page:
function writeJsonKey(key, data) {
  try { 
    localStorage.setItem(key, JSON.stringify(data || [])); 
    
    // ‚úÖ ADD Firestore sync for all keys
    const uid = getUid();
    if (uid && uid !== 'anon') {
      if (key === ORDERS_KEY()) {
        updateFirestoreOrders(data || []);
      } else if (key === getCartKey()) { // Use getCartKey() helper
        updateFirestoreCart(data || []);
      } else if (key === getSavedKey()) { // Use getSavedKey() helper
        updateFirestoreWishlist(data || []);
      }
    }
  }
  catch(e){
    console.warn('writeJsonKey failed:', e);
  }
}

// ‚úÖ ADD THIS HELPER FUNCTION:
async function updateFirestoreOrders(ordersData) {
  const uid = getUid();
  if (!uid || uid === 'anon') return;
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    await updateDoc(userDocRef, { orders: ordersData });
    console.log('‚úÖ Orders updated in Firestore');
  } catch (error) {
    console.error('Error updating Firestore orders:', error);
  }
}

// ‚úÖ IF YOU NEED CART SYNC TOO:
async function updateFirestoreCart(cartData) {
  const uid = getUid();
  if (!uid || uid === 'anon') return;
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    await updateDoc(userDocRef, { cart: cartData });
    console.log('‚úÖ Cart updated in Firestore');
  } catch (error) {
    console.error('Error updating Firestore cart:', error);
  }
}

const ORDERS_KEY = () => nsKey('orders');
const CART_KEY = () => nsKey('cart');
const PRODUCTS_KEY = () => 'products'; // global shared catalog

// üî• MISSING FUNCTION: Merge buyer local with global
function mergeBuyerLocalWithGlobal() {
  try {
    const localKey = ORDERS_KEY();
    const local = readJsonKey(localKey, []);
    const global = JSON.parse(localStorage.getItem(ORDERS_GLOBAL) || '[]');
    
    // Start with global (truth)
    const merged = [...global];
    
    // Add any local orders not in global
    local.forEach(localOrder => {
      const exists = merged.some(g => 
        g && localOrder && (String(g.id) === String(localOrder.id) || String(g.orderId) === String(localOrder.orderId))
      );
      if (!exists && localOrder) {
        merged.push(localOrder);
      }
    });
    
    // Ensure status is preserved
    const result = merged.map(order => {
      if (!order) return null;
      
      const status = order.status || 'Pending';
      return {
        ...order,
        status: status,
        progressStep: mapStatusToStep(status)
      };
    }).filter(order => order !== null);
    
    return result;
  } catch (e) {
    console.warn('mergeBuyerLocalWithGlobal failed:', e);
    return readJsonKey(ORDERS_KEY(), []);
  }
}

// --- GLOBAL TRUTH KEY ---
const ORDERS_GLOBAL = "orders_global";

// üî• Sync buyer local storage with global orders (FIXED VERSION)

// ----------------- Sync orders with Firestore -----------------
// ----------------- Firestore Orders Integration -----------------
/* ---------- Sync Orders with Firestore (SIMPLIFIED) ---------- */
async function syncOrdersWithFirestore() {
  const uid = getUid();
  if (!uid || uid === 'anon') {
    return readJsonKey(ORDERS_KEY(), []);
  }
  
  try {
    console.log('üîÑ Syncing orders from Firestore...');
    
    let orders = [];
    
    // üî• Get from user document (where seller updates go)
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    if (userDoc.exists()) {
      const userData = userDoc.data();
      orders = userData.orders || [];
      
      console.log(`‚úÖ Synced ${orders.length} orders from user document`);
      
      // Preserve statuses
      orders = orders.map(order => ({
        ...order,
        status: order.status || 'Pending',
        progressStep: mapStatusToStep(order.status || 'Pending')
      }));
    }
    
    // Save to localStorage
    writeJsonKey(ORDERS_KEY(), orders);
    
    return orders;
    
  } catch (error) {
    console.error('‚ùå Error syncing orders:', error);
    return readJsonKey(ORDERS_KEY(), []);
  }
}

// üî• PREVENT STATUS RESET ON PAGE LOAD
window.addEventListener('load', () => {
  setTimeout(() => {
    const ordersKey = ORDERS_KEY();
    let localOrders = JSON.parse(localStorage.getItem(ordersKey) || '[]');
    
    let changed = false;
    localOrders = localOrders.map(order => {
      if (order && order.status === '0') {
        changed = true;
        return {
          ...order,
          status: 'Pending',
          progressStep: 1
        };
      }
      return order;
    });
    
    if (changed) {
      localStorage.setItem(ordersKey, JSON.stringify(localOrders));
      console.log('üî• Fixed orders with status "0"');
    }
  }, 500);
});

// ----------------- Load Products from Firestore -----------------
async function loadProductsFromFirestore() {
  try {
    console.log('üì¶ Loading products from Firestore...');
    
    const productsCollection = collection(firestore, "products");
    const querySnapshot = await getDocs(productsCollection);
    
    const products = [];
    querySnapshot.forEach(doc => {
      const productData = doc.data();
      products.push({
        id: doc.id,
        ...productData
      });
    });
    
    // Store in localStorage for caching
    localStorage.setItem(PRODUCTS_KEY(), JSON.stringify(products));
    
    console.log('‚úÖ Loaded', products.length, 'products from Firestore');
    return products;
  } catch (error) {
    console.error('‚ùå Error loading products from Firestore:', error);
    
    // Fallback to localStorage cache
    const cachedProducts = JSON.parse(localStorage.getItem(PRODUCTS_KEY()) || '[]');
    console.log('üì¶ Using cached products:', cachedProducts.length);
    return cachedProducts;
  }
}

// ----------------- Setup Product Sync -----------------
function setupProductSync() {
  try {
    const uid = getUid();
    if (!uid || uid === 'anon') return;
    
    console.log('üîÑ Setting up product sync listener...');
    
    // Listen for product updates in real-time
    const productsCollection = collection(firestore, "products");
    return onSnapshot(productsCollection, (snapshot) => {
      const products = [];
      snapshot.forEach(doc => {
        const productData = doc.data();
        products.push({
          id: doc.id,
          ...productData
        });
      });
      
      // Update localStorage cache
      localStorage.setItem(PRODUCTS_KEY(), JSON.stringify(products));
      console.log('üîÑ Products updated in real-time:', products.length, 'products');
      
      // If you need to update the UI when products change, call renderOrders here
      // renderOrders();
    });
  } catch (error) {
    console.error('‚ùå Error setting up product sync:', error);
  }
}

// üî• ADD THIS: Listen for real-time order updates
function setupOrderUpdateListener() {
  const uid = getUid();
  if (!uid || uid === 'anon') {
    console.log('‚ö†Ô∏è Not logged in - skipping order listener');
    return null;
  }
  
  console.log('üëÇ Setting up real-time order listener for buyer:', uid);
  
  try {
    // Listen to user's document for order updates
    const userDocRef = doc(firestore, "users", uid);
    
    return onSnapshot(userDocRef, (doc) => {
      if (doc.exists()) {
        const userData = doc.data();
        const firestoreOrders = userData.orders || [];
        
        console.log('üì¢ Buyer: Real-time order update received!');
        
        // Update localStorage
        writeJsonKey(ORDERS_KEY(), firestoreOrders);
        
        // Update global orders too
        localStorage.setItem(ORDERS_GLOBAL, JSON.stringify(firestoreOrders));
        
        // Re-render after a short delay
        setTimeout(() => {
          renderOrders();
          showToast('Order status updated!', 'success');
        }, 300);
      }
    }, (error) => {
      console.error('‚ùå Order listener error:', error);
    });
    
  } catch (error) {
    console.error('‚ùå Failed to setup order listener:', error);
    return null;
  }
}

// ----------------- Load Orders from ALL Sources -----------------
/* ---------- Load Orders from Firestore (SIMPLIFIED) ---------- */
async function loadOrdersFromAllSources() {
  const uid = getUid();
  console.log('üì¶ Loading orders for user:', uid);
  
  let allOrders = [];
  
  // üéØ 1. ALWAYS TRY FIRESTORE USER DOCUMENT FIRST
  if (uid && uid !== 'anon') {
    try {
      const userDocRef = doc(firestore, "users", uid);
      const userDoc = await getDoc(userDocRef);
      
      if (userDoc.exists()) {
        const userData = userDoc.data();
        const userOrders = userData.orders || [];
        
        console.log(`üì• Found ${userOrders.length} orders in user document`);
        
        userOrders.forEach(order => {
          if (order && order.id) {
            // üî• CRITICAL: Preserve ACTUAL status from Firestore
            const status = order.status || 'Pending';
            allOrders.push({
              ...order,
              status: status,
              progressStep: mapStatusToStep(status)
            });
          }
        });
      }
    } catch (error) {
      console.error('‚ùå User document error:', error);
    }
  }
  
  // üéØ 2. FALLBACK TO LOCALSTORAGE
  if (allOrders.length === 0) {
    console.log('üìÇ Falling back to localStorage...');
    allOrders = readJsonKey(ORDERS_KEY(), []);
  }
  
  // üéØ 3. ENSURE NO STATUS RESETS
  allOrders = allOrders.map(order => {
    if (!order) return null;
    
    const currentStatus = order.status || 'Pending';
    
    return {
      // Default values only if missing
      status: currentStatus,
      progressStep: mapStatusToStep(currentStatus),
      deliveryCode: order.deliveryCode || Math.floor(100000 + Math.random() * 900000).toString(),
      date: order.date || new Date().toLocaleDateString('en-GB', { month: 'long', day: 'numeric', year: 'numeric' }),
      createdAt: order.createdAt || new Date().toISOString(),
      updatedAt: order.updatedAt || new Date().toISOString(),
      // Keep ALL original data
      ...order,
      // üî• CRITICAL: NEVER override existing status with defaults
      status: currentStatus,
      progressStep: mapStatusToStep(currentStatus)
    };
  }).filter(order => order !== null);
  
  // üéØ 4. SAVE BACK TO LOCALSTORAGE (with correct status)
  writeJsonKey(ORDERS_KEY(), allOrders);
  
  console.log(`üìä FINAL: Loaded ${allOrders.length} orders with preserved statuses`);
  
  return allOrders;
}
// ----------------- Update Firestore Order -----------------
async function updateOrderInFirestore(orderId, updates) {
  const uid = getUid();
  if (!uid || uid === 'anon') return false;
  
  try {
    // Update in main orders collection
    const orderRef = doc(firestore, "orders", orderId);
    const orderDoc = await getDoc(orderRef);
    
    if (orderDoc.exists()) {
      await updateDoc(orderRef, {
        ...updates,
        updatedAt: new Date().toISOString()
      });
      console.log('‚úÖ Order updated in Firestore orders collection');
    }
    
    // Also update in user's orders array
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    if (userDoc.exists()) {
      const userData = userDoc.data();
      const userOrders = userData.orders || [];
      const orderIndex = userOrders.findIndex(o => 
        o.id === orderId || o.orderId === orderId
      );
      
      if (orderIndex !== -1) {
        userOrders[orderIndex] = {
          ...userOrders[orderIndex],
          ...updates,
          updatedAt: new Date().toISOString()
        };
        
        await updateDoc(userDocRef, { orders: userOrders });
        console.log('‚úÖ Order updated in user Firestore profile');
      }
    }
    
    return true;
  } catch (error) {
    console.error('‚ùå Error updating order in Firestore:', error);
    return false;
  }
}

// ----------------- Cancel Order with Firestore Sync -----------------
window.cancelOrder = async function(index) {
  try {
    // Load orders
    const orders = await loadOrdersFromAllSources();
    const order = orders[index];
    if (!order) {
      showToast('Order not found', 'error');
      return;
    }

    const orderId = order.id || order.orderId;
    const buyerUid = getUid();
    
    if (!buyerUid || buyerUid === 'anon') {
      showToast('Please sign in to cancel orders', 'error');
      return;
    }

    if (!confirm(`Cancel Order #${orderId || 'N/A'}? This will mark it as Cancelled.`)) return;

    const cancelledAt = new Date().toISOString();
    const oldStatus = order.status || 'Pending';
    
    // Prepare updates
    const updates = {
      status: 'Cancelled',
      progressStep: mapStatusToStep('Cancelled'),
      cancelledAt: cancelledAt,
      cancelledBy: buyerUid,
      history: [
        ...(order.history || []),
        {
          action: 'cancelled',
          from: oldStatus,
          to: 'Cancelled',
          by: buyerUid,
          at: cancelledAt
        }
      ],
      updatedAt: cancelledAt
    };

    // üî• 1. Update in Firestore (Primary)
    const firestoreSuccess = await updateOrderInFirestore(orderId, updates);
    
    if (!firestoreSuccess) {
      showToast('Failed to cancel order in cloud', 'error');
      return;
    }

    // üî• 2. Update localStorage (Backup)
    // Update buyer's local storage
    let buyerLocal = readJsonKey(ORDERS_KEY(), []);
    const localIndex = buyerLocal.findIndex(o => 
      o.id === orderId || o.orderId === orderId
    );
    
    if (localIndex !== -1) {
      buyerLocal[localIndex] = { ...buyerLocal[localIndex], ...updates };
      writeJsonKey(ORDERS_KEY(), buyerLocal);
    }

    // Update global storage
    const globalOrders = JSON.parse(localStorage.getItem(ORDERS_GLOBAL) || '[]');
    const globalIndex = globalOrders.findIndex(o => 
      o.id === orderId || o.orderId === orderId
    );
    
    if (globalIndex !== -1) {
      globalOrders[globalIndex] = { ...globalOrders[globalIndex], ...updates };
      localStorage.setItem(ORDERS_GLOBAL, JSON.stringify(globalOrders));
    }

    // üî• 3. Create notification for seller in Firestore
    try {
      if (order.sellerId) {
        const notificationRef = doc(collection(firestore, "notifications"));
        await setDoc(notificationRef, {
          type: 'order_cancelled',
          recipientId: order.sellerId,
          orderId: orderId,
          buyerId: buyerUid,
          buyerName: order.buyerName || 'Buyer',
          timestamp: cancelledAt,
          read: false,
          title: 'Order Cancelled',
          message: `Order ${orderId} has been cancelled by the buyer.`,
          actionUrl: `/seller/orders.html?order=${orderId}`
        });
        console.log('‚úÖ Cancellation notification sent to seller');
      }
    } catch (notifyError) {
      console.error('‚ùå Failed to create notification:', notifyError);
    }

    // üî• 4. Send ping for real-time updates
    localStorage.setItem(`orders_ping__buyer__${buyerUid}`, String(Date.now()));
    
    if (order.sellerId) {
      localStorage.setItem(`orders_ping__seller__${order.sellerId}`, String(Date.now()));
    }

    // üî• 5. Update UI
    await renderOrders();
    showToast('Order cancelled successfully', 'success');

  } catch (err) {
    console.error('‚ùå Cancel order failed:', err);
    showToast('Error cancelling order', 'error');
  }
};


// ----------------- Real-time Firestore Listener -----------------
// Add this function to listen for real-time order updates
function setupFirestoreOrderListener() {
  const uid = getUid();
  if (!uid || uid === 'anon') return;
  
  // Listen to user's orders array
  const userDocRef = doc(firestore, "users", uid);
  
  return onSnapshot(userDocRef, (doc) => {
    if (doc.exists()) {
      const userData = doc.data();
      const firestoreOrders = userData.orders || [];
      
      // Update localStorage cache
      writeJsonKey(ORDERS_KEY(), firestoreOrders);
      
      // Re-render if needed
      renderOrders();
    }
  });
}

// ----------------- Update getGlobalOrders for better Firestore integration -----------------
async function getGlobalOrders() {
  try {
    const uid = getUid();
    let orders = [];
    
    // üî• Get from user's Firestore document (not main collection)
    if (uid && uid !== 'anon') {
      try {
        const userDocRef = doc(firestore, "users", uid);
        const userDoc = await getDoc(userDocRef);
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          orders = userData.orders || [];
          console.log('‚úÖ Loaded', orders.length, 'orders from user Firestore document');
        }
      } catch (error) {
        console.error('‚ùå Firestore user doc error:', error);
      }
    }
    
    // Ensure status preservation
    orders = orders.map(order => {
      if (!order) return null;
      
      const status = order.status || 'Pending';
      return {
        ...order,
        status: status,
        progressStep: mapStatusToStep(status)
      };
    }).filter(order => order !== null);
    
    return orders;
    
  } catch (error) {
    console.error('‚ùå Error in getGlobalOrders:', error);
    return [];
  }
}

// ----------------- Update saveGlobalOrders -----------------
async function saveGlobalOrders(data) {
  try {
    const uid = getUid();
    const ordersArray = Array.isArray(data) ? data : [];
    
    // 1. Always save to localStorage cache
    localStorage.setItem(ORDERS_GLOBAL, JSON.stringify(ordersArray));
    
    // 2. Save to Firestore if user is logged in
    if (uid && uid !== 'anon') {
      try {
        const userDocRef = doc(firestore, "users", uid);
        await updateDoc(userDocRef, { 
          orders: ordersArray,
          updatedAt: new Date().toISOString()
        });
        
        // Also save each order to main orders collection
        for (const order of ordersArray) {
          if (order && order.id) {
            try {
              const orderRef = doc(firestore, "orders", order.id);
              const orderDoc = await getDoc(orderRef);
              
              if (orderDoc.exists()) {
                await updateDoc(orderRef, {
                  ...order,
                  updatedAt: new Date().toISOString()
                });
              } else {
                await setDoc(orderRef, {
                  ...order,
                  createdAt: order.createdAt || new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                });
              }
            } catch (orderError) {
              console.warn('Could not save order to main collection:', orderError);
            }
          }
        }
      } catch (firestoreError) {
        console.error('‚ùå Error saving to Firestore:', firestoreError);
      }
    }
  } catch (error) {
    console.error('‚ùå Error in saveGlobalOrders:', error);
  }
}

// ----------------- Update loadOrders function -----------------
async function loadOrders() {
  console.log('üöÄ Loading orders...');
  
  // Load directly from all sources (which includes Firestore sync)
  orders = await loadOrdersFromAllSources();
  
  console.log('üì¶ Orders loaded:', orders.length);
  
  if (typeof window.maybeShowClearButton === 'function') {
    window.maybeShowClearButton(orders);
  }
  
  return orders;
}


// ----------------- Update visibilitychange event -----------------
document.addEventListener('visibilitychange', async () => {
  if (!document.hidden) {
    console.log('üîÑ Page became visible, syncing with Firestore...');
    
    try {
      // Sync from Firestore
      await syncOrdersWithFirestore();
      
      // Load fresh orders
      orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
      
      // Re-render
      await renderOrders();
      updateCartCount();
      
      console.log('‚úÖ Synced on visibility change');
    } catch (error) {
      console.error('‚ùå Sync on visibility change failed:', error);
    }
  }
});

// ----------------- Global helpers for shared orders -----------------

async function updateGlobalOrder(orderId, updates = {}) {
  try {
    console.log('üîÑ Updating global order:', orderId, updates);
    
    // 1. Get current global orders
    const global = await getGlobalOrders(); // ‚Üê Add await
    
    if (!Array.isArray(global)) {
      console.warn('Global orders is not an array');
      return false;
    }
    
    // 2. Find and update the order
    const idx = global.findIndex(o => 
      o && (String(o.id) === String(orderId) || String(o.orderId) === String(orderId))
    );
    
    if (idx === -1) {
      // Order doesn't exist, create new entry
      const newEntry = { 
        ...updates, 
        id: orderId, 
        orderId: orderId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      global.unshift(newEntry);
      console.log('‚ûï Created new order in global storage');
    } else {
      // Update existing order
      global[idx] = { 
        ...global[idx], 
        ...updates,
        updatedAt: new Date().toISOString()
      };
      console.log('‚úèÔ∏è Updated existing order in global storage');
    }
    
    // 3. Save back to storage
    await saveGlobalOrders(global);
    
    // 4. üî• Update Firestore directly too
    try {
      const uid = getUid();
      if (uid && uid !== 'anon' && orderId) {
        // Update in main orders collection
        const orderRef = doc(firestore, "orders", orderId);
        const orderDoc = await getDoc(orderRef);
        
        if (orderDoc.exists()) {
          await updateDoc(orderRef, {
            ...updates,
            updatedAt: new Date().toISOString()
          });
          console.log('‚úÖ Updated order in Firestore main collection');
        }
        
        // Also update in user's orders array
        const userDocRef = doc(firestore, "users", uid);
        const userDoc = await getDoc(userDocRef);
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          const userOrders = userData.orders || [];
          const userOrderIndex = userOrders.findIndex(o => 
            o.id === orderId || o.orderId === orderId
          );
          
          if (userOrderIndex !== -1) {
            userOrders[userOrderIndex] = {
              ...userOrders[userOrderIndex],
              ...updates,
              updatedAt: new Date().toISOString()
            };
            
            await updateDoc(userDocRef, { orders: userOrders });
            console.log('‚úÖ Updated order in user Firestore profile');
          }
        }
      }
    } catch (firestoreError) {
      console.warn('Firestore update failed, using localStorage only:', firestoreError);
    }
    
    return true;
    
  } catch (e) {
    console.warn('‚ùå updateGlobalOrder failed', e);
    return false;
  }
}

// Helper: remove an order (by id/orderId) from global canonical list
async function removeFromGlobal(orderId) {
  try {
    if (!orderId) return false;
    
    console.log('üóëÔ∏è Removing order from global storage:', orderId);
    
    // 1. Get current global orders
    const global = await getGlobalOrders(); // ‚Üê Add await
    if (!Array.isArray(global)) return false;
    
    // 2. Filter out the order
    const filtered = global.filter(o => 
      o && String(o.id || o.orderId) !== String(orderId)
    );
    
    console.log('üìä Before removal:', global.length, 'orders');
    console.log('üìä After removal:', filtered.length, 'orders');
    
    // 3. Save filtered list
    await saveGlobalOrders(filtered);
    
    // 4. üî• Also remove from Firestore user profile (but keep in orders collection)
    try {
      const uid = getUid();
      if (uid && uid !== 'anon') {
        const userDocRef = doc(firestore, "users", uid);
        const userDoc = await getDoc(userDocRef);
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          const userOrders = userData.orders || [];
          const filteredUserOrders = userOrders.filter(o => 
            o && String(o.id || o.orderId) !== String(orderId)
          );
          
          await updateDoc(userDocRef, { 
            orders: filteredUserOrders,
            updatedAt: new Date().toISOString()
          });
          
          console.log('‚úÖ Removed order from user Firestore profile');
        }
      }
    } catch (firestoreError) {
      console.warn('Could not remove from Firestore:', firestoreError);
    }
    
    return true;
    
  } catch (e) {
    console.warn('‚ùå removeFromGlobal failed', e);
    return false;
  }
}

// ----------------- Merge local buyer orders + global truth -----------------
function mapStatusToStep(status) {
  if (!status) return 1; // Default to step 1 if no status
  
  const s = String(status).toLowerCase().trim();
  
  switch (s) {
    case 'pending': return 1;
    case 'accepted': return 2;
    case 'processing': return 3;
    case 'assigned': return 3;
    case 'delivering': return 4;
    case 'at door': return 5;
    case 'delivered': return 6;
    case 'ready for pickup': return 4;
    case 'picked up': return 5;
    case 'completed': return 6;
    case 'rejected': return 0;
    case 'cancelled': return 0;
    // üî• ADD THESE: Handle numeric statuses
    case '0': return 0;
    case '1': return 1;
    case '2': return 2;
    case '3': return 3;
    case '4': return 4;
    case '5': return 5;
    case '6': return 6;
    default: return 1; // Default to pending
  }
}

// ‚úÖ ADD TO ORDERS PAGE: Wishlist sync functions (must match cart page)
async function syncWishlistWithFirestore() {
  const uid = getUid();
  if (!uid || uid === 'anon') {
    const wishlist = readJsonKey(getSavedKey(), []);
    console.log('‚úÖ Wishlist synced from Firestore: 0 items (anon)');
    return wishlist;
  }
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    if (userDoc.exists()) {
      const userData = userDoc.data();
      const firestoreWishlist = userData.wishlist || [];
      
      // Update localStorage
      localStorage.setItem(getSavedKey(), JSON.stringify(firestoreWishlist || []));
      console.log('‚úÖ Wishlist synced from Firestore:', firestoreWishlist.length, 'items');
      return firestoreWishlist;
    } else {
      console.log('‚ö†Ô∏è No user document in Firestore for wishlist');
      const wishlist = readJsonKey(getSavedKey(), []);
      return wishlist;
    }
  } catch (error) {
    console.error('‚ùå Error syncing wishlist with Firestore:', error);
    const wishlist = readJsonKey(getSavedKey(), []);
    return wishlist;
  }
}

// ‚úÖ ADD: Update Firestore when wishlist changes
async function updateFirestoreWishlist(wishlistData) {
  const uid = getUid();
  if (!uid || uid === 'anon') return;
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    await updateDoc(userDocRef, { wishlist: wishlistData });
    console.log('‚úÖ Wishlist updated in Firestore');
  } catch (error) {
    console.error('Error updating Firestore wishlist:', error);
  }
}

// ‚úÖ ADD: Cart sync function for orders page
async function syncCartWithFirestore() {
  const uid = getUid();
  if (!uid || uid === 'anon') {
    const cart = readJsonKey(getCartKey(), []);
    console.log('‚úÖ Cart synced from Firestore: 0 items (anon)');
    return cart;
  }
  
  try {
    const userDocRef = doc(firestore, "users", uid);
    const userDoc = await getDoc(userDocRef);
    
    if (userDoc.exists()) {
      const userData = userDoc.data();
      const firestoreCart = userData.cart || [];
      
      // Update localStorage
      localStorage.setItem(getCartKey(), JSON.stringify(firestoreCart));
      console.log('‚úÖ Cart synced from Firestore:', firestoreCart.length, 'items');
      return firestoreCart;
    } else {
      // No user doc in Firestore yet
      console.log('‚ö†Ô∏è No user document in Firestore');
      const cart = readJsonKey(getCartKey(), []);
      return cart;
    }
  } catch (error) {
    console.error('‚ùå Error syncing cart with Firestore:', error);
    const cart = readJsonKey(getCartKey(), []);
    return cart;
  }
}

// ‚úÖ ADD: Helper to get saved key (must match cart page)
function getSavedKey(){ 
  return nsKey('wishlist');  // Must match cart page
}

// ‚úÖ ADD: Helper to get cart key
function getCartKey(){ 
  return nsKey('cart');
}




// --- DOM Elements ---
const darkModeToggle = document.getElementById('darkModeToggle');
const container = document.querySelector('.tracking-container');
const emptyState = document.querySelector('.empty-state');
const userAvatar = document.querySelector('.user-avatar');
const logoutBtn = document.getElementById('logoutBtn');
const cartBadge = document.getElementById('cartBadge');
const dropdownContent = document.querySelector('.dropdown-content');

// --- Toast notifications ---
function showToast(message, type = 'success') {
  const existingToasts = document.querySelectorAll('.buyer-toast');
  existingToasts.forEach(t => t.remove());
  const toast = document.createElement('div');
  toast.className = `buyer-toast buyer-toast-${type}`;
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#f59e0b'};
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10000;
    font-weight: 500;
    animation: slideInRight 0.3s ease;
  `;
  document.body.appendChild(toast);
  setTimeout(() => {
    toast.style.animation = 'slideOutRight 0.3s ease';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}
if (!document.querySelector('#toast-animations')) {
  const style = document.createElement('style');
  style.id = 'toast-animations';
  style.textContent = `
    @keyframes slideInRight {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOutRight {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
  `;
  document.head.appendChild(style);
}

// --- Profile Dropdown ---
if (userAvatar && dropdownContent) {
  userAvatar.addEventListener('click', e => { e.stopPropagation(); dropdownContent.classList.toggle('show'); });
}
document.addEventListener('click', e => {
  if (dropdownContent?.classList.contains('show') && !e.target.closest('.profile-dropdown')) {
    dropdownContent.classList.remove('show');
  }
});
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && dropdownContent?.classList.contains('show')) {
    dropdownContent.classList.remove('show');
  }
});

// --- Dark Mode ---
const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
if (localStorage.getItem('theme') === 'dark' || (!localStorage.getItem('theme') && prefersDark)) {
  document.body.classList.add('dark-mode');
  if (darkModeToggle) darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
}
if (darkModeToggle) {
  darkModeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    const isDark = document.body.classList.contains('dark-mode');
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
    darkModeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
  });
}

// --- Auth Handling ---
onAuthStateChanged(auth, async user => {
  if (!user) return window.location.href = "../../../index.html";
  try {
    try { sessionStorage.setItem('uid', user.uid); } catch(e){}
    // ‚úÖ SYNC FROM FIRESTORE WHEN USER LOGS IN
    await syncCartWithFirestore();
    await syncWishlistWithFirestore();
    await syncOrdersWithFirestore();
    const userRef = ref(database, `users/${user.uid}`);
    const snapshot = await get(userRef);
    if (!snapshot.exists()) return window.location.href = "../../../index.html";
    const userData = snapshot.val();
    if (userData.declined) window.location.href = "../../../adminlogic/declined/declined.html";
    if (userData.banned) window.location.href = "../../../adminlogic/banned/banned.html";
    if (userAvatar) {
      userAvatar.src = userData.profilePictureUrl || "../../../images/no profile pic.jpg";
      userAvatar.alt = (userData.name || "User") + "'s profile picture";
    }
    updateCartCount();
  } catch (err) {
    console.warn('Auth user lookup failed', err);
  }
});

// --- Logout ---
logoutBtn?.addEventListener("click", async e => {
  e.preventDefault();
  await signOut(auth);
  sessionStorage.removeItem('uid');
  window.location.href = "../../../index.html";
});

// --- Cart Badge (reads namespaced cart) ---
// ‚úÖ UPDATE updateCartCount function to sync with Firestore:
async function updateCartCount() {
  // Sync cart from Firestore first
  await syncCartWithFirestore();
  
  const cart = readJsonKey(CART_KEY(), []);
  const totalItems = (cart || []).reduce((sum, item) => sum + (item.quantity || 1), 0);
  if (cartBadge) {
    cartBadge.textContent = totalItems;
    cartBadge.style.display = totalItems > 0 ? 'flex' : 'none';
  }
}
updateCartCount();

// --- ORDERS: use merged view (global master + buyer local) ---
// --- ORDERS: use merged view (global master + buyer local) ---
let orders = []; // Initialize as empty array


// small helper used by cancel and elsewhere
function nowISO(){ return new Date().toISOString(); }
function getProgressStep(status){ return mapStatusToStep(status); }

// Ensure default fields are persisted to buyer local (but we render from merged)
writeJsonKey(ORDERS_KEY(), readJsonKey(ORDERS_KEY(), []).map(o => {
  if (!o.status) o.status = 'Pending';
  if (!('progressStep' in o)) o.progressStep = mapStatusToStep(o.status);
  if (!o.deliveryCode) o.deliveryCode = Math.floor(100000 + Math.random() * 900000).toString();
  return o;
}));

// --- Seller cache & helper ---
const sellerCache = new Map();
async function getSeller(uid) {
  if (!uid) return null;
  if (sellerCache.has(uid)) return sellerCache.get(uid);
  try {
    const snap = await get(ref(database, `users/${uid}`));
    if (!snap.exists()) { sellerCache.set(uid, null); return null; }
    const d = snap.val();
    sellerCache.set(uid, d);
    return d;
  } catch (err) {
    console.warn('getSeller error', err);
    sellerCache.set(uid, null);
    return null;
  }
}
async function prefetchSellersForOrders(ordersList) {
  const ids = new Set();
  (ordersList || []).forEach(o => { (o.items || []).forEach(it => { if (it.sellerId) ids.add(String(it.sellerId)); }); });
  if (!ids.size) return;
  const promises = [];
  ids.forEach(id => { if (!sellerCache.has(id)) promises.push(getSeller(id)); });
  await Promise.all(promises);
}

// -----------------------------
// Clear finished orders button
// -----------------------------
(function addClearFinishedButton() {
  if (detectPageRole() !== 'buyer') return;
  const uid = getUid();
  if (!uid) return;
  if (document.getElementById('clearFinishedBtn')) {
    if (!window.maybeShowClearButton) window.maybeShowClearButton = maybeShowClearButton;
    return;
  }

  const btn = document.createElement('button');
  btn.id = 'clearFinishedBtn';
  btn.className = 'action-btn secondary-btn';
  btn.innerHTML = '<i class="fas fa-broom"></i> Clear completed / cancelled / rejected';
  btn.style.margin = '10px 0 18px 0';
  btn.title = 'Remove delivered, cancelled and rejected orders from your view';
  btn.style.display = 'none';
  btn.setAttribute('aria-hidden', 'true');

  let wrapper = document.createElement('div');
  wrapper.style.display = 'flex';
  wrapper.style.justifyContent = 'flex-end';
  wrapper.appendChild(btn);
  if (container && container.parentNode) container.parentNode.insertBefore(wrapper, container);
  else document.body.insertBefore(wrapper, document.body.firstChild);

  function cleanupCanonicalAndPing(orderIds = []) {
    try {
      orderIds.forEach(oid => {
        if (!oid) return;
        const canonicalKey = `order__${oid}`;
        const raw = localStorage.getItem(canonicalKey);
        if (!raw) return;
        try {
          const canonical = JSON.parse(raw || '{}') || {};
          canonical.archivedByBuyer = uid;
          canonical.archivedAt = Date.now();
          canonical.version = (canonical.version || 0) + 1;
          localStorage.setItem(canonicalKey, JSON.stringify(canonical));
        } catch (e) { /* ignore */ }
      });
      localStorage.setItem(`orders_ping__buyer__${uid}`, String(Date.now()));
    } catch (e) {
      console.warn('cleanupCanonicalAndPing failed', e);
    }
  }

  function setBtnWorking(state = true) {
    try {
      btn.disabled = !!state;
      btn.style.opacity = state ? '0.6' : '';
      btn.setAttribute('aria-busy', state ? 'true' : 'false');
    } catch (e) { /* ignore */ }
  }

  // Actual clear function (global)
  async function clearFinishedOrders() {
    try {
      const confirmMsg = 'Clear all delivered, cancelled and rejected orders from your active list and history? This will remove them from this device\'s storage.';
      if (!confirm(confirmMsg)) return;

      setBtnWorking(true);
      const statusesToRemove = new Set(['delivered','cancelled','rejected','completed','picked up']);

      // 1) Remove from active buyer-local orders
      let currentOrders = readJsonKey(ORDERS_KEY(), []);
      if (!Array.isArray(currentOrders)) currentOrders = [];

      const removedOrderIds = [];
      const keptOrders = currentOrders.filter(o => {
        const s = (o && o.status) ? String(o.status).toLowerCase() : '';
        if (statusesToRemove.has(s)) {
          removedOrderIds.push(o.id || o.orderId || null);
          return false; // remove
        }
        return true; // keep
      });

      writeJsonKey(ORDERS_KEY(), keptOrders);

      // 2) Remove matching entries from completedOrders__buyer__<uid>
      try {
        const buyerCompletedKey = `completedOrders__buyer__${uid}`;
        let completed = JSON.parse(localStorage.getItem(buyerCompletedKey) || '[]') || [];
        if (!Array.isArray(completed)) completed = [];
        const filteredCompleted = completed.filter(o => {
          const s = (o && o.status) ? String(o.status).toLowerCase() : '';
          return !statusesToRemove.has(s);
        });
        localStorage.setItem(buyerCompletedKey, JSON.stringify(filteredCompleted));
      } catch (e) {
        console.warn('clearFinishedOrders: failed cleaning completed list', e);
      }

      // 3) Optionally clean canonical order__<id> entries and ping other tabs
      cleanupCanonicalAndPing(removedOrderIds.filter(Boolean));

      // --- NEW: remove these IDs from the global master list so merged view won't bring them back ---
      try {
        const toRemove = removedOrderIds.filter(Boolean).map(id => String(id));
        if (toRemove.length) {
          const global = getGlobalOrders();
          const filteredGlobal = global.filter(g => !toRemove.includes(String(g.id || g.orderId)));
          saveGlobalOrders(filteredGlobal);
        }
      } catch (e) {
        console.warn("Failed to remove from orders_global in clearFinishedOrders", e);
      }

      // 4) Fire UI updates & analytics
      if (typeof renderOrders === 'function') await renderOrders();
      if (typeof renderCompletedOrders === 'function') await renderCompletedOrders();
      if (typeof renderAnalytics === 'function') renderAnalytics();
      updateCartCount();

      // 5) toast
      if (typeof showToast === 'function') showToast('Cleared finished orders', 'success');
    } catch (err) {
      console.error('clearFinishedOrders failed', err);
      if (typeof showToast === 'function') showToast('Failed to clear finished orders', 'error');
    } finally {
      setBtnWorking(false);
    }
  }

  // Remove a single order by its stable id (recommended) ‚Äî used by per-order Clear buttons
  async function clearSingleOrderById(orderId) {
    try {
      if (!orderId) return (typeof showToast === 'function') ? showToast('Order id missing', 'error') : alert('Order id missing');

      let currentOrders = readJsonKey(ORDERS_KEY(), []) || [];
      const idx = currentOrders.findIndex(o => String(o.id || o.orderId || '') === String(orderId));
      if (idx === -1) return (typeof showToast === 'function') ? showToast('Order not found', 'error') : alert('Order not found');

      const ord = currentOrders[idx];
      const status = (ord.status || '').toLowerCase();
      if (!['delivered','cancelled','rejected','completed','picked up'].includes(status)) {
        return (typeof showToast === 'function') ? showToast('Order not clearable', 'error') : alert('Order not clearable');
      }

      const confirmMsg = `Clear order ${orderId} from your active list and history?`;
      if (!confirm(confirmMsg)) return;

      // remove from buyer-local active
      currentOrders.splice(idx, 1);
      writeJsonKey(ORDERS_KEY(), currentOrders);

      // remove from completed list (if any)
      try {
        const buyerCompletedKey = `completedOrders__buyer__${uid}`;
        let completed = JSON.parse(localStorage.getItem(buyerCompletedKey) || '[]') || [];
        if (!Array.isArray(completed)) completed = [];
        completed = completed.filter(o => {
          const sid = (o && (o.id || o.orderId)) ? String(o.id || o.orderId) : null;
          if (!sid || !orderId) return true;
          return String(sid) !== String(orderId);
        });
        localStorage.setItem(buyerCompletedKey, JSON.stringify(completed));
      } catch (e) {
        console.warn('clearSingleOrderById: failed cleaning completed list', e);
      }

      // archive canonical and ping buyer tabs
      try {
        const canonicalKey = `order__${orderId}`;
        const raw = localStorage.getItem(canonicalKey);
        if (raw) {
          try {
            const canonical = JSON.parse(raw || '{}') || {};
            canonical.archivedByBuyer = uid;
            canonical.archivedAt = Date.now();
            canonical.version = (canonical.version || 0) + 1;
            localStorage.setItem(canonicalKey, JSON.stringify(canonical));
          } catch (e) { /* ignore parse errors */ }
        }
        localStorage.setItem(`orders_ping__buyer__${uid}`, String(Date.now()));
      } catch (e) {
        console.warn('clearSingleOrderById: archive/ping failed', e);
      }

      // --- NEW: remove from global canonical list too
      // --- NEW: remove from global canonical list too
      try {
        await removeFromGlobal(orderId); // ‚Üê Add await
      } catch (e) {
        console.warn("clearSingleOrderById: failed to remove from global", e);
      }

      // re-render
      if (typeof renderOrders === 'function') await renderOrders();
      if (typeof renderCompletedOrders === 'function') await renderCompletedOrders();
      if (typeof renderAnalytics === 'function') renderAnalytics();

      if (typeof showToast === 'function') showToast('Order cleared', 'success');
    } catch (err) {
      console.error('clearSingleOrderById failed', err);
      if (typeof showToast === 'function') showToast('Failed to clear order', 'error');
    }
  }

  // Backwards-compatible index-based clear (kept but deprecated)
  async function clearSingleOrderByIndex(index) {
    const currentOrders = readJsonKey(ORDERS_KEY(), []) || [];
    const ord = currentOrders[index];
    if (!ord) return (typeof showToast === 'function') ? showToast('Order not found', 'error') : alert('Order not found');
    const orderId = ord.id || ord.orderId || null;
    return clearSingleOrderById(orderId);
  }

  btn.addEventListener('click', clearFinishedOrders);

  // Expose hooks so other code (renderOrders) can trigger actions
  window.maybeShowClearButton = maybeShowClearButton;
  window.clearSingleOrderById = clearSingleOrderById;
  window.clearSingleOrderByIndex = clearSingleOrderByIndex; // deprecated alias

  maybeShowClearButton();
})();

// Show or hide button depending on whether there are orders with clearable statuses
// Accepts optional orders array so renderOrders can call maybeShowClearButton(orders)
// Show or hide button depending on whether there are orders with clearable statuses
// Accepts optional orders array so renderOrders can call maybeShowClearButton(orders)
function maybeShowClearButton(ordersArg) {
  try {
    const currentOrders = Array.isArray(ordersArg) ? ordersArg : (readJsonKey(ORDERS_KEY(), []) || []);
    const hasClearable = currentOrders.some(o => {
      const s = (o && o.status) ? String(o.status).toLowerCase() : '';
      return ['delivered', 'cancelled', 'rejected', 'completed', 'picked up'].includes(s);
    });
    const btn = document.getElementById('clearFinishedBtn');
    if (btn) {
      btn.style.display = hasClearable ? 'block' : 'none';
      btn.setAttribute('aria-hidden', hasClearable ? 'false' : 'true');
    }
  } catch (e) {
    console.warn('maybeShowClearButton failed', e);
    const btn = document.getElementById('clearFinishedBtn');
    if (btn) {
      btn.style.display = 'none';
      btn.setAttribute('aria-hidden', 'true');
    }
  }
}

// --- Render Orders ---
// --- Render Orders ---
async function renderOrders() {

  // ‚úÖ PREVENT MULTIPLE SIMULTANEOUS RENDERS
  if (isRendering) {
    console.log('‚ö†Ô∏è Already rendering, skipping...');
    return;
  }

  if (!container) return;
  
  console.log('üé® Rendering orders...');
  isRendering = true;
  
  try {

  // Clear container
  container.innerHTML = '';
  
  // Load fresh orders from Firestore
try {
  console.log('üîÑ Loading fresh orders from Firestore...');
  orders = await loadOrdersFromAllSources(); // ‚Üê NEW LINE
} catch (error) {
  console.error('‚ùå Failed to load orders:', error);
  orders = [];
}

  // Double-check it's an array
  if (!Array.isArray(orders)) {
    console.error('ERROR: orders is not an array, resetting to empty');
    orders = [];
  }
  
  // Handle empty state
  if (orders.length === 0) {
    if (emptyState) emptyState.style.display = 'flex';
    container.innerHTML = '';
    return;
  }
  
  if (emptyState) emptyState.style.display = 'none';
  
  // Update clear button visibility
  try { 
    maybeShowClearButton(orders); 
  } catch(e) { 
    console.warn('maybeShowClearButton failed:', e); 
  }
  
  // Prefetch seller info
  await prefetchSellersForOrders(orders);
  
  // Render each order
  orders.forEach((order, index) => {
    if (!order) return;
    
    // Ensure order has required fields
    if (!('progressStep' in order)) {
      order.progressStep = mapStatusToStep(order.status);
    }
    
    const card = document.createElement('div');
    card.className = `tracking-card animate-fade ${order.deliveryType === 'delivery' ? 'delivery-order' : 'pickup-order'}`;
    card.style.animationDelay = `${index * 0.1}s`;

    const itemsHTML = (order.items || []).map(item => {
      const image = item.image || '../../../images/default-product.jpg';
      const name = item.name || item.title || 'Item';
      const price = (item.price || 0).toFixed(2);
      const qty = item.quantity || 1;

      let sellerDisplay = 'Seller';
      if (item.sellerId && sellerCache.has(String(item.sellerId)) && sellerCache.get(String(item.sellerId))) {
        const s = sellerCache.get(String(item.sellerId));
        sellerDisplay = s.name || s.displayName || s.fullname || (s.email ? s.email.split('@')[0] : 'Seller');
      } else if (item.seller && String(item.seller).trim()) {
        sellerDisplay = item.seller;
      }
      const sellerLine = `<div class="item-seller">Sold by: ${escapeHtml(sellerDisplay)}</div>`;

      return `
      <div class="order-item">
        <img src="${escapeAttr(image)}" alt="${escapeAttr(name)}" class="item-image" onerror="this.onerror=null;this.src='../../../images/default-product.jpg'">
        <div class="item-details">
          <div class="item-name">${escapeHtml(name)}</div>
          <div class="item-meta">
            <div class="item-price">GHC ${price}</div>
            <div class="item-quantity">Quantity: ${qty}</div>
          </div>
          ${sellerLine}
        </div>
      </div>
    `;
    }).join('');

    let actionsHTML = '';
    const status = (order.status || '').toLowerCase();
    const isClearable = ['delivered','cancelled','rejected','completed','picked up'].includes(status);

    // ===== DELIVERY ORDER TEMPLATE =====
    if (order.deliveryType === 'delivery') {
        const progressPercent = 
          order.progressStep === 1 ? 16 :
          order.progressStep === 2 ? 32 :
          order.progressStep === 3 ? 48 :
          order.progressStep === 4 ? 64 :
          order.progressStep === 5 ? 80 : 100;

        const stepClasses = step => {
          if (order.progressStep > step) return 'completed';
          if (order.progressStep === step) return 'active';
          return '';
        };

        // Delivery actions
        if (status === 'pending') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn secondary-btn" data-action="cancel" data-idx="${index}"><i class="fas fa-times-circle"></i> Cancel Order</button>
          `;
        } else if (status === 'accepted') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn secondary-btn" data-action="cancel" data-idx="${index}"><i class="fas fa-times-circle"></i> Cancel Order</button>
            <button class="action-btn primary-btn" data-action="track" data-idx="${index}"><i class="fas fa-truck"></i> Track Delivery</button>
          `;
        } else if (['processing','delivering','at door','shipped'].includes(status)) {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn primary-btn" data-action="track" data-idx="${index}"><i class="fas fa-truck"></i> Track Delivery</button>
          `;
        } else if (status === 'delivered') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn primary-btn" data-action="buyagain" data-idx="${index}"><i class="fas fa-shopping-cart"></i> Buy Again</button>
          `;
        } else if (status === 'delivered' || status === 'cancelled' || status === 'rejected') {
          // Added cancelled and rejected here
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn primary-btn" data-action="buyagain" data-idx="${index}"><i class="fas fa-shopping-cart"></i> Buy Again</button>
          `;
        }

        const deliveryCodeHTML = `
          <div class="order-summary">
            <div class="summary-label">Delivery Code</div>
            <div class="summary-value" style="font-weight:700;color:#007BFF">${escapeHtml(order.deliveryCode)}</div>
          </div>
        `;

        let sellerInfoHTML = '';
        if (order.intendedSellerId) {
          const seller = sellerCache.get(String(order.intendedSellerId));
          if (seller && seller.name) {
            sellerInfoHTML = `<div class="small-muted" style="margin-top:4px">From: ${escapeHtml(seller.name)}</div>`;
          }
        }

        card.innerHTML = `
          <div class="order-header">
            <div class="order-info">
              <div class="order-id">Order #${escapeHtml(order.id || 'N/A')}</div>
              <div class="order-date">Placed on ${escapeHtml(order.date || 'N/A')}</div>
              <div class="order-delivery-type" style="margin-top:4px">
                <span style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.35rem 0.75rem;border-radius:1rem;font-size:0.85rem;font-weight:600;background:rgba(37, 99, 235, 0.1);color:#2563eb;border:1px solid rgba(37, 99, 235, 0.3)">
                  <i class="fas fa-truck"></i> Delivery Order
                </span>
              </div>
              ${sellerInfoHTML}
            </div>
            <div class="order-status status-${escapeHtml(status)}">${escapeHtml(order.status || 'Unknown')}</div>
          </div>

          <div class="progress-tracker">
            <div class="progress-bar" style="--progress: ${progressPercent}%;"></div>
            <div class="progress-steps">
              <div class="step ${stepClasses(1)}"><div class="step-icon"><i class="${order.progressStep > 1 ? 'fas fa-check' : 'fas fa-circle'}"></i></div><div class="step-label">Order Placed</div></div>
              <div class="step ${stepClasses(2)}"><div class="step-icon"><i class="${order.progressStep > 2 ? 'fas fa-check' : 'fas fa-clipboard-check'}"></i></div><div class="step-label">Accepted</div></div>
              <div class="step ${stepClasses(3)}"><div class="step-icon"><i class="${order.progressStep > 3 ? 'fas fa-check' : 'fas fa-box-open'}"></i></div><div class="step-label">Processing</div></div>
              <div class="step ${stepClasses(4)}"><div class="step-icon"><i class="${order.progressStep > 4 ? 'fas fa-check' : 'fas fa-shipping-fast'}"></i></div><div class="step-label">Delivering</div></div>
              <div class="step ${stepClasses(5)}"><div class="step-icon"><i class="${order.progressStep > 5 ? 'fas fa-check' : 'fas fa-door-open'}"></i></div><div class="step-label">At Door</div></div>
              <div class="step ${stepClasses(6)}"><div class="step-icon"><i class="fas fa-home"></i></div><div class="step-label">Delivered</div></div>
            </div>
          </div>

          <div class="order-items">${itemsHTML}</div>

          <div class="order-summary"><div class="summary-label">Subtotal</div><div class="summary-value">GHC ${(order.subtotal || 0).toFixed(2)}</div></div>
          <div class="order-summary"><div class="summary-label">Delivery Fee</div><div class="summary-value">GHC ${(order.deliveryFee || 0).toFixed(2)}</div></div>
          <div class="order-summary"><div class="summary-label">Tax</div><div class="summary-value">GHC ${(order.tax || 0).toFixed(2)}</div></div>
          <div class="order-summary summary-total"><div class="summary-label">Total</div><div class="summary-value">GHC ${(order.total || 0).toFixed(2)}</div></div>

          ${deliveryCodeHTML}

          <div class="order-actions">${actionsHTML}${isClearable ? ` <button class="action-btn danger-btn" data-action="clear" data-idx="${index}"><i class="fas fa-trash-alt"></i> Clear</button>` : ''}</div>
        `;

    // ===== PICKUP ORDER TEMPLATE =====
    } else {
        const progressPercent = 
          order.progressStep === 1 ? 20 :
          order.progressStep === 2 ? 40 :
          order.progressStep === 3 ? 60 :
          order.progressStep === 4 ? 80 :
          order.progressStep === 5 ? 100 : 0;

        const stepClasses = step => {
          if (order.progressStep > step) return 'completed';
          if (order.progressStep === step) return 'active';
          return '';
        };

       
                // Pickup actions
        if (status === 'pending') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn secondary-btn" data-action="cancel" data-idx="${index}"><i class="fas fa-times-circle"></i> Cancel Order</button>
          `;
        } else if (status === 'accepted') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn secondary-btn" data-action="cancel" data-idx="${index}"><i class="fas fa-times-circle"></i> Cancel Order</button>
            <button class="action-btn primary-btn" data-action="directions" data-idx="${index}"><i class="fas fa-map-marker-alt"></i> Get Directions</button>
          `;
        } else if (status === 'processing') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn primary-btn" data-action="directions" data-idx="${index}"><i class="fas fa-map-marker-alt"></i> Get Directions</button>
          `;
        } else if (status === 'ready for pickup') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn primary-btn" data-action="directions" data-idx="${index}"><i class="fas fa-map-marker-alt"></i> Get Directions</button>
          `;
        } else if (status === 'completed' || status === 'picked up') {
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn primary-btn" data-action="buyagain" data-idx="${index}"><i class="fas fa-shopping-cart"></i> Buy Again</button>
          `;
        }else if (status === 'completed' || status === 'picked up' || status === 'cancelled' || status === 'rejected') {
          // Added cancelled and rejected here
          actionsHTML = `
            <button class="action-btn secondary-btn" data-action="help" data-idx="${index}"><i class="fas fa-question-circle"></i> Help</button>
            <button class="action-btn primary-btn" data-action="buyagain" data-idx="${index}"><i class="fas fa-shopping-cart"></i> Buy Again</button>
          `;
        }

        let sellerInfoHTML = '';
        if (order.intendedSellerId) {
          const seller = sellerCache.get(String(order.intendedSellerId));
          if (seller && seller.name) {
            sellerInfoHTML = `<div class="small-muted" style="margin-top:4px">From: ${escapeHtml(seller.name)}</div>`;
          }
        }

        card.innerHTML = `
          <div class="order-header">
            <div class="order-info">
              <div class="order-id">Order #${escapeHtml(order.id || 'N/A')}</div>
              <div class="order-date">Placed on ${escapeHtml(order.date || 'N/A')}</div>
              <div class="order-delivery-type" style="margin-top:4px">
                <span style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.35rem 0.75rem;border-radius:1rem;font-size:0.85rem;font-weight:600;background:rgba(16, 185, 129, 0.1);color:#10b981;border:1px solid rgba(16, 185, 129, 0.3)">
                  <i class="fas fa-store"></i> Pickup Order
                </span>
              </div>
              ${sellerInfoHTML}
            </div>
            <div class="order-status status-${escapeHtml(status)}">${escapeHtml(order.status || 'Unknown')}</div>
          </div>

          <div class="progress-tracker">
    <div class="progress-bar" style="--progress: ${progressPercent}%;"></div>
    <div class="progress-steps">
        <div class="step ${stepClasses(1)}"><div class="step-icon"><i class="${order.progressStep > 1 ? 'fas fa-check' : 'fas fa-circle'}"></i></div><div class="step-label">Order Placed</div></div>
        <div class="step ${stepClasses(2)}"><div class="step-icon"><i class="${order.progressStep > 2 ? 'fas fa-check' : 'fas fa-clipboard-check'}"></i></div><div class="step-label">Accepted</div></div>
        <div class="step ${stepClasses(3)}"><div class="step-icon"><i class="${order.progressStep > 3 ? 'fas fa-check' : 'fas fa-box-open'}"></i></div><div class="step-label">Processing</div></div>
        <div class="step ${stepClasses(4)}"><div class="step-icon"><i class="${order.progressStep > 4 ? 'fas fa-check' : 'fas fa-box'}"></i></div><div class="step-label">Ready for Pickup</div></div>
        <div class="step ${stepClasses(5)}"><div class="step-icon"><i class="${order.progressStep > 5 ? 'fas fa-check' : 'fas fa-hand-holding'}"></i></div><div class="step-label">Picked Up</div></div>
    </div>
 </div>

          <div class="order-items">${itemsHTML}</div>

          <div class="order-summary"><div class="summary-label">Subtotal</div><div class="summary-value">GHC ${(order.subtotal || 0).toFixed(2)}</div></div>
          <div class="order-summary"><div class="summary-label">Pickup Fee</div><div class="summary-value">FREE</div></div>
          <div class="order-summary"><div class="summary-label">Tax</div><div class="summary-value">GHC ${(order.tax || 0).toFixed(2)}</div></div>
          <div class="order-summary summary-total"><div class="summary-label">Total</div><div class="summary-value">GHC ${(order.total || 0).toFixed(2)}</div></div>

          <div class="order-summary">
            <div class="summary-label">Pickup Location</div>
            <div class="summary-value" style="font-weight:600;color:#10b981">Seller's Store</div>
          </div>
          <div class="order-summary">
            <div class="summary-label">Pickup Code</div>
            <div class="summary-value" style="font-weight:700;color:#007BFF">${escapeHtml(order.deliveryCode)}</div>
          </div>

          <div class="order-actions">${actionsHTML}${isClearable ? ` <button class="action-btn danger-btn" data-action="clear" data-idx="${index}"><i class="fas fa-trash-alt"></i> Clear</button>` : ''}</div>
        `;
    }

    container.appendChild(card);
  });

  // Animate progress bars
  requestAnimationFrame(() => {
    document.querySelectorAll('.progress-bar').forEach(bar => {
      const pct = bar.style.getPropertyValue('--progress') || '0%';
      bar.style.width = pct;
    });
  });
  
  console.log(`‚úÖ Rendered ${orders.length} orders`);
  } finally {
    // ‚úÖ ALWAYS reset the flag
    isRendering = false;
  }
}

// Delegated actions handler
if (container) {
  container.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-action]');
    if (!btn) return;
    const idx = Number(btn.getAttribute('data-idx'));
    const action = btn.getAttribute('data-action');
    
    if (action === 'help') orderHelp(idx);
    else if (action === 'cancel') cancelOrder(idx);
    else if (action === 'track') trackDelivery(idx);
    else if (action === 'return') startReturn(idx);
    else if (action === 'buyagain') buyAgain(idx);
    else if (action === 'directions') getDirections(idx);
    else if (action === 'pickedup') markAsPickedUp(idx);
    else if (action === 'clear') {
  const order = orders[idx]; // ‚Üê USE CURRENT orders ARRAY
  const orderId = order ? (order.id || order.orderId) : null;
  if (orderId) {
    if (window.clearSingleOrderById) window.clearSingleOrderById(orderId);
    else clearSingleOrderById(orderId);
  } else {
    showToast('Unable to determine order id to clear', 'error');
  }
}
      
});
}

// Small helpers for escaping
function escapeHtml(s) {
  if (s === null || s === undefined) return '';
  return String(s)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}
function escapeAttr(s){
  return escapeHtml(s);
}

// --- Action functions ---
window.buyAgain = async index => {
  orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
  const order = orders[index];
  if (!order) return alert('Order not found.');
  let cart = readJsonKey(CART_KEY(), []);
  (order.items || []).forEach(item => {
    const matchIdx = cart.findIndex(ci => String(ci.id) === String(item.id) || String(ci.name) === String(item.name));
    if (matchIdx > -1) cart[matchIdx].quantity = (cart[matchIdx].quantity || 0) + (item.quantity || 0);
    else cart.push({ id: item.id, name: item.name, title: item.name, price: item.price, image: item.image, quantity: item.quantity || 1, seller: item.seller, sellerId: item.sellerId || null });
  });
  writeJsonKey(CART_KEY(), cart);
  alert('Items added to cart!');
  updateCartCount();
};

window.orderHelp = async index => {
  orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
  alert(`Need help with Order #${orders[index]?.id || 'N/A'}? Contact support.`);
};

window.trackDelivery = async index => {
  orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
  alert(`Tracking info for Order #${orders[index]?.id || 'N/A'} will appear here.`);
};

window.startReturn = async index => {
  orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
  alert(`Return process started for Order #${orders[index]?.id || 'N/A'}.`);
};

// Remove duplicate startReturn function

window.getDirections = async index => {
  orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
  const order = orders[index];
    
  if (!order || !order.id) {
    alert('Order not found or missing ID');
    return;
  }
  
  sessionStorage.setItem('trackingOrderId', order.id || order.orderId);
  window.location.href = '../../map/map.html';
};

window.markAsPickedUp = async index => {
  orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
  const order = orders[index];
  if (confirm(`Mark Order #${order?.id || 'N/A'} as picked up?`)) {
    showToast('Order marked as picked up!', 'success');
  }
};

// --- A lightweight completed-order renderer (optional) ---
async function renderCompletedOrders(){
  try{
    const uid = getUid();
    const key = `completedOrders__buyer__${uid}`;
    const completed = JSON.parse(localStorage.getItem(key) || '[]') || [];
    const compContainer = document.querySelector('.completed-container');
    if (!compContainer) return;
    compContainer.innerHTML = '';
    completed.forEach(o => {
      const el = document.createElement('div');
      el.className = 'completed-item';
      el.innerHTML = `<div>Order #${escapeHtml(o.id||o.orderId||'N/A')} ‚Äî ${escapeHtml(o.status||'')}</div>`;
      compContainer.appendChild(el);
    });
  }catch(e){console.warn('renderCompletedOrders failed',e);}
}

// --- Listen for storage changes (including global) ---
window.addEventListener('storage', async (e) => {
  if (!e.key) return;

  // ‚úÖ ADD: Prevent rapid-fire storage events
  if (window.storageCooldown) return;
  window.storageCooldown = true;
  
  setTimeout(() => {
    window.storageCooldown = false;
  }, 500); // 0.5 second cooldown

  // 1) ping intended for buyers
  if (e.key.startsWith('orders_ping__buyer__')) {
    const uidMatch = e.key.match(/^orders_ping__buyer__(.+)$/);
    if (uidMatch) {
  const buyerUid = uidMatch[1];
  const currentUid = getUid();
  if (buyerUid === currentUid) {
    // reload from Firestore
    orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
    await renderOrders();
    showToast('Order status updated!', 'success');
  }
}
    return;
  }

  // 1b) global canonical changed ‚Äî re-render merged view
  // 1b) global canonical changed ‚Äî re-render merged view
if (e.key === ORDERS_GLOBAL) {
  try {
    orders = await loadOrdersFromAllSources(); // ‚Üê FIXED
    await renderOrders();
    showToast('Order status synced', 'success');
  } catch (err) {
    console.warn('orders_global storage event handling failed', err);
  }
  return;
}

  // 2) If namespaced orders key changed (buyer local) -> re-render merged
  const ordersKey = ORDERS_KEY();
  const cartKey = CART_KEY();
  const productsKey = PRODUCTS_KEY();

if (e.key === ordersKey) {
  try {
    orders = await loadOrdersFromAllSources(); // ‚Üê NEW LINE
  } catch (err) {
    orders = readJsonKey(ordersKey, []);
  }
  await renderOrders();
  return;
}

  // 3) cart changed -> update badge
  if (e.key === cartKey) {
    updateCartCount();
    return;
  }

  // 4) product catalog changed -> re-render orders (optional)
  if (e.key === productsKey) {
  orders = await loadOrdersFromAllSources();
  await renderOrders();
  return;
  }

});


// --- Initial render ---
// --- Initial render ---
document.addEventListener('DOMContentLoaded', async () => {
  console.log('üöÄ Orders page initialized');
  
  // Load products from Firestore on startup
  await loadProductsFromFirestore();
  
  // Setup sync listeners
  setupProductSync();
  
  // üî• ADD THIS: Setup real-time order listener
  setupOrderUpdateListener();

  // Load and render orders
  await loadOrders();
  await renderOrders();
  renderCompletedOrders();
  
  console.log('‚úÖ Orders page ready');
});

</script>












</body>
</html>
