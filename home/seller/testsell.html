<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Seller Dashboard ‚Äî Marketplace</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  /* ===== MOBILE-FIRST RESPONSIVE CSS ===== */
  :root {
    --primary: #2563eb;
    --success: #10b981;
    --warn: #f59e0b;
    --danger: #ef4444;
    --light-bg: #f9fafb;
    --dark-bg: #0f172a;
    --card: #fff;
    --card-dark: #1e293b;
    --text-dark: #1e293b;
    --text-light: #f8fafc;
    --muted: #64748b;
    --radius: 8px;
    --trans: all 0.2s ease;
    --excel-border: #c9d4e8;
    --badge-bg: #ef4444;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: Inter, Arial, sans-serif;
    margin: 0;
    background: var(--light-bg);
    color: var(--text-dark);
    padding: 12px;
    transition: var(--trans);
    font-size: 14px;
    line-height: 1.4;
  }

  body.dark-mode {
    background: var(--dark-bg);
    color: var(--text-light);
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
  }

  /* ===== HEADER ===== */
  .header {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 16px;
  }

  .title {
    display: flex;
    align-items: flex-start;
    gap: 10px;
  }

  .title h1 {
    font-size: 1.3rem;
    margin: 0;
    color: var(--primary);
    line-height: 1.2;
  }

  .small-muted {
    font-size: 0.8rem;
    color: var(--muted);
    line-height: 1.3;
  }

  .user-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: space-between;
  }

  .icon-btn {
    background: transparent;
    border: none;
    padding: 6px;
    border-radius: 6px;
    cursor: pointer;
    color: inherit;
    font-size: 0.9rem;
  }

  .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(0, 0, 0, 0.06);
  }

  .profile-dropdown {
    position: relative;
  }

  .dropdown-menu {
    position: absolute;
    right: 0;
    top: 42px;
    background: var(--card);
    border-radius: 6px;
    padding: 6px 0;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    display: none;
    min-width: 160px;
    z-index: 100;
  }

  body.dark-mode .dropdown-menu {
    background: var(--card-dark);
  }

  .dropdown-menu a {
    display: block;
    padding: 8px 12px;
    color: inherit;
    text-decoration: none;
    font-size: 0.85rem;
  }

  .dropdown-menu a:hover {
    background: rgba(0, 0, 0, 0.04);
  }

  /* ===== CONTROLS ROW ===== */
  .controls-row {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: stretch;
    margin-bottom: 12px;
  }

  /* ===== SECTIONS & CARDS ===== */
  .section {
    background: var(--card);
    border-radius: var(--radius);
    padding: 12px;
    margin-bottom: 16px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
    transition: var(--trans);
    overflow: hidden;
  }

  body.dark-mode .section {
    background: var(--card-dark);
  }

  .section h2 {
    margin: 0 0 8px 0;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  /* ===== BADGE FOR NEW ORDERS ===== */
  .section .new-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-left: 6px;
  }

  .new-badge .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--badge-bg);
    position: relative;
    box-shadow: 0 0 6px rgba(239, 68, 68, 0.6);
  }

  .new-badge .count {
    background: var(--badge-bg);
    color: #fff;
    padding: 3px 6px;
    border-radius: 999px;
    font-weight: 700;
    font-size: 0.75rem;
    min-width: 22px;
    text-align: center;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.6);
    }

    70% {
      box-shadow: 0 0 0 6px rgba(239, 68, 68, 0);
    }

    100% {
      box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
    }
  }

  .new-badge .dot.pulse {
    animation: pulse 1.6s infinite;
  }

  /* ===== TABLE (EXCEL-LIKE GRID) ===== */
  .table-wrap {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    border: 1px solid var(--excel-border);
    border-radius: var(--radius);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    min-width: 600px;
    background: transparent;
    font-size: 0.85rem;
  }

  th,
  td {
    padding: 8px 10px;
    border: 1px solid var(--excel-border);
    text-align: left;
    vertical-align: middle;
  }

  th {
    background: #f3fdff;
    font-weight: 600;
    font-size: 0.8rem;
  }

  body.dark-mode th,
  body.dark-mode td {
    border-color: rgba(255, 255, 255, 0.06);
  }

  tr:hover td {
    background: rgba(0, 0, 0, 0.02);
  }

  .status-badge {
    padding: 4px 8px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 0.75rem;
    display: inline-block;
  }

  .s-pending {
    background: #fff7ed;
    color: #92400e;
  }

  .s-accepted {
    background: #dbeafe;
    color: #1e40af;
  }

  .s-processing {
    background: #fff3bf;
    color: #92400e;
  }

  .s-delivering {
    background: #d1fae5;
    color: #065f46;
  }

  .s-atdoor {
    background: #fef3c7;
    color: #92400e;
  }

  .s-delivered {
    background: #dcfce7;
    color: #065f46;
  }

  .s-rejected {
    background: #fecaca;
    color: #7f1d1d;
  }

  /* ===== ACTIONS ===== */
  .actions {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }

  .btn {
    padding: 6px 8px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.8rem;
    white-space: nowrap;
  }

  .btn-edit {
    background: var(--primary);
    color: #fff;
  }

  .btn-delete {
    background: var(--danger);
    color: #fff;
  }

  .btn-accept {
    background: var(--success);
    color: #fff;
  }

  .btn-warn {
    background: var(--warn);
    color: #fff;
  }

  .btn-muted {
    background: transparent;
    border: 1px solid #e6eefc;
  }

  /* ===== ORDER DETAILS EXPANDED PANE ===== */
  .order-details {
    margin-top: 8px;
    padding: 10px;
    border-radius: 6px;
    background: var(--light-bg);
    display: none;
    border: 1px solid var(--excel-border);
    font-size: 0.85rem;
  }

  body.dark-mode .order-details {
    background: rgba(255, 255, 255, 0.03);
  }

  .order-items {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .order-item {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .item-thumb {
    width: 50px;
    height: 50px;
    border-radius: 6px;
    object-fit: cover;
    border: 1px solid #e6eefc;
  }

  /* ===== THUMBNAIL IN LIST ===== */
  .row-thumb {
    width: 40px;
    height: 40px;
    border-radius: 5px;
    object-fit: cover;
    border: 1px solid #e6eefc;
    margin-right: 8px;
    vertical-align: middle;
  }

  /* ===== MODAL ===== */
  .modal {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.45);
    z-index: 999;
    padding: 12px;
  }

  .modal-card {
    background: var(--card);
    padding: 16px;
    border-radius: 8px;
    width: 100%;
    max-width: 420px;
    max-height: 90vh;
    overflow-y: auto;
  }

  body.dark-mode .modal-card {
    background: var(--card-dark);
  }

  .modal-card h3 {
    margin: 0 0 8px 0;
    font-size: 1.1rem;
  }

  .input,
  select {
    width: 100%;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #e6eefc;
    margin-top: 8px;
    font-size: 0.9rem;
  }

  /* ===== TOAST ===== */
  #toastContainer {
    position: fixed;
    right: 12px;
    bottom: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1000;
    max-width: calc(100vw - 24px);
  }

  .toast {
    padding: 8px 12px;
    border-radius: 6px;
    color: #fff;
    min-width: 200px;
    max-width: 280px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    font-size: 0.85rem;
  }

  .toast-success {
    background: var(--success);
  }

  .toast-error {
    background: var(--danger);
  }

  .toast-warn {
    background: var(--warn);
  }

  /* ===== ANALYTICS GRID ===== */
  .analytics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 10px;
    margin-top: 12px;
  }

  .analytics-item {
    text-align: center;
    padding: 10px;
    background: var(--light-bg);
    border-radius: var(--radius);
  }

  body.dark-mode .analytics-item {
    background: rgba(255, 255, 255, 0.05);
  }

  .analytics-item strong {
    display: block;
    font-size: 0.85rem;
    margin-bottom: 4px;
  }

  /* ===== MEDIA QUERIES ===== */

  /* Small phones (up to 360px) */
  @media (max-width: 360px) {
    body {
      padding: 8px;
      font-size: 13px;
    }

    .section {
      padding: 10px;
    }

    .user-controls {
      gap: 6px;
    }

    .btn {
      padding: 5px 7px;
      font-size: 0.75rem;
    }

    table {
      min-width: 500px;
      font-size: 0.8rem;
    }

    th,
    td {
      padding: 6px 8px;
    }
  }

  /* Medium phones (361px to 480px) */
  @media (min-width: 361px) and (max-width: 480px) {
    .user-controls {
      justify-content: flex-start;
    }

    .controls-row {
      flex-direction: row;
      flex-wrap: wrap;
    }
  }

  /* Large phones (481px to 767px) */
  @media (min-width: 481px) {
    .header {
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
    }

    .controls-row {
      flex-direction: row;
      align-items: center;
    }

    .user-controls {
      justify-content: flex-end;
    }
  }

  /* Tablets and larger (768px+) */
  @media (min-width: 768px) {
    body {
      padding: 16px;
      font-size: 14px;
    }

    .section {
      padding: 16px;
    }

    .title h1 {
      font-size: 1.5rem;
    }

    .controls-row {
      flex-direction: row;
      align-items: center;
    }

    table {
      min-width: 680px;
      font-size: 0.85rem;
    }

    th,
    td {
      padding: 10px 12px;
    }

    .btn {
      padding: 8px 10px;
      font-size: 0.8rem;
    }
  }

  /* Desktop (900px+) */
  @media (min-width: 900px) {
    .analytics-grid {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
  }

  /* ===== UTILITY CLASSES ===== */
  .text-center {
    text-align: center;
  }

  .text-left {
    text-align: left;
  }

  .text-right {
    text-align: right;
  }

  .mb-1 {
    margin-bottom: 8px;
  }

  .mb-2 {
    margin-bottom: 16px;
  }

  .mt-1 {
    margin-top: 8px;
  }

  .mt-2 {
    margin-top: 16px;
  }

  .hidden {
    display: none;
  }

  .flex {
    display: flex;
  }

  .flex-col {
    flex-direction: column;
  }

  .items-center {
    align-items: center;
  }

  .justify-between {
    justify-content: space-between;
  }

  .gap-1 {
    gap: 8px;
  }

  .gap-2 {
    gap: 16px;
  }

  .w-full {
    width: 100%;
  }

  /* ===== VALIDATION STYLES ===== */
  .input:invalid {
    border-color: var(--danger);
    box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.1);
  }

  .input:focus:invalid {
    border-color: var(--danger);
    box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
  }

  .validation-message {
    color: var(--danger);
    font-size: 0.75rem;
    margin-top: 4px;
    display: none;
  }

  .input:invalid+.validation-message {
    display: block;
  }
</style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="title">
        <i class="fas fa-store" style="font-size:1.4rem;color:var(--primary)"></i>
        <div>
          <h1>Seller Dashboard</h1>
          <div class="small-muted">Marketplace ‚Äî Manage orders (simple flow)</div>
        </div>
      </div>

      <div class="user-controls">
        <button id="openAdd" class="btn btn-edit"><i class="fas fa-plus"></i>&nbsp;Add Product</button>
        <button id="resetData" class="btn btn-warn" title="Clear all test data"><i
            class="fas fa-trash-alt"></i>&nbsp;Reset Data</button>
        <button id="toggleTheme" class="icon-btn" title="Toggle theme"><i class="fas fa-moon"></i></button>
        <div class="profile-dropdown">
          <img id="userAvatar" class="avatar" src="../../images/no profile pic.jpg" alt="profile">
          <div class="dropdown-menu" id="profileMenu">
            <a href="../profile/profile.html"><i class="fas fa-user"></i>Profile</a>
            <a href="../shopping/orders/orders.html"><i class="fas fa-box"></i>Orders</a>
            <a href="../delivery/delivery.html"><i class="fas fa-shipping-fast"></i>Carriers</a>
            <a href="../market/market.html"><i class="fas fa-store"></i>Guild Forge</a>
            <a href="../shopping/cart/cart.html"><i class="fas fa-shopping-cart"></i>Cart</a>
            <a href="../community/community.html"><i class="fas fa-users"></i>Guild Hall</a>
            <a href="../map/map.html"><i class="fas fa-map-marker-alt"></i>Map</a>
            <div style="height:1px;background:#eee;margin:6px 0"></div>
            <a href="#" id="logoutBtn"><i class="fas fa-sign-out-alt"></i>Leave Guildite</a>
          </div>
        </div>
      </div>
    </div>

    <!-- Products -->
    <section class="section" id="sectionProducts">
      <h2><i class="fas fa-box-open"></i>&nbsp; My Listings</h2>
      <div class="controls-row">
        <input id="productSearch" class="input" placeholder="Search products by name..." style="max-width:320px">
        <select id="productStatusFilter" class="input" style="max-width:200px">
          <option value="">All product status</option>
          <option>Active</option>
          <option>Out of Stock</option>
        </select>
        <select id="productCategoryFilter" class="input" style="max-width:200px">
          <option value="">All categories</option>
        </select>
      </div>
      <div class="table-wrap">
        <table id="prodTable">
          <thead>
            <tr>
              <th>Product</th>
              <th>Price</th>
              <th>Quantity</th>
              <th>Condition</th>
              <th>Category</th>
              <th>Status</th>
              <th>Added</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Orders -->
    <section class="section" id="sectionOrders">
      <h2>
        <i class="fas fa-shopping-cart"></i>&nbsp; Customer Orders
        <span class="new-badge" id="ordersBadge" title="Active orders" style="display:none">
          <span class="dot pulse" id="ordersDot"></span>
          <span class="count" id="ordersCount">0</span>
        </span>
      </h2>
      <div class="controls-row">
        <input id="orderSearch" class="input" placeholder="Search by buyer or product..." style="max-width:320px">
        <select id="orderFilterSelect" class="input" style="max-width:220px">
          <option value="">All order status</option>
          <option>Pending</option>
          <option>Accepted</option>
          <option>Processing</option>
          <option>Delivering</option>
          <option>At Door</option>
          <option>Delivered</option>
          <option>Rejected</option>
        </select>
      </div>

      <div class="table-wrap">
        <table id="ordersTable">
          <thead>
            <tr>
              <th>Order ID</th>
              <th>Buyer</th>
              <th>Product(s)</th>
              <th>Qty</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Completed / History -->
    <section class="section" id="sectionHistory">
      <h2><i class="fas fa-history"></i>&nbsp; Completed Orders (History)</h2>
      <div class="controls-row">
        <input id="historySearch" class="input" placeholder="Search completed orders..." style="max-width:320px">
        <div style="margin-left:auto;display:flex;gap:8px">
          <button id="exportCsv" class="btn btn-edit"><i class="fas fa-file-csv"></i>&nbsp;Export CSV</button>
          <button id="clearHistory" class="btn btn-warn"><i class="fas fa-trash"></i>&nbsp;Clear History</button>
        </div>
      </div>
      <div class="table-wrap">
        <table id="completedTable">
          <thead>
            <tr>
              <th>Order ID</th>
              <th>Buyer</th>
              <th>Product(s)</th>
              <th>Qty</th>
              <th>Total</th>
              <th>Delivered At</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Analytics -->
    <section class="section" id="sectionAnalytics">
      <h2><i class="fas fa-chart-line"></i>&nbsp; Sales Analytics</h2>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-top:12px">
        <div><strong>Total Sales</strong>
          <div id="cardTotal" class="small-muted">GHC 0</div>
        </div>
        <div><strong>Orders</strong>
          <div id="cardOrders" class="small-muted">0</div>
        </div>
        <div><strong>Pending</strong>
          <div id="cardPending" class="small-muted">0</div>
        </div>
        <div><strong>Active Listings</strong>
          <div id="cardActive" class="small-muted">0</div>
        </div>
        <div><strong>Total Stock</strong>
          <div id="cardStock" class="small-muted">0</div>
        </div>
      </div>
    </section>

  </div>

  <!-- Product modal -->
  <div class="modal" id="productModal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true">
      <h3 id="productModalTitle">Add product</h3>
      <input id="pName" class="input" placeholder="Product name">
      <input id="pPrice" class="input" type="number" placeholder="Price (GHC)" min="0" step="0.01">
      <input id="pQuantity" class="input" type="number" placeholder="Quantity" min="0" step="1"
        onkeydown="return event.keyCode !== 69 && event.keyCode !== 189">
      <select id="pCondition" class="input">
        <option>New</option>
        <option>Good</option>
        <option>Fair</option>
        <option>Poor</option>
      </select>

      <!-- CATEGORY SELECT (predefined only) -->
      <select id="pCategory" class="input" style="margin-top:8px">
        <option value="">Uncategorized</option>
      </select>

      <label for="pDescription">Description</label>
      <textarea id="pDescription" rows="1" placeholder="Enter product description"></textarea>


      <select id="pStatus" class="input" style="margin-top:8px">
        <option>Active</option>
        <option>Out of Stock</option>
      </select>
      <div style="margin-top: 8px;">
        <label class="small-muted">Product Image</label>
        <input id="pImage" class="input" type="file" accept="image/*">
        <div class="small-muted" style="font-size: 0.75rem; margin-top: 4px;">
          All formats supported ‚Ä¢ Auto-optimized for best quality ‚Ä¢ Max 10MB
        </div>
      </div>
      <img id="pPreview" style="width:96px;height:96px;border-radius:8px;object-fit:cover;display:none;margin-top:8px"
        alt="preview">
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="pCancel" class="btn">Cancel</button>
        <button id="pSave" class="btn btn-edit">Save product</button>
      </div>

    </div>
  </div>

  <!-- Delivery code modal -->
  <div id="codeModal" class="modal" style="display:none">
    <div class="modal-card">
      <h3>Enter Delivery Code</h3>
      <div class="small-muted">Ask the buyer for the delivery code and enter it here to confirm delivery.</div>
      <input id="deliveryCodeInput" class="input" placeholder="6-digit code">
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
        <button id="cancelDelivery" class="btn btn-warn">Cancel</button>
        <button id="confirmDelivery" class="btn btn-accept">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Toasts -->
  <div id="toastContainer" aria-live="polite"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
    import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-database.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, updateDoc, collection, addDoc, deleteDoc,getDocs,query,where, writeBatch, onSnapshot } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

    // --- Firebase Config ---
    const firebaseConfig = {
      apiKey: "AIzaSyBzPa671GH71UvTcZ3dECFPrW4xe1vS9ds",
      authDomain: "marketplace-e0bff.firebaseapp.com",
      projectId: "marketplace-e0bff",
      storageBucket: "marketplace-e0bff.appspot.com",
      messagingSenderId: "892936444768",
      appId: "1:892936444768:web:f595b3a3e5d697988e1c05",
      databaseURL: "https://marketplace-e0bff-default-rtdb.europe-west1.firebasedatabase.app"
    };

    // --- Init ---
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    const auth = getAuth(app);
    const firestore = getFirestore(app);

const DEFAULT_AVATAR = "../../images/no profile pic.jpg";

    // Add this to your imports section
const CLOUDINARY_UPLOAD_URL = `https://api.cloudinary.com/v1_1/dsj9imkpp/image/upload`;
const CLOUDINARY_UPLOAD_PRESET = 'marketplace_products'; // You need to create this preset

    /* ====== NAMESPACE / UID HELPERS ====== */

    // detect page role (we're on seller dashboard so default to seller)
    function detectPageRole() {
      try { return (document?.body?.dataset?.role || '').toLowerCase() || (window.location.pathname || '').toLowerCase().includes('testsell') ? 'seller' : 'buyer'; }
      catch (e) { return 'seller'; }
    }

    // get current signed-in uid (sessionStorage set during auth elsewhere)
    function getUid() {
      // fallback to firebase auth current user if session storage missing
      try { return sessionStorage.getItem('uid') || (auth.currentUser && auth.currentUser.uid) || null; }
      catch (e) { return sessionStorage.getItem('uid'); }
    }

    // ‚úÖ ADD THIS FUNCTION - Load products from Firestore on startup
async function loadProductsFromFirestore() {
  try {
    const uid = getUid();
    if (!uid) {
      console.warn('No user ID - cannot load products');
      return [];
    }
    
    console.log('üîÑ Loading products from Firestore (cloud)...');
    
    // Import Firestore functions at the top of your script if not already done:
    // import { collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";
    
    // Get ALL products from Firestore
    const productsCollection = collection(firestore, "products");
    const querySnapshot = await getDocs(productsCollection);
    
    const allProducts = [];
    querySnapshot.forEach((docSnap) => {
      const data = docSnap.data();
      // Only include approved products
      if (data.approved !== false) {
        allProducts.push({
          id: docSnap.id,
          ...data
        });
      }
    });
    
    console.log('üì¶ Total products in Firestore:', allProducts.length);
    
    // Filter to only THIS seller's products
    const sellerProducts = allProducts.filter(p => 
      String(p.sellerId) === String(uid) || 
      String(p.sellerUid) === String(uid)
    );
    
    console.log('üë§ Your products:', sellerProducts.length);
    
    // ‚úÖ CRITICAL: Update localStorage cache (but Firestore is the source of truth)
    const sellerProductsKey = productsKey();
    localStorage.setItem(sellerProductsKey, JSON.stringify(sellerProducts));
    
    // Update global state
    products = sellerProducts;
    
    console.log('‚úÖ Products loaded from Firestore and cached locally');
    return sellerProducts;
    
  } catch (error) {
    console.error('‚ùå Failed to load from Firestore:', error);
    
    // FALLBACK: Try localStorage as last resort
    const sellerProductsKey = productsKey();
    const cachedProducts = JSON.parse(localStorage.getItem(sellerProductsKey) || '[]');
    console.log('‚ö†Ô∏è Using cached products as fallback:', cachedProducts.length);
    
    products = cachedProducts;
    return cachedProducts;
  }
}
    // ‚úÖ ADD TO SELLER PAGE: Function to sync seller's products to Firestore
// ‚úÖ STEP 2: Auto-sync products TO Firestore whenever localStorage changes
async function syncSellerProductsToFirestore() {
  try {
    const uid = getUid();
    if (!uid) return;
    
    const sellerProductsKey = productsKey();
    const sellerProducts = JSON.parse(localStorage.getItem(sellerProductsKey) || '[]');
    
    console.log('üîÑ Syncing products to Firestore...', sellerProducts.length);
    
    // Save each product to Firestore
    for (const product of sellerProducts) {
      const productRef = doc(firestore, "products", product.id);
      
      const productData = {
        ...product,
        sellerId: uid,
        sellerUid: uid,
        updatedAt: new Date().toISOString(),
        // Ensure all required fields exist
        approved: product.approved !== false,
        createdAt: product.createdAt || new Date().toISOString()
      };
      
      await setDoc(productRef, productData, { merge: true });
    }
    
    // Also update user's products array
    const userDocRef = doc(firestore, "users", uid);
    await setDoc(userDocRef, { 
      products: sellerProducts,
      updatedAt: new Date().toISOString()
    }, { merge: true });
    
    console.log('‚úÖ Synced to Firestore successfully');
    
  } catch (error) {
    console.error('‚ùå Sync to Firestore failed:', error);
  }
}

// ‚úÖ STEP 3: Watch for changes and auto-sync
let syncTimeout;
function scheduleSync() {
  clearTimeout(syncTimeout);
  syncTimeout = setTimeout(() => {
    syncSellerProductsToFirestore();
  }, 2000); // Sync 2 seconds after last change
}


    // make namespaced key: base__role__uid
    function nsKey(base, { role = null, uid = null } = {}) {
      const r = role || detectPageRole() || 'seller';
      const u = uid || getUid() || 'anon';
      return `${String(base)}__${String(r)}__${String(u)}`;
    }

    // helpers for common keys used across pages
    function productsKey() { return nsKey('products'); }
    function ordersKey() { return nsKey('orders'); }
    function cartKey() { return nsKey('cart'); }
    function wishlistKey() { return nsKey('wishlist'); }
    function completedOrdersKey() { return nsKey('completedOrders'); }

    // safe read/write JSON
    function readJson(k, fallback = []) {
      try { return JSON.parse(localStorage.getItem(k) || JSON.stringify(fallback)); }
      catch (e) { return fallback; }
    }
    function writeJson(k, data) {
      try { localStorage.setItem(k, JSON.stringify(data || [])); }
      catch (e) { console.warn('writeJson failed', e); }
    }

    /* ---------- Helper: fetch seller info live by UID ---------- */
    async function getSellerInfo(uid) {
      if (!uid) return null;
      try {
        const userRef = ref(database, `users/${uid}`);
        const snap = await get(userRef);
        return snap.exists() ? snap.val() : null;
      } catch (err) {
        console.error("Error fetching seller info:", err);
        return null;
      }
    }

    
    
    // üî• ADD THIS RIGHT AFTER getSellerInfo function
function cleanFirestoreData(data) {
  const cleaned = { ...data };
  Object.keys(cleaned).forEach(key => {
    if (cleaned[key] === undefined) {
      delete cleaned[key];
    }
  });
  return cleaned;
}

    const ORDERS_GLOBAL = "orders_global";

    // --- ADD THESE TWO FUNCTIONS ---
    function getGlobalOrders() {
      try {
        return JSON.parse(localStorage.getItem(ORDERS_GLOBAL)) || [];
      } catch (e) {
        return [];
      }
    }

    function saveGlobalOrders(data) {
      try {
        localStorage.setItem(ORDERS_GLOBAL, JSON.stringify(data || []));
      } catch (e) {
        console.warn('saveGlobalOrders failed', e);
      }
    }
    // --- END OF ADDED FUNCTIONS ---


    // --- DOM ---
    const avatarEl = document.getElementById('userAvatar');
    const logoutBtn = document.getElementById('logoutBtn');

    // --- Auth Handling ---
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "../../index.html";
        return;
      }

      // ensure per-seller storage keys exist
      const uid = user.uid;
      try {
        if (!localStorage.getItem(productsKey())) localStorage.setItem(productsKey(), JSON.stringify([]));
        if (!localStorage.getItem(ordersKey())) localStorage.setItem(ordersKey(), JSON.stringify([]));
        if (!localStorage.getItem(completedOrdersKey())) localStorage.setItem(completedOrdersKey(), JSON.stringify([]));
        if (!localStorage.getItem(cartKey())) localStorage.setItem(cartKey(), JSON.stringify([]));
        if (!localStorage.getItem(wishlistKey())) localStorage.setItem(wishlistKey(), JSON.stringify([]));
      } catch (e) { console.warn('init seller boxes failed', e); }

      const userRef = ref(database, `users/${user.uid}`);
      const snapshot = await get(userRef);

      if (!snapshot.exists()) {
        window.location.href = "../../index.html";
        return;
      }

      const userData = snapshot.val();

      // Security checks
      if (userData.declined) {
        window.location.href = "../../adminlogic/declined/declined.html";
        return;
      }
      if (userData.banned) {
        window.location.href = "../../adminlogic/banned/banned.html";
        return;
      }

      // ‚úÖ Update avatar (seller dashboard)
      if (avatarEl) {
        avatarEl.src = userData.profilePictureUrl || "../../images/no profile pic.jpg";
        avatarEl.alt = (userData.name || "User") + "'s profile picture";
      }

      
    });

    // --- Logout ---
    if (logoutBtn) {
      logoutBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        await signOut(auth);
        window.location.href = "../../index.html";
      });
    }

    /* ---------- Utilities ---------- */
    const qs = s => document.querySelector(s);
    const qsa = s => Array.from(document.querySelectorAll(s));
    const nowISO = () => new Date().toISOString();
    const fmtDate = iso => iso ? new Date(iso).toLocaleString() : '';
    const escapeHtml = s => String(s || '').replace(/[&<>"'`=\/]/g, ch => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;' })[ch]);

    /* ---------- Predefined categories (admins only can change these offline) ---------- */
    const PREDEFINED_CATEGORIES = ['Food', 'Books', 'Electronics', 'Others', 'Services', 'Clothing'];

    /* ---------- Data (localStorage) ---------- */
    let products = JSON.parse(localStorage.getItem(productsKey()) || '[]');
    let orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
    let completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]');

    /* ensure default fields exist on orders */
    function normalizeOrderFields(o) {
      if (!o) return o;
      if (!Array.isArray(o.bidders)) o.bidders = [];
      if (!o.history) o.history = [];
      if (typeof o.attempts === 'undefined') o.attempts = 0;
      if (typeof o.requestActive === 'undefined') o.requestActive = false;
      if (typeof o.ownerIsDelivering === 'undefined') o.ownerIsDelivering = false;
      return o;
    }

    // SHARED STORAGE FOR DELIVERY REQUESTS - Add this to both files

    // Public area where all delivery requests are posted
    function publicDeliveryRequestsKey() {
      return 'public_delivery_requests';
    }

    // Get all open delivery requests (for delivery guys)
    // Get all open delivery requests (for delivery guys)
// Get all open delivery requests (for delivery guys)
async function getPublicDeliveryRequests() {
  try {
    // Try to get from Firestore first
    const deliveryRequestsRef = collection(firestore, "deliveryRequests");
    const q = query(deliveryRequestsRef, where("status", "==", "open"));
    const querySnapshot = await getDocs(q);
    
    const requests = [];
    querySnapshot.forEach((doc) => {
      requests.push({ 
        id: doc.id, 
        ...doc.data(),
        // Ensure dates are properly formatted
        createdAt: doc.data().createdAt?.toDate ? 
                  doc.data().createdAt.toDate().toISOString() : 
                  doc.data().createdAt,
        updatedAt: doc.data().updatedAt?.toDate ? 
                  doc.data().updatedAt.toDate().toISOString() : 
                  doc.data().updatedAt,
        expiresAt: doc.data().expiresAt?.toDate ? 
                  doc.data().expiresAt.toDate().toISOString() : 
                  doc.data().expiresAt
      });
    });
    
    console.log('üì¶ Loaded delivery requests from Firestore:', requests.length);
    
    // Also save to localStorage for fallback
    localStorage.setItem(publicDeliveryRequestsKey(), JSON.stringify(requests));
    
    return requests;
    
  } catch (error) {
    console.error('‚ùå Failed to load from Firestore, falling back to localStorage:', error);
    
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem(publicDeliveryRequestsKey());
      if (stored) {
        return JSON.parse(stored);
      }
      return [];
    } catch (e) {
      console.error('‚ùå Failed to parse localStorage:', e);
      return []; // Always return an array
    }
  }
}

    // Save delivery requests to public area
    // ‚úÖ NEW - Uses Firestore
// ‚úÖ NEW - Uses Firestore with batch operations
async function savePublicDeliveryRequests(requests) {
  try {
    if (!requests || !requests.length) return;
    
    // Use batch for better performance
    const batch = writeBatch(firestore);
    
    for (const request of requests) {
      const docRef = doc(firestore, "deliveryRequests", request.id);
      
      // Prepare clean data without undefined values
      const cleanRequest = cleanFirestoreData({
        ...request,
        updatedAt: new Date()
      });
      
      batch.set(docRef, cleanRequest, { merge: true });
    }
    
    await batch.commit();
    
    console.log('‚úÖ Saved delivery requests to Firestore');
    window.dispatchEvent(new Event('publicDeliveryRequestsUpdated'));
    
  } catch (e) {
    console.error('‚ùå Failed to save public delivery requests:', e);
    // Fallback to localStorage
    localStorage.setItem(publicDeliveryRequestsKey(), JSON.stringify(requests));
  }
}
    /* ---------- DOM elements ---------- */
    const prodTbody = qs('#prodTable tbody');
    const ordersTbody = qs('#ordersTable tbody');
    const completedTbody = qs('#completedTable tbody');
    const productSearch = qs('#productSearch');
    const productStatusFilter = qs('#productStatusFilter');
    const orderSearch = qs('#orderSearch');
    const orderFilter = qs('#orderFilterSelect');
    const historySearch = qs('#historySearch');

    const openAdd = qs('#openAdd'), toggleTheme = qs('#toggleTheme'), profileMenu = qs('#profileMenu'), avatar = qs('#userAvatar');
    const resetDataBtn = qs('#resetData');

    const productModal = qs('#productModal'), pName = qs('#pName'), pPrice = qs('#pPrice'), pQuantity = qs('#pQuantity'),
      pCondition = qs('#pCondition'), pStatus = qs('#pStatus'), pImage = qs('#pImage'), pPreview = qs('#pPreview'),
      pCancel = qs('#pCancel'), pSave = qs('#pSave'), productModalTitle = qs('#productModalTitle'),
      pCategory = qs('#pCategory'), pDescription = qs('#pDescription');

    const codeModal = qs('#codeModal'), deliveryCodeInput = qs('#deliveryCodeInput'), confirmDeliveryBtn = qs('#confirmDelivery'), cancelDeliveryBtn = qs('#cancelDelivery');

    const toastContainer = qs('#toastContainer');

    const ordersBadge = qs('#ordersBadge');
    const ordersCountEl = qs('#ordersCount');
    const ordersDot = qs('#ordersDot');
    const exportCsvBtn = qs('#exportCsv');
    const clearHistoryBtn = qs('#clearHistory');

    const productCategoryFilter = qs('#productCategoryFilter');

    // ============================================
    // üéØ REAL-TIME QUANTITY VALIDATION
    // ============================================

    // Add real-time quantity validation
    pQuantity && pQuantity.addEventListener('input', function (e) {
      let value = parseInt(this.value) || 0;

      // If value is negative, set to 0
      if (value < 0) {
        this.value = 0;
        showToast('‚ö†Ô∏è Quantity set to 0 (cannot be negative)', 'warn');
      }

      // If not a whole number, round down
      if (!Number.isInteger(value)) {
        this.value = Math.floor(value);
        showToast('‚ö†Ô∏è Quantity must be a whole number', 'warn');
      }
    });

    // Prevent negative input on keypress
    pQuantity && pQuantity.addEventListener('keydown', function (e) {
      // Allow: backspace, delete, tab, escape, enter
      if ([46, 8, 9, 27, 13].includes(e.keyCode) ||
        // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
        (e.keyCode === 65 && e.ctrlKey === true) ||
        (e.keyCode === 67 && e.ctrlKey === true) ||
        (e.keyCode === 86 && e.ctrlKey === true) ||
        (e.keyCode === 88 && e.ctrlKey === true) ||
        // Allow: home, end, left, right
        (e.keyCode >= 35 && e.keyCode <= 39)) {
        return;
      }

      // Ensure that it is a number and stop the keypress if not
      if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
        e.preventDefault();
      }
    });

    // Also add for price field to prevent negatives
    pPrice && pPrice.addEventListener('input', function (e) {
      let value = parseFloat(this.value) || 0;

      if (value < 0) {
        this.value = 0;
        showToast('‚ö†Ô∏è Price set to 0 (cannot be negative)', 'warn');
      }
    });

    /* ---------- Toast ---------- */
    function showToast(msg, type = 'success') {
      const t = document.createElement('div');
      t.className = 'toast ' + (type === 'error' ? 'toast-error' : type === 'warn' ? 'toast-warn' : 'toast-success');
      t.textContent = msg;
      toastContainer.appendChild(t);
      setTimeout(() => t.remove(), 3000);
    }

    /* ---------- Profile menu toggle ---------- */
    avatar && avatar.addEventListener('click', e => { e.stopPropagation(); profileMenu.style.display = profileMenu.style.display === 'block' ? 'none' : 'block'; });
    document.addEventListener('click', () => profileMenu && (profileMenu.style.display = 'none'));

    /* ---------- Theme ---------- */
    (function initTheme() {
      if (localStorage.getItem('theme') === 'dark') document.body.classList.add('dark-mode');
    })();
    toggleTheme && toggleTheme.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
    });

    /* ---------- Reset Data (SELLER PRODUCTS + COMPLETED ORDERS) ---------- */
    resetDataBtn && resetDataBtn.addEventListener('click', () => {
      if (!confirm('Clear ALL your posted products and order history? This will remove all products you\'ve listed and all your completed orders. This cannot be undone.')) return;

      try {
        // Clear seller's products and completed orders
        products = [];
        completedOrders = [];

        // Clear seller's products and completed orders from localStorage
        localStorage.removeItem(productsKey()); // seller's posted products
        localStorage.removeItem(completedOrdersKey()); // seller's completed orders

        // Reinitialize empty arrays
        localStorage.setItem(productsKey(), '[]');
        localStorage.setItem(completedOrdersKey(), '[]');

        // Clear tracking variables
        localStorage._lastCompletedJson = '[]';
        localStorage._lastProductsJson = '[]';

        // Refresh displays
        renderProducts();
        renderCompletedOrders();
        renderAnalytics();

        showToast('Your products and order history have been cleared', 'success');
        console.log('‚úÖ Seller data reset: products and completed orders cleared');

      } catch (error) {
        console.error('‚ùå Error resetting seller data:', error);
        showToast('Error resetting data', 'error');
      }
    });

    /* ---------- Clear History (SELLER COMPLETED ORDERS ONLY) ---------- */
    clearHistoryBtn && clearHistoryBtn.addEventListener('click', () => {
      if (!confirm('Clear your completed order history? This will remove all your delivered and rejected orders from history. This cannot be undone.')) return;

      try {
        // Clear only seller's completed orders
        completedOrders = [];
        localStorage.setItem(completedOrdersKey(), JSON.stringify([]));

        // Update tracking
        localStorage._lastCompletedJson = '[]';

        // Refresh displays
        renderCompletedOrders();
        renderAnalytics();

        showToast('Your completed order history has been cleared', 'success');
        console.log('‚úÖ Seller completed orders history cleared');

      } catch (error) {
        console.error('‚ùå Error clearing seller history:', error);
        showToast('Error clearing history', 'error');
      }
    });

    /* ---------- Helpers ---------- */
    function getProgressStep(status) {
      switch ((status || '').toLowerCase()) {
        case 'pending': return 1;
        case 'accepted': return 2;
        case 'processing': return 3;
        case 'assigned': return 3;
        case 'ready for pickup': return 4;  // üÜï PICKUP STEP
        case 'picked up': return 5;         // üÜï PICKUP FINAL STEP
        case 'delivering': return 4;        // Delivery step
        case 'at door': return 5;           // Delivery step  
        case 'delivered': return 6;         // Delivery final step
        default: return 1;
      }
    }
    // -------------------------
    // Seller: reconcile final-status orders and move to completed
    // Paste this near the top of the seller script (before renderOrders)
    // -------------------------
    function isFinalStatus(status) {
      if (!status) return false;
      const s = String(status).toLowerCase();
      return ['delivered', 'rejected', 'cancelled', 'cancel', 'completed'].includes(s);
    }

    // üî• COMPLETELY REWRITTEN renderOrders - PREVENTS DUPLICATES
async function renderOrders(notifyNew = false) {
  try {
    console.log('üîÑ renderOrders started');
    
    if (!ordersTbody) return;
    
    syncSellerOrdersFromGlobal();
    
    // üéØ STEP 1: Look only in YOUR orders box
    let orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');

    // üéØ STEP 2: Check the big board for updates  
    syncSellerOrdersFromGlobal();

    // üéØ STEP 3: Only keep orders with YOUR name
    const sellerUid = getUid();
    orders = orders.filter(order =>
      order.intendedSellerId === sellerUid ||
      order.sellerId === sellerUid
    );
    
    // üî• CRITICAL FIX: CLEAR tbody FIRST before doing anything
    ordersTbody.innerHTML = '';

    let changed = false;
    orders.forEach((o, idx) => {
      normalizeOrderFields(o);
      if (typeof o.progressStep === 'undefined') { 
        o.progressStep = getProgressStep(o.status); 
        changed = true; 
      }
      if (!o.deliveryCode) { 
        assignDeliveryCode(o); 
        changed = true; 
      }
      if (!o.appearedAt) { 
        ensureAppearedAt(o); 
        changed = true; 
      }
      orders[idx] = o;
    });
    
    if (changed) localStorage.setItem(ordersKey(), JSON.stringify(orders));

    // ensure final-state orders moved into completed before rendering
    const reconciled = reconcileSellerOrders();
    let sellerOrders = reconciled.active || [];

    const sTerm = (orderSearch?.value || '').toLowerCase();
    const fStatus = orderFilter?.value;

    // If no active seller orders, show empty state and stop
    if (!sellerOrders.length) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="6" style="text-align:center;color:var(--muted)">No orders yet</td>`;
      ordersTbody.appendChild(tr);
      updateOrdersBadge(0);
      renderAnalytics();
      lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
      return;
    }

    // üî• CRITICAL FIX: Get public delivery requests ASYNCHRONOUSLY
    let publicRequests = [];
    try {
      console.log('üì• Loading public delivery requests...');
      publicRequests = await getPublicDeliveryRequests();
      console.log('‚úÖ Loaded public requests:', publicRequests.length);
    } catch (error) {
      console.error('‚ùå Failed to load public requests:', error);
      try {
        const stored = localStorage.getItem(publicDeliveryRequestsKey());
        publicRequests = stored ? JSON.parse(stored) : [];
      } catch (e) {
        console.error('‚ùå Failed to parse localStorage:', e);
        publicRequests = [];
      }
    }

    // Build filtered list from reconciled active orders
    const list = sellerOrders.slice().reverse().filter(o => {
      const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
      const buyerSearch = `${buyerObj?.name || o.buyerName || o.buyer || o.customer || ''} ${buyerObj?.phone || o.phone || ''} ${buyerObj?.email || o.email || ''} ${buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || ''}`;
      const combined = `${buyerSearch} ${JSON.stringify(o.items || o.product || '')}`;
      return (!sTerm || combined.toLowerCase().includes(sTerm) || String(o.id || '').includes(sTerm)) && (!fStatus || o.status === fStatus);
    });

    // üî• FIX: Use a DocumentFragment for better performance
    const fragment = document.createDocumentFragment();

    // Process each order
    for (const o of list) {
      if (typeof o.progressStep === 'undefined') o.progressStep = getProgressStep(o.status);
      if (!o.appearedAt) o.appearedAt = nowISO();

      const tr = document.createElement('tr');

      const thumbUrl = orderThumbnail(o) || 'https://via.placeholder.com/90';
      const itemsSummary = Array.isArray(o.items) ? o.items.map(i => i.name).join(', ') : (o.product || '-');
      const qty = Array.isArray(o.items) ? o.items.reduce((s, i) => s + (i.quantity || 1), 0) : (o.quantity || 1);

      // buyer display fields (favor object)
      const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
      const buyerNameDisplay = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
      const buyerPhoneDisplay = escapeHtml(buyerObj?.phone || o.phone || '');
      const buyerRoomDisplay = escapeHtml(buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '');
      const buyerAvatar = buyerObj?.profilePictureUrl || '';

      tr.innerHTML = `
    <td>
      ${escapeHtml(o.id || o.orderId || '')}
      <div class="small-muted">${fmtDate(o.appearedAt || o.date)}</div>
    </td>
    <td style="min-width:200px">
      ${buyerAvatar ? `<img src="${buyerAvatar}" style="width:28px;height:28px;border-radius:50%;vertical-align:middle;margin-right:8px">` : ''}
      <span style="vertical-align:middle">${buyerNameDisplay}</span>
      ${buyerPhoneDisplay ? `<div class="small-muted">üìû ${buyerPhoneDisplay}</div>` : ''}
      ${buyerRoomDisplay ? `<div class="small-muted">üè† ${buyerRoomDisplay}</div>` : ''}
    </td>
    <td style="max-width:320px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:flex;align-items:center">
      <img src="${thumbUrl}" class="row-thumb" alt="thumb">
      <div style="min-width:0">
        <div style="font-weight:700">${escapeHtml(itemsSummary)}</div>
        <div class="small-muted">first item</div>
      </div>
    </td>
    <td>${qty}</td>
    <td><span class="status-badge ${statusClass(o.status)}">${o.status || 'Pending'}</span></td>
    <td class="actions"></td>
  `;

      tr.addEventListener('click', e => { if (e.target.closest('.actions')) return; toggleDetailsFor(o); });

      const actTd = tr.querySelector('.actions');
      const st = (o.status || 'Pending');

      // üî• ENHANCED: Delivery-request controls (seller-side)
      const deliveryRequest = publicRequests.find(req =>
        req.orderId === o.id || req.orderId === o.orderId
      );

      const isAssignedInOrder = !!(o.assignedTo || o.assignedDeliveryId);
      const isAssignedInPublicRequest = !!(deliveryRequest && deliveryRequest.assignedTo);
      const isAssigned = isAssignedInOrder || isAssignedInPublicRequest;

      const isRequestActive = !!deliveryRequest && deliveryRequest.status === 'open' && !isAssigned;
      const biddersCount = deliveryRequest ? (deliveryRequest.bids || []).length : 0;
      const assignedTo = o.assignedTo || (deliveryRequest ? deliveryRequest.assignedTo : null) || null;
      const ownerIsDelivering = !!o.ownerIsDelivering;

      const isPickupOrder = o.deliveryType === 'pickup';

      // Show bidder count badge if there are bidders and request is still open
      if (biddersCount > 0 && !isAssigned) {
        const badge = document.createElement('span');
        badge.className = 'small-muted';
        badge.style.marginRight = '8px';
        badge.textContent = `Bidders: ${biddersCount}`;
        actTd.appendChild(badge);
      }

      // üî• PRIORITY 1: If assigned anywhere, show "Assigned" immediately
      if (isAssigned) {
        const assignedBtn = actionBtn('Assigned', 'btn-muted', () => showAssignedCourierDetails(o));
        assignedBtn.style.background = '#10b981';
        assignedBtn.style.color = 'white';
        assignedBtn.innerHTML = '<i class="fas fa-check-circle"></i> Assigned';
        actTd.appendChild(assignedBtn);

        if (assignedTo) {
          const assigneeInfo = document.createElement('span');
          assigneeInfo.className = 'small-muted';
          assigneeInfo.style.marginLeft = '8px';
          assigneeInfo.textContent = `to: ${assignedTo}`;
          actTd.appendChild(assigneeInfo);
        }
      }
      // üî• PRIORITY 2: Seller is self-delivering
      else if (ownerIsDelivering) {
        actTd.appendChild(actionBtn('You are delivering', 'btn-accept', () => {
          if (!o.assignedTo) {
            const sellerUid = auth.currentUser?.uid || null;
            if (sellerUid) assignCourier(o.id || o.orderId, sellerUid, 'Seller (self)');
          }
        }));
      }
      // üî• PRIORITY 3: Active request but not assigned
      else if (isRequestActive) {
        actTd.appendChild(actionBtn('Cancel Request', 'btn-warn', () => cancelDeliveryRequest(o.id || o.orderId)));
        actTd.appendChild(actionBtn('View Bidders', 'btn-muted', () => showBiddersModal(o)));
      }
      // üî• PRIORITY 4: No request yet - ONLY SHOW FOR DELIVERY ORDERS, NOT PICKUP
      else if (!isPickupOrder && (o.status || '').toLowerCase() === 'processing') {
        actTd.appendChild(actionBtn('Ask for Delivery', 'btn-edit', () => {
          askForDelivery(o.id || o.orderId, 300);
        }));
      }
      // üÜï Optional: Show a message when order is not ready for delivery
      else if (!isPickupOrder && ['pending', 'accepted'].includes((o.status || '').toLowerCase())) {
        const notReadyMsg = document.createElement('span');
        notReadyMsg.className = 'small-muted';
        notReadyMsg.style.color = 'var(--muted)';
        notReadyMsg.textContent = 'Complete order steps first';
        actTd.appendChild(notReadyMsg);
      }
      // üÜï PRIORITY 5: For pickup orders, show pickup info instead
      else if (isPickupOrder) {
        const pickupInfo = document.createElement('span');
        pickupInfo.className = 'small-muted';
        pickupInfo.style.color = 'var(--primary)';
        pickupInfo.innerHTML = '<i class="fas fa-store"></i> Pickup Order';
        actTd.appendChild(pickupInfo);
      }

      // Order flow actions
      if (st === 'Pending') {
        actTd.appendChild(actionBtn('Accept', 'btn-accept', () => changeOrderStatus(o, 'Accepted')));
        actTd.appendChild(actionBtn('Reject', 'btn-warn', () => rejectOrder(o)));
      } else if (st === 'Accepted') {
        actTd.appendChild(actionBtn('Start Processing', 'btn-edit', () => changeOrderStatus(o, 'Processing')));
        actTd.appendChild(actionBtn('Reject', 'btn-warn', () => rejectOrder(o)));
      } else if (st === 'Processing') {
        if (o.deliveryType === 'pickup') {
          actTd.appendChild(actionBtn('Ready for Pickup', 'btn-accept', () => handlePickupOrder(o)));
        } else {
          actTd.appendChild(actionBtn('Start Delivery', 'btn-edit', () => changeOrderStatus(o, 'Delivering')));
        }
        actTd.appendChild(actionBtn('Reject', 'btn-warn', () => rejectOrder(o)));

      } else if (st === 'Ready for Pickup') {
        actTd.appendChild(actionBtn('Confirm Pickup', 'btn-accept', () => openPickupConfirmationModal(o)));
        actTd.appendChild(actionBtn('Reject', 'btn-warn', () => rejectOrder(o)));
      } else if (st === 'Delivering') {
        actTd.appendChild(actionBtn('Mark At Door', 'btn-accept', () => changeOrderStatus(o, 'At Door')));
        actTd.appendChild(actionBtn('Reject', 'btn-warn', () => rejectOrder(o)));
      } else if (st === 'At Door') {
        actTd.appendChild(actionBtn('Confirm Delivery', 'btn-accept', () => openConfirmCodeModal(o)));
        actTd.appendChild(actionBtn('Reject', 'btn-warn', () => rejectOrder(o)));
      } else {
        actTd.appendChild(actionBtn('Details', 'btn-muted', () => toggleDetailsFor(o)));
      }

      if (!actTd.querySelector('.btn-muted')) {
        actTd.appendChild(actionBtn('Details', 'btn-muted', () => toggleDetailsFor(o)));
      }

      // üî• FIX: Add order to fragment instead of directly appending
      fragment.appendChild(tr);

      // üî• FIX: Create details row ONLY if order is in expanded view
      const detailsTr = document.createElement('tr'); 
      detailsTr.className = 'details-row'; 
      detailsTr.style.display = 'none';
      detailsTr.dataset.orderId = o.id || o.orderId; // Store order ID for tracking
      const td = document.createElement('td'); 
      td.colSpan = 6;

      const baseHtml = await renderOrderDetailsHtml(o);

      const bidsArr = Array.isArray(o.bids) && o.bids.length ? o.bids : (Array.isArray(o.bidders) ? o.bidders.map(b => ({
        bidderId: b.id || b.bidderId || '',
        bidderName: b.name || b.bidderName || '',
        bidderAvatar: b.profilePictureUrl || b.bidderAvatar || '',
        bidderPhone: b.phone || b.phone || '',
        bidderEmail: b.email || b.email || '',
        bidderIndex: b.index || b.index || '',
        bidderProgram: b.program || b.program || '',
        bidderRoom: b.room || b.room || '',
        amount: (typeof b.amount !== 'undefined' ? b.amount : (b.bidAmount || null)),
        eta: b.eta || null,
        placedAt: b.placedAt || b.requestedAt || b.requested || nowISO()
      })) : []);

      const biddersHtml = (bidsArr.length ? `<div style="margin-top:10px"><strong>Bidders (${bidsArr.length})</strong><div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">` + bidsArr.map(b => {
        const bidId = escapeHtml(b.bidderId || b.id || '');
        const name = escapeHtml(b.bidderName || b.bidderName || b.name || bidId);
        const avatar = escapeHtml(b.bidderAvatar || b.profilePictureUrl || '../../images/no profile pic.jpg');
        const amountText = (typeof b.amount !== 'undefined' && b.amount !== null) ? `GHC ${Number(b.amount).toFixed(2)}` : '';
        const etaText = b.eta ? ` ‚Ä¢ ETA: ${escapeHtml(String(b.eta))} min` : '';
        const placed = b.placedAt ? fmtDate(b.placedAt) : '';
        return `
      <div style="padding:10px;border-radius:8px;border:1px solid #f0f0f0;display:flex;gap:12px;align-items:flex-start;background:#fff">
        <img src="${avatar}" style="width:64px;height:64px;border-radius:8px;object-fit:cover">
        <div style="flex:1">
          <div style="font-weight:800;font-size:15px">${name}</div>
          <div class="small-muted" style="margin-top:4px">UID: ${bidId}</div>
          ${(amountText || etaText) ? `<div class="small-muted" style="margin-top:8px">${escapeHtml(amountText)}${escapeHtml(etaText)}</div>` : ''}
          ${b.bidderPhone ? `<div class="small-muted" style="margin-top:6px">üìû ${escapeHtml(b.bidderPhone)}</div>` : ''}
          ${b.bidderEmail ? `<div class="small-muted">‚úâÔ∏è ${escapeHtml(b.bidderEmail)}</div>` : ''}
          ${b.bidderIndex ? `<div class="small-muted">Index: ${escapeHtml(b.bidderIndex)}</div>` : ''}
          ${b.bidderProgram ? `<div class="small-muted">Program: ${escapeHtml(b.bidderProgram)}</div>` : ''}
          ${b.bidderRoom ? `<div class="small-muted">Room: ${escapeHtml(b.bidderRoom)}</div>` : ''}
          <div class="small-muted" style="margin-top:8px;font-size:12px">Placed: ${escapeHtml(placed)}</div>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px">
          <button class="btn btn-accept" data-bid-id="${bidId}" data-order-id="${escapeHtml(o.id || o.orderId || '')}">Assign</button>
          <button class="btn btn-warn" data-bid-remove="${bidId}" data-order-id="${escapeHtml(o.id || o.orderId || '')}">Remove</button>
        </div>
      </div>
    `;
      }).join('') + `</div></div>` : `<div style="margin-top:10px" class="small-muted">No bidders yet.</div>`);

      td.innerHTML = baseHtml + biddersHtml;
      detailsTr.appendChild(td);
      
      // üî• FIX: Add details row to fragment
      fragment.appendChild(detailsTr);

      // resolve assigned info async (existing behavior)
      if (o.assignedTo || o.assignedDeliveryId) {
        (async () => {
          try {
            const uid = o.assignedTo || o.assignedDeliveryId;
            const assignedPlaceholderId = `assigned-info-${sanitizeDomId(o.id || o.orderId)}`;
            const el = document.getElementById(assignedPlaceholderId);
            if (!el) return;
            const profile = await getSellerInfo(uid);
            if (profile) {
              el.innerHTML = `
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
              <img src="${profile.profilePictureUrl || '../../images/no profile pic.jpg'}" style="width:36px;height:36px;border-radius:6px;object-fit:cover;margin-right:8px">
              <div>
                <strong>${escapeHtml(profile.name || uid)}</strong>
                <div class="small-muted">${escapeHtml(uid)}</div>
              </div>
            </div>
            <div class="small-muted">üìû ${escapeHtml(profile.phone || '')}</div>
            <div class="small-muted">‚úâÔ∏è ${escapeHtml(profile.email || '')}</div>
            ${profile.index ? `<div class="small-muted">Index: ${escapeHtml(profile.index)}</div>` : ''}
            ${profile.program ? `<div class="small-muted">Program: ${escapeHtml(profile.program)}</div>` : ''}
            ${profile.room ? `<div class="small-muted">Room: ${escapeHtml(profile.room)}</div>` : ''}
          `;
            } else {
              el.textContent = `Assigned courier: ${escapeHtml(uid)}`;
            }
          } catch (e) { }
        })();
      }
    }

    // üî• FIX: APPEND ENTIRE FRAGMENT AT ONCE (not row by row)
    ordersTbody.appendChild(fragment);

    // === EVENT DELEGATION - MAKES ASSIGN/REMOVE BUTTONS WORK ===
    try {
      if (ordersTbody && !ordersTbody._delegationAttached) {
        ordersTbody.addEventListener('click', (e) => {
          const assignBtn = e.target.closest('[data-bid-id]');
          if (assignBtn) {
            e.stopPropagation();
            const bidId = assignBtn.getAttribute('data-bid-id');
            const orderId = assignBtn.getAttribute('data-order-id');
            if (!confirm('Assign this bidder to the order?')) return;
            (async () => {
              let friendly = bidId;
              try {
                const profile = await getSellerInfo(bidId);
                if (profile && profile.name) friendly = profile.name;
              } catch (e) { }
              assignCourier(orderId, bidId, friendly);
              if (biddersModal) biddersModal.style.display = 'none';
            })();
            return;
          }

          const removeBtn = e.target.closest('[data-bid-remove]');
          if (removeBtn) {
            e.stopPropagation();
            const rid = removeBtn.getAttribute('data-bid-remove');
            const orderId = removeBtn.getAttribute('data-order-id');
            if (!confirm('Remove this bidder?')) return;
            removeBid(orderId, rid);
            return;
          }
        });
        ordersTbody._delegationAttached = true;
      }
    } catch (err) { console.warn('delegation attach failed', err); }
    // === END EVENT DELEGATION ===

    // update badge (count active orders) ‚Äî use reconciled sellerOrders
    const activeCount = (sellerOrders || []).filter(o => ['Pending', 'Accepted', 'Processing', 'Delivering', 'At Door', 'Assigned'].includes(o.status)).length;
    updateOrdersBadge(activeCount);

    if (notifyNew) showToast('New order received', 'success');

    renderAnalytics();
    lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
    
    console.log('‚úÖ renderOrders completed successfully');
  } catch (err) {
    console.error('‚ùå renderOrders failed:', err);
  }
}

    function reconcileSellerOrders() {
      try {
        const key = ordersKey(); // existing helper in your seller page
        const compKey = (typeof completedOrdersKey === 'function') ? completedOrdersKey() : (`completedOrders__seller__${sessionStorage.getItem('uid')}`);
        let sellerOrders = JSON.parse(localStorage.getItem(key) || '[]') || [];
        let completed = JSON.parse(localStorage.getItem(compKey) || '[]') || [];

        // split
        const remaining = [];
        sellerOrders.forEach(o => {
          if (isFinalStatus(o.status)) {
            // if we already have a copy in completed (avoid dupes by id), skip adding
            const exists = completed.find(c => String(c.id) === String(o.id) || String(c.orderId) === String(o.orderId));
            if (!exists) {
              completed.unshift(o);
            }
          } else {
            remaining.push(o);
          }
        });

        // if something changed, persist back
        // We only write if lengths differ to avoid noise
        const changed = remaining.length !== sellerOrders.length || completed.length > (JSON.parse(localStorage.getItem(compKey) || '[]') || []).length;
        if (changed) {
          localStorage.setItem(key, JSON.stringify(remaining));
          localStorage.setItem(compKey, JSON.stringify(completed));
          // update any quick caches
          if (typeof updateOrdersBadge === 'function') {
            updateOrdersBadge(remaining.filter(o => !isFinalStatus(o.status)).length);
          }
        }
        return { active: remaining, completed };
      } catch (err) {
        console.warn('reconcileSellerOrders failed', err);
        return { active: JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [], completed: JSON.parse(localStorage.getItem((typeof completedOrdersKey === 'function' ? completedOrdersKey() : `completedOrders__seller__${sessionStorage.getItem('uid')}`)) || '[]') || [] };
      }
    }


    function statusClass(status) {
      const s = (status || '').toLowerCase();
      if (s === 'pending') return 's-pending';
      if (s === 'accepted') return 's-accepted';
      if (s === 'processing') return 's-processing';
      if (s === 'ready for pickup') return 's-atdoor';           // üÜï ADD THIS LINE
      if (s === 'picked up') return 's-delivered';               // üÜï ADD THIS LINE
      if (s === 'delivering') return 's-delivering';
      if (s === 'at door') return 's-atdoor';
      if (s === 'delivered') return 's-delivered';
      if (s === 'rejected') return 's-rejected';
      if (s === 'out of stock') return 's-rejected';
      return 's-pending';
    }

    function updateOrdersBadge(count) {
      if (!ordersBadge) return;
      if (count > 0) {
        ordersBadge.style.display = 'inline-flex';
        ordersCountEl.textContent = String(count);
        ordersDot.classList.add('pulse');
      } else {
        hideOrdersBadge();
      }
    }
    function hideOrdersBadge() {
      if (!ordersBadge) return;
      ordersBadge.style.display = 'none';
      ordersCountEl.textContent = '0';
      ordersDot.classList.remove('pulse');
    }

    /* ---------- Category selects population (predefined only) ---------- */
    function populateCategorySelects() {
      // product modal select
      if (pCategory) {
        const cur = pCategory.value || '';
        pCategory.innerHTML = `<option value="">Uncategorized</option>`;
        PREDEFINED_CATEGORIES.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          pCategory.appendChild(opt);
        });
        if (cur) pCategory.value = cur;
      }
      // filter select
      if (productCategoryFilter) {
        const curf = productCategoryFilter.value || '';
        productCategoryFilter.innerHTML = `<option value="">All categories</option>`;
        PREDEFINED_CATEGORIES.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          productCategoryFilter.appendChild(opt);
        });
        if (curf) productCategoryFilter.value = curf;
      }
    }

    /* ---------- Update product status when stock reaches zero ---------- */
    function updateProductStatusWhenZero() {
      let updated = false;
      products.forEach(p => {
        const newStatus = (Number(p.quantity) || 0) <= 0 ? 'Out of Stock' : 'Active';
        if (p.status !== newStatus) {
          p.status = newStatus;
          updated = true;
        }
      });

      if (updated) {
        localStorage.setItem(productsKey(), JSON.stringify(products));
        localStorage._lastProductsJson = localStorage.getItem(productsKey()) || '[]';
        renderProducts();
        showToast('Product statuses updated based on stock levels', 'success');
      }
    }

    /* ---------- Reduce Product Stock When Order Processing ---------- */
    /* ---------- Reduce Product Stock When Order Processing ---------- */
    function reduceProductStock(order) {
      try {
        console.log('üîÑ reduceProductStock called for order:', order.id);
        console.log('üì¶ Order items:', order.items);

        // Get products from SELLER'S namespaced storage (not global 'products')
        const sellerProductsKey = productsKey();
        let allProducts = JSON.parse(localStorage.getItem(sellerProductsKey) || '[]');
        console.log('üìä Seller products key:', sellerProductsKey);
        console.log('üìä Seller products count:', allProducts.length);
        console.log('üìä All seller products:', allProducts);

        let stockUpdated = false;

        // Reduce quantity for each item in the order
        (order.items || []).forEach(orderItem => {
          const productId = String(orderItem.id);
          const orderedQuantity = Number(orderItem.quantity || 1);

          console.log(`üîç Looking for product: ${productId}, Qty: ${orderedQuantity}`);

          // Find the product - COMPARE AS STRINGS
          const productIndex = allProducts.findIndex(p => String(p.id) === String(productId));

          if (productIndex !== -1) {
            const currentStock = Number(allProducts[productIndex].quantity || 0);
            const newStock = Math.max(0, currentStock - orderedQuantity);

            console.log(`üì¶ Found product: "${allProducts[productIndex].name}"`);
            console.log(`üì¶ Reducing from ${currentStock} to ${newStock}`);

            // ACTUALLY REDUCE THE QUANTITY NUMBER
            allProducts[productIndex].quantity = newStock;

            // Update status immediately
            allProducts[productIndex].status = newStock <= 0 ? 'Out of Stock' : 'Active';
            stockUpdated = true;

            console.log(`‚úÖ Updated: ${allProducts[productIndex].name} = ${newStock}`);
          } else {
            console.log('‚ùå Product not found in seller storage:', productId);

            // Debug: Show all product IDs for comparison
            console.log('üîç Available product IDs:', allProducts.map(p => p.id));
          }
        });

        // Save the reduced quantities back to SELLER'S storage
        if (stockUpdated) {
          localStorage.setItem(sellerProductsKey, JSON.stringify(allProducts));
          console.log('üíæ Saved updated products to seller storage');

          // Also try to update global products if they exist
          try {
            const globalProducts = JSON.parse(localStorage.getItem('products') || '[]');
            if (globalProducts.length > 0) {
              // Update global products too
              (order.items || []).forEach(orderItem => {
                const globalIndex = globalProducts.findIndex(p => String(p.id) === String(orderItem.id));
                if (globalIndex !== -1) {
                  globalProducts[globalIndex].quantity = Math.max(0, globalProducts[globalIndex].quantity - orderItem.quantity);
                  globalProducts[globalIndex].status = globalProducts[globalIndex].quantity <= 0 ? 'Out of Stock' : 'Active';
                }
              });
              localStorage.setItem('products', JSON.stringify(globalProducts));
              console.log('üíæ Also updated global products');
            }
          } catch (e) {
            console.log('‚ö†Ô∏è No global products to update');
          }

          // Refresh the display
          products = allProducts;
          renderProducts();

          console.log('‚úÖ Product stock reduced successfully');
          showToast('Product stock automatically updated', 'success');
        } else {
          console.log('‚ö†Ô∏è No stock was updated - no matching products found in seller storage');
          showToast('No products found to update stock', 'warn');
        }

      } catch (error) {
        console.error('‚ùå Failed to reduce product stock:', error);
        showToast('Error updating product stock', 'error');
      }
    }

    /* ---------- Product CRUD ---------- */
    /* *** IMPORTANT FIXED renderProducts (prevents duplicate DOM rows by batching seller lookups and atomically updating tbody) *** */

    // simple render guard id
    renderProducts._id = renderProducts._id || 0;

    async function renderProducts() {
      // üö® SAFETY CHECK: Fix any existing negative quantities
      products.forEach(p => {
        if (p.quantity < 0) {
          p.quantity = 0;
          p.status = 'Out of Stock';
          console.warn('Fixed negative quantity in product:', p.name);
        }
      });
      if (!prodTbody) return;

      // capture current render id
      const myId = ++renderProducts._id;

      const search = (productSearch?.value || '').toLowerCase();
      const filter = productStatusFilter?.value;
      const catFilter = productCategoryFilter?.value;
      const filtered = (products || []).filter(p => {
        const matchesSearch = (p.name || '').toLowerCase().includes(search);
        const matchesStatus = filter ? p.status === filter : true;
        const matchesCat = catFilter ? (p.category === catFilter) : true;
        return matchesSearch && matchesStatus && matchesCat;
      });

      // if nothing to show, clear and quick-return
      if (!filtered.length) {
        prodTbody.innerHTML = '';
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="8" style="text-align:center;color:var(--muted)">No products</td>`;
        prodTbody.appendChild(tr);
        return;
      }

      // fetch all seller info in parallel (best-effort)
      const sellerPromises = filtered.map(p => {
        if (p && p.sellerId) return getSellerInfo(p.sellerId).catch(() => null);
        return Promise.resolve(null);
      });

      let sellers = [];
      try {
        sellers = await Promise.all(sellerPromises);
      } catch (err) {
        // if something fails, continue with null sellers
        sellers = filtered.map(() => null);
      }

      // if a newer render started while we were awaiting, abort this one
      if (myId !== renderProducts._id) return;

      // build fragment and update DOM atomically (prevents interleaving duplicates)
      const frag = document.createDocumentFragment();

      for (let i = 0; i < filtered.length; i++) {
        const p = filtered[i];
        const sellerData = sellers[i] || null;
        const sellerName = sellerData?.name || "Unknown Seller";
        const sellerAvatar = sellerData?.profilePictureUrl || "../../images/no profile pic.jpg";

        const tr = document.createElement('tr');

        const catName = p.category || 'Uncategorized';

        tr.innerHTML = `
      <td>
        <div style="display:flex;gap:10px;align-items:center">
          <img src="${p.img || 'https://via.placeholder.com/80'}" 
              style="width:54px;height:54px;border-radius:6px;object-fit:cover;border:1px solid #e6eefc">
          <div>
            <div style="font-weight:700">${escapeHtml(p.name)}</div>
            <div class="small-muted">ID: ${escapeHtml(String(p.id || ''))}</div>
            ${p.description
            ? `<div class="small-muted" title="${escapeHtml(p.description)}"
                      style="max-width:200px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
                    ${escapeHtml(p.description)}
                  </div>`
            : ''
          }
            <div class="small-muted" style="margin-top:6px;display:flex;align-items:center;gap:8px">
              <img src="${sellerAvatar}" style="width:20px;height:20px;border-radius:50%;vertical-align:middle;margin-right:5px">
              <span>${escapeHtml(sellerName)}</span>
            </div>
          </div>
        </div>
      </td>
      <td>GHC ${Number(p.price || 0).toFixed(2)}</td>
      <td>${p.quantity || 0}</td>
      <td>${p.condition || ''}</td>
      <td>${escapeHtml(catName)}</td>
      <td><span class="status-badge ${p.status === 'Active' ? 's-delivering' : 's-rejected'}">${escapeHtml(p.status || '')}</span></td>
      <td>${p.createdAt ? fmtDate(p.createdAt) : ''}</td>
      <td class="actions"></td>
    `;

        // actions (use addEventListener to avoid double-binding)
        const actionsTd = tr.querySelector('.actions');
        const editBtn = document.createElement('button'); editBtn.className = 'btn btn-edit'; editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
        editBtn.addEventListener('click', (e) => { e.stopPropagation(); openProductEditor(p); });
        const delBtn = document.createElement('button'); delBtn.className = 'btn btn-delete'; delBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
        // Find the delete button handler in your renderProducts function
// Replace the deletion logic with:

// IN renderProducts() function, find the delete button handler:
delBtn.addEventListener('click', async (e) => {
  e.stopPropagation();
  
  if (!confirm(`Delete product "${p.name}"? This cannot be undone.`)) return;
  
  try {
    // 1. Delete from Firestore
    const productRef = doc(firestore, "products", p.id);
    await deleteDoc(productRef);
    
    // 2. Remove from user's products array in Firestore
    const uid = getUid();
    if (uid) {
      const userDocRef = doc(firestore, "users", uid);
      const userDoc = await getDoc(userDocRef);
      if (userDoc.exists()) {
        const userData = userDoc.data();
        const userProducts = (userData.products || []).filter(prod => prod.id !== p.id);
        await updateDoc(userDocRef, { products: userProducts });
      }
    }
    
    // 3. Remove from localStorage cache
    products = products.filter(x => x.id !== p.id);
    localStorage.setItem(productsKey(), JSON.stringify(products));
    
    // 4. Refresh UI
    renderProducts();
    showToast('‚úÖ Product deleted', 'success');
    
    // Notify market page
    window.dispatchEvent(new CustomEvent('productsUpdated', { 
      detail: { productId: p.id, action: 'deleted' }
    }));
    
  } catch (error) {
    console.error('Delete failed:', error);
    showToast('‚ùå Failed to delete product', 'error');
  }
});
        actionsTd.appendChild(editBtn); actionsTd.appendChild(delBtn);

        frag.appendChild(tr);
      }

      // final check - if a new render started meanwhile, abort applying this fragment
      if (myId !== renderProducts._id) return;

      // replace tbody content atomically
      prodTbody.innerHTML = '';
      prodTbody.appendChild(frag);
    }

    function openProductEditor(p = null) {
      productModal.style.display = 'flex';
      populateCategorySelects();

      if (p) {
        productModalTitle.textContent = 'Edit product';
        pName.value = p.name; pPrice.value = p.price; pQuantity.value = p.quantity;
        pCondition.value = p.condition; pStatus.value = p.status; pPreview.src = p.img || ''; pPreview.style.display = p.img ? 'block' : 'none';
        pCategory.value = p.category || ''; pDescription.value = p.description || '';
        productModal.dataset.editId = p.id;
      } else {
        productModalTitle.textContent = 'Add product';
        delete productModal.dataset.editId;
        pName.value = ''; pPrice.value = ''; pQuantity.value = ''; pCondition.value = 'New'; pStatus.value = 'Active'; pPreview.style.display = 'none'; pImage.value = ''; pCategory.value = ''; pDescription.value = '';
      }
    }
    openAdd && openAdd.addEventListener('click', () => openProductEditor());
    pCancel && pCancel.addEventListener('click', () => productModal.style.display = 'none');
    // LONG-TERM SOLUTION: Smart auto-compression
    // üñºÔ∏è FIXED IMAGE UPLOAD HANDLER
    // ====== IMAGE VALIDATION & COMPRESSION ======
    // Add this function to validate images before accepting them
    function validateImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        // Set timeout to handle unresponsive images
        const timeout = setTimeout(() => {
          URL.revokeObjectURL(url);
          reject(new Error('Image took too long to load - may be corrupted'));
        }, 10000); // 10 second timeout

        img.onload = () => {
          clearTimeout(timeout);
          URL.revokeObjectURL(url);
          // Check if image loaded properly and has reasonable dimensions
          if (img.width > 10 && img.height > 10 && img.width < 10000 && img.height < 10000) {
            resolve({
              valid: true,
              width: img.width,
              height: img.height
            });
          } else {
            reject(new Error(`Image appears corrupted or has invalid dimensions (${img.width}x${img.height}px)`));
          }
        };

        img.onerror = () => {
          clearTimeout(timeout);
          URL.revokeObjectURL(url);
          reject(new Error('Failed to load image - file may be corrupted or unsupported'));
        };

        img.src = url;
      });
    }

    // üñºÔ∏è ENHANCED IMAGE UPLOAD HANDLER WITH VALIDATION
    // ‚úÖ REPLACE THE ENTIRE UPLOAD HANDLER WITH THIS:
    // ‚úÖ UPDATED: Cloudinary Upload Handler (keeps same UI)
// ‚úÖ SIMPLE CLOUDINARY UPLOAD - REPLACE YOUR OLD CODE WITH THIS
// ‚úÖ UPDATED: Cloudinary Upload Handler (keeps same UI)
pImage && pImage.addEventListener('change', async e => {
  const file = e.target.files[0];
  
  if (!file) {
    pPreview.style.display = 'none';
    return;
  }
  
  // üéØ STRICTER FILE SIZE CHECK
  const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
  if (file.size > MAX_FILE_SIZE) {
    showToast('‚ùå Image too large! Please select an image under 5MB.', 'error');
    pImage.value = '';
    return;
  }
  
  // üéØ VALIDATE FILE TYPE
  const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
  if (!validTypes.includes(file.type)) {
    showToast('‚ùå Please select JPEG, PNG, or WebP images only', 'error');
    pImage.value = '';
    return;
  }
  
  // üéØ SHOW LOADING STATE
  pPreview.style.display = 'block';
  pPreview.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0BveD0iMCAwIDEyMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjYwIiBjeT0iNjAiIHI9IjIwIiBzdHJva2U9IiMyNTYzZWIiIHN0cm9rZS13aWR0aD0iNCI+CiAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJyb3RhdGUiIGZyb209IjAgNjAgNjAiIHRvPSIzNjAgNjAgNjAiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIi8+CjwvY2lyY2xlPgo8L3N2Zz4=';
  
  showToast('üîÑ Uploading image...', 'info');
  
  
  try {
    // üéØ UPLOAD TO CLOUDINARY
    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', 'marketplace_products'); // Create this preset in Cloudinary
    formData.append('cloud_name', 'dsj9imkpp');
    
    const response = await fetch(CLOUDINARY_UPLOAD_URL, {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error(`Upload failed: ${response.status}`);
    }
    
    const result = await response.json();
    
    // ‚úÖ SUCCESS: Update preview with Cloudinary URL
    pPreview.src = result.secure_url;
    
    const sizeMB = (file.size / 1024 / 1024).toFixed(2);
    showToast(`‚úÖ Image uploaded to Cloudinary (${sizeMB} MB)`, 'success');
    
    // Store the Cloudinary URL in a hidden field or data attribute
    if (pImage) {
      pImage.dataset.cloudinaryUrl = result.secure_url;
      pImage.dataset.cloudinaryId = result.public_id;
    }
    
    console.log('Cloudinary upload success:', {
      url: result.secure_url,
      id: result.public_id,
      size: result.bytes,
      dimensions: `${result.width}x${result.height}`
    });
    
  } catch (error) {
    console.error('‚ùå Cloudinary upload failed:', error);
    
    // FALLBACK: Use local compression as before
    showToast('‚ö†Ô∏è Cloud upload failed, using local compression...', 'warn');
    
    // Fallback to your existing compression logic
    const validation = await validateImage(file);
    const quality = getStorageQualityLevel(file.size);
    const compressedBlob = await compressImageSmart(file, quality);
    
    const reader = new FileReader();
    reader.onload = ev => {
      pPreview.src = ev.target.result;
      const savings = ((file.size - compressedBlob.size) / file.size * 100).toFixed(1);
      showToast(`‚ö†Ô∏è Used local compression (saved ${savings}%)`, 'warn');
    };
    reader.readAsDataURL(compressedBlob);
  }
});

    // ‚úÖ FIXED PRODUCT SAVE HANDLER
    // ‚úÖ REPLACE THE ENTIRE pSave CLICK HANDLER WITH THIS:
    // ‚úÖ UPDATED: Product Save Handler with Firestore Sync
// ‚úÖ COMPLETELY UPDATED: Firestore-first Product Save Handler
// ‚úÖ FIXED: Product Save Handler with COMPLETE Firestore Update
pSave && pSave.addEventListener('click', async (e) => {
  e.preventDefault();
  
  // Disable button during save
  const originalText = pSave.innerHTML;
  pSave.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
  pSave.disabled = true;
  
  try {
    // ============================================
    // üéØ VALIDATION
    // ============================================
    const hasImage = pPreview.style.display !== 'none' &&
      pPreview.src &&
      !pPreview.src.includes('svg+xml');

    if (!hasImage) {
      alert("‚ùå Please add a product image before saving!");
      pImage.focus();
      throw new Error('No image');
    }

    const name = pName.value.trim();
    const price = Number(pPrice.value);
    const qty = Number(pQuantity.value);

    if (qty < 0 || !Number.isInteger(qty) || qty > 1000000) {
      showToast('‚ùå Invalid quantity!', 'error');
      pQuantity.focus();
      throw new Error('Invalid quantity');
    }

    if (price < 0 || !name || !price || isNaN(qty)) {
      showToast('‚ùå Please enter valid name and price!', 'error');
      throw new Error('Invalid input');
    }

    // Get image URL
    let img = pPreview.src || '';
    // If we have a Cloudinary URL stored, use it
    if (pImage && pImage.dataset.cloudinaryUrl) {
      img = pImage.dataset.cloudinaryUrl;
      console.log('Using Cloudinary URL:', img);
    }
    
    const category = pCategory.value || '';
    const description = pDescription.value.trim();
    const condition = pCondition.value;
    const status = qty <= 0 ? 'Out of Stock' : pStatus.value;
    
    const uid = auth.currentUser?.uid;
    if (!uid) {
      showToast('‚ùå You must be logged in to save products', 'error');
      throw new Error('No user');
    }

    // ============================================
    // üéØ GET SELLER INFO FOR PRODUCT DATA
    // ============================================
    let sellerInfo = null;
    try {
      const userRef = ref(database, `users/${uid}`);
      const snapshot = await get(userRef);
      if (snapshot.exists()) {
        sellerInfo = snapshot.val();
      }
    } catch (err) {
      console.warn('Could not fetch seller info:', err);
    }

    let productId;
    let isNewProduct = false;
    let productData;

    if (productModal.dataset.editId) {
      // ‚úÖ EDITING EXISTING PRODUCT
      productId = String(productModal.dataset.editId);
      isNewProduct = false;
      
      // Get existing product to preserve important fields
      let existingProduct = null;
      try {
        const productRef = doc(firestore, "products", productId);
        const productDoc = await getDoc(productRef);
        if (productDoc.exists()) {
          existingProduct = productDoc.data();
        }
      } catch (err) {
        console.warn('Could not fetch existing product:', err);
      }
      
      // ‚úÖ COMPLETE PRODUCT DATA FOR UPDATE
      // ‚úÖ COMPLETE PRODUCT DATA FOR UPDATE
productData = {
  // Keep existing important fields
  id: productId,
  sellerId: existingProduct?.sellerId || uid,
  sellerUid: existingProduct?.sellerUid || uid,
  seller: existingProduct?.seller || sellerInfo?.name || 'Seller',
  sellerAvatar: existingProduct?.sellerAvatar || sellerInfo?.profilePictureUrl || DEFAULT_AVATAR,
  approved: existingProduct?.approved !== false,
  createdAt: existingProduct?.createdAt || nowISO(),
  
  // Updated fields
  name: name,
  title: name,
  price: price,
  quantity: qty,
  condition: condition,
  status: status,
  img: img,
  images: [img],
  category: category,
  description: description,
  updatedAt: nowISO(),
  
  // Preserve other fields if they exist - FIXED
location: existingProduct?.location || sellerInfo?.location || '',
// Don't include oldPrice if it doesn't exist - it will be undefined and removed by cleanFirestoreData
oldPrice: existingProduct?.oldPrice,
views: existingProduct?.views || 0,
wishlistCount: existingProduct?.wishlistCount || 0,
// Include purchaseCount if it exists
...(existingProduct?.purchaseCount !== undefined && { purchaseCount: existingProduct.purchaseCount })
};

     console.log('üîÑ Updating product in Firestore:', productId, productData);

// üî• Clean data to remove undefined values
const cleanedProductData = cleanFirestoreData(productData);

// 1. UPDATE FIRESTORE (Source of Truth)
const productRef = doc(firestore, "products", productId);
await setDoc(productRef, cleanedProductData, { merge: true });

console.log('‚úÖ Firestore update completed');

// 2. UPDATE USER'S PRODUCTS ARRAY IN FIRESTORE
try {
  const userDocRef = doc(firestore, "users", uid);
  const userDoc = await getDoc(userDocRef);
  
  if (userDoc.exists()) {
    const userData = userDoc.data();
    const userProducts = userData.products || [];
    
    // Find and update the product in user's array
    const productIndex = userProducts.findIndex(p => String(p.id) === String(productId));
    
    if (productIndex !== -1) {
      userProducts[productIndex] = cleanedProductData;
    } else {
      // If product not found in user's array, add it
      userProducts.push(cleanedProductData);
    }
    
    await updateDoc(userDocRef, { 
      products: userProducts,
      updatedAt: nowISO()
    });
    
    console.log('‚úÖ Updated product in user\'s products array');
  }
} catch (error) {
  console.error('‚ùå Failed to update user products array:', error);
  // Don't fail the whole operation - product is already saved in main collection
}

// 3. Update localStorage cache
const sellerProductsKey = productsKey();
let sellerProducts = JSON.parse(localStorage.getItem(sellerProductsKey) || '[]');
const idx = sellerProducts.findIndex(x => String(x.id) === productId);
if (idx > -1) {
  sellerProducts[idx] = { ...sellerProducts[idx], ...cleanedProductData };
  localStorage.setItem(sellerProductsKey, JSON.stringify(sellerProducts));
}

showToast('‚úÖ Product updated successfully!', 'success');
      
    } else {
      // ‚úÖ ADDING NEW PRODUCT
      productId = `prod_${Date.now()}_${Math.random().toString(36).slice(2)}`;
      isNewProduct = true;
      
      // ‚úÖ COMPLETE PRODUCT DATA FOR NEW PRODUCT
     // ‚úÖ COMPLETE PRODUCT DATA FOR NEW PRODUCT
productData = {
  id: productId,
  name: name,
  title: name,
  price: price,
  quantity: qty,
  condition: condition,
  status: status,
  img: img,
  images: [img],
  category: category,
  description: description,
  sellerId: uid,
  sellerUid: uid,
  seller: sellerInfo?.name || 'Seller',
  sellerAvatar: sellerInfo?.profilePictureUrl || DEFAULT_AVATAR,
  approved: true,
  createdAt: nowISO(),
  updatedAt: nowISO(),
  location: sellerInfo?.location || '',
  // Initialize popularity fields - DON'T include oldPrice for new products
  views: 0,
  wishlistCount: 0,
  purchaseCount: 0
  // oldPrice is NOT included for new products
};
     console.log('üÜï Adding new product to Firestore:', productId, productData);

// üî• Clean data to remove undefined values
const cleanedProductData = cleanFirestoreData(productData);

// 1. SAVE TO FIRESTORE (Source of Truth)
const productRef = doc(firestore, "products", productId);
await setDoc(productRef, cleanedProductData);

console.log('‚úÖ Firestore save completed');

// 2. Update localStorage cache
const sellerProductsKey = productsKey();
let sellerProducts = JSON.parse(localStorage.getItem(sellerProductsKey) || '[]');
sellerProducts.push(cleanedProductData);
localStorage.setItem(sellerProductsKey, JSON.stringify(sellerProducts));

// 3. Also update user's products array in Firestore (for quick access)
const userDocRef = doc(firestore, "users", uid);
const userDoc = await getDoc(userDocRef);
if (userDoc.exists()) {
  const userData = userDoc.data();
  const userProducts = userData.products || [];
  const existingIndex = userProducts.findIndex(p => p.id === productId);
  
  if (existingIndex >= 0) {
    userProducts[existingIndex] = cleanedProductData;
  } else {
    userProducts.push(cleanedProductData);
  }
  
  await updateDoc(userDocRef, { products: userProducts });
}

showToast('‚úÖ Product added successfully!', 'success');
    }

    // ============================================
    // üéØ UPDATE UI & CLOSE MODAL
    // ============================================
    productModal.style.display = 'none';
    
    // Reset form for next use
    pName.value = '';
    pPrice.value = '';
    pQuantity.value = '';
    pDescription.value = '';
    pPreview.src = '#';
    pPreview.style.display = 'none';
    if (pImage) {
      pImage.value = '';
      delete pImage.dataset.cloudinaryUrl;
      delete pImage.dataset.cloudinaryId;
    }
    
    // Refresh local display
    await refreshProductsFromFirestore();
    renderProducts();
    renderAnalytics();
    
    // Dispatch event to notify market page (if open)
    window.dispatchEvent(new CustomEvent('productsUpdated', { 
      detail: { productId, action: isNewProduct ? 'added' : 'updated' }
    }));

    console.log('üéâ Product save completed successfully:', {
      productId,
      action: isNewProduct ? 'added' : 'updated',
      name: name,
      price: price
    });

  } catch (error) {
    console.error('‚ùå Product save failed:', error);
    showToast(`‚ùå Failed to save product: ${error.message}`, 'error');
  } finally {
    // Restore button state
    pSave.innerHTML = originalText;
    pSave.disabled = false;
  }
});

// ‚úÖ Helper function for Cloudinary upload with retry
async function uploadToCloudinaryWithRetry(file, maxRetries = 2) {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      showToast(`üîÑ Uploading image (attempt ${attempt}/${maxRetries})...`, 'info');
      
      const formData = new FormData();
      formData.append('file', file);
      formData.append('upload_preset', 'marketplace_products');
      formData.append('cloud_name', 'dsj9imkpp');
      
      const response = await fetch(CLOUDINARY_UPLOAD_URL, {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const result = await response.json();
      showToast('‚úÖ Image uploaded successfully!', 'success');
      return result;
      
    } catch (error) {
      console.error(`Upload attempt ${attempt} failed:`, error);
      lastError = error;
      
      if (attempt < maxRetries) {
        // Wait before retry (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
      }
    }
  }
  
  throw lastError || new Error('All upload attempts failed');
}

// ‚úÖ NEW: Function to refresh products from Firestore
// ‚úÖ FIXED: Function to refresh products from Firestore
async function refreshProductsFromFirestore() {
  try {
    const uid = getUid();
    if (!uid) return;
    
    console.log('üîÑ Refreshing products from Firestore...');
    
    // 1. Get ALL products from Firestore (not just user's)
    const productsCollection = collection(firestore, "products");
    const querySnapshot = await getDocs(productsCollection);
    
    const allProducts = [];
    querySnapshot.forEach((docSnap) => {
      const data = docSnap.data();
      const id = docSnap.id;
      
      // Only include approved products (or all if approved field doesn't exist)
      if (data.approved !== false) {
        allProducts.push({
          id: id,
          ...data
        });
      }
    });
    
    console.log('üì¶ Fetched all products from Firestore:', allProducts.length);
    
    // 2. Filter to only this seller's products
    const sellerProducts = allProducts.filter(p => 
      String(p.sellerId) === String(uid) || 
      String(p.sellerUid) === String(uid)
    );
    
    console.log('üë§ Filtered to seller products:', sellerProducts.length);
    
    // 3. Update localStorage cache
    const sellerProductsKey = productsKey();
    localStorage.setItem(sellerProductsKey, JSON.stringify(sellerProducts));
    
    // 4. Update global state
    products = sellerProducts;
    
    console.log('‚úÖ Products refreshed successfully');

  } catch (error) {
    console.error('‚ùå Failed to refresh from Firestore:', error);
    // Fallback to localStorage
    const sellerProductsKey = productsKey();
    products = JSON.parse(localStorage.getItem(sellerProductsKey) || '[]');
    console.log('üîÑ Falling back to cached products:', products.length);
  }
}


// ‚úÖ OPTIONAL: Add periodic sync function
function startAutoSync() {
  // Sync every 5 minutes
  setInterval(async () => {
    try {
      await syncSellerProductsToFirestore();
      console.log('‚úÖ Periodic sync completed');
    } catch (error) {
      console.warn('Periodic sync failed:', error);
    }
  }, 5 * 60 * 1000); // 5 minutes
  
  // Also sync when page becomes visible again
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      syncSellerProductsToFirestore().catch(err => {
        console.warn('Visibility change sync failed:', err);
      });
    }
  });
}
// ‚úÖ Auto-sync when page becomes visible
document.addEventListener('visibilitychange', async () => {
  if (!document.hidden) {
    console.log('üîÑ Page visible again, syncing from Firestore...');
    await loadProductsFromFirestore();
    renderProducts();
    renderAnalytics();
  }
});

// ‚úÖ Also sync on page load
window.addEventListener('load', async () => {
  setTimeout(async () => {
    await loadProductsFromFirestore();
    renderProducts();
  }, 1000);
});

// ‚úÖ Initialize auto-sync on page load
if (typeof startAutoSync === 'function') {
  setTimeout(startAutoSync, 10000); // Start after 10 seconds
}

    // Smart quality-based compression
    // ‚úÖ REPLACE WITH THIS STORAGE-FOCUSED FUNCTION:
    function getStorageQualityLevel(fileSize) {
      // üéØ MUCH MORE AGGRESSIVE COMPRESSION FOR STORAGE
      if (fileSize > 3 * 1024 * 1024) return 0.5;    // 50% for very large files
      if (fileSize > 1.5 * 1024 * 1024) return 0.6;  // 60% for large files
      if (fileSize > 0.5 * 1024 * 1024) return 0.7;  // 70% for medium files
      return 0.8; // 80% for small files
    }

    // Advanced compression with size limits
    // ‚úÖ REPLACE WITH THIS OPTIMIZED FUNCTION:
    async function compressImageSmart(file, quality = 0.7) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        img.onload = () => {
          // üéØ MUCH SMALLER DIMENSIONS FOR STORAGE
          let { width, height } = img;

          // Force maximum dimensions for storage
          const MAX_STORAGE_WIDTH = 600;
          const MAX_STORAGE_HEIGHT = 600;

          if (width > MAX_STORAGE_WIDTH || height > MAX_STORAGE_HEIGHT) {
            const ratio = Math.min(MAX_STORAGE_WIDTH / width, MAX_STORAGE_HEIGHT / height);
            width = Math.floor(width * ratio);
            height = Math.floor(height * ratio);
          }

          canvas.width = width;
          canvas.height = height;

          // Good enough quality for storage
          ctx.imageSmoothingQuality = 'medium';
          ctx.drawImage(img, 0, 0, width, height);

          // üéØ LOWER QUALITY FOR STORAGE
          canvas.toBlob((blob) => {
            if (blob) {
              console.log(`üì¶ STORAGE OPTIMIZED: ${formatBytes(file.size)} ‚Üí ${formatBytes(blob.size)} (${quality * 100}% quality, ${width}x${height})`);

              // üö® REJECT IF STILL TOO LARGE
              if (blob.size > 300 * 1024) { // 300KB max
                reject(new Error('Image still too large after compression. Please try a smaller image.'));
                return;
              }

              resolve(blob);
            } else {
              reject(new Error('Compression failed'));
            }
          }, 'image/jpeg', quality); // Lower quality for storage
        };

        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = URL.createObjectURL(file);
      });
    }

    // Helper function to format file sizes
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
    }

    /* ---------- Orders helpers ---------- */
    /* 4-digit delivery code generator (created at order creation if missing) */
    function assignDeliveryCode(order) {
      if (!order.deliveryCode) order.deliveryCode = Math.floor(1000 + Math.random() * 9000).toString(); // 4-digit
      return order;
    }

    function ensureAppearedAt(order) {
      if (!order.appearedAt) order.appearedAt = nowISO();
      return order;
    }

    function orderThumbnail(o) {
  // Try item image first (most reliable)
  if (Array.isArray(o.items) && o.items.length) {
    return o.items[0].image || o.items[0].img || null;
  }
  
  // Then try product lookup (fallback)
  if (o.product && o.productId) {
    const prod = products.find(p => String(p.id) === String(o.productId));
    if (prod?.img) return prod.img;
  }
  
  // Default placeholder
  return 'https://via.placeholder.com/90';
}

    /* ---------- History helper ---------- */
    function pushOrderHistory(order, actorId, actorType, action, note) {
      order.history = order.history || [];
      order.history.push({ actorId: actorId || null, actorType: actorType || 'system', action, note: note || null, timestamp: nowISO() });
    }

    /* ---------- Delivery request / bidding API (seller-side) ---------- */

    /**
     * askForDelivery(orderId, windowSeconds = 300)
     * Starts a timed bid window for couriers to request to deliver.
     */
    /**
     * askForDelivery(orderId, windowSeconds = 300)
     * Posts delivery request to public area where all delivery guys can see and bid
     */
    /**
     * askForDelivery(orderId, windowSeconds = 300)
     * Posts delivery request to public area where all delivery guys can see and bid
     */
    /**
     * Enhanced Ask for Delivery function with better validation and user experience
     */
    /**
 * Enhanced Ask for Delivery function with Firestore sync
 */
/**
 * Enhanced Ask for Delivery function with complete Firestore integration
 */
async function askForDelivery(orderId, windowSeconds = 300) {
  try {
    console.log('üîÑ askForDelivery called for order:', orderId);

    // Load current orders
    const orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
    const orderIndex = orders.findIndex(o =>
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );

    if (orderIndex === -1) {
      showToast('Order not found in your orders', 'error');
      return;
    }

    const order = normalizeOrderFields(orders[orderIndex]);

    // üÜï PREVENT DELIVERY REQUESTS FOR PICKUP ORDERS
    if (order.deliveryType === 'pickup') {
      showToast('Cannot request delivery for pickup orders', 'error');
      return;
    }

    // üî• VALIDATION: Check if order can be delivered
    if (order.status === 'Delivered' || order.status === 'Rejected') {
      showToast(`Cannot request delivery for ${order.status.toLowerCase()} orders`, 'error');
      return;
    }

    // üî• VALIDATION: Check if there's already an active delivery request in Firestore
    try {
      const deliveryRequestsRef = collection(firestore, "deliveryRequests");
      const q = query(deliveryRequestsRef, 
        where("orderId", "==", order.id || order.orderId),
        where("status", "in", ["open", "assigned"])
      );
      const querySnapshot = await getDocs(q);
      
      if (!querySnapshot.empty) {
        const existingRequest = querySnapshot.docs[0].data();
        if (existingRequest.status === 'open') {
          showToast('Delivery request already active for this order', 'warn');
          showBiddersModal(order);
          return;
        } else if (existingRequest.status === 'assigned') {
          showToast('This order already has a courier assigned', 'warn');
          return;
        }
      }
    } catch (error) {
      console.error('Error checking existing delivery requests:', error);
    }

    // üî• VALIDATION: Check if order is assigned to someone
    if (order.assignedTo || order.assignedDeliveryId) {
      showToast('This order is already assigned to a courier', 'warn');
      return;
    }

    // üî• VALIDATION: Check if seller is self-delivering
    if (order.ownerIsDelivering) {
      const proceed = confirm('You marked this for self-delivery. Do you want to cancel self-delivery and post to public bidding?');
      if (!proceed) return;
      order.ownerIsDelivering = false;
    }

    // Extract customer information
    const buyerObj = (order.buyer && typeof order.buyer === 'object') ? order.buyer : null;
    const customerInfo = {
      name: buyerObj?.name || order.buyerName || order.buyer || 'Unknown Customer',
      phone: buyerObj?.phone || order.phone || '',
      email: buyerObj?.email || order.email || '',
      room: buyerObj?.room || buyerObj?.roomNumber || order.room || '',
      index: buyerObj?.index || order.index || '',
      program: buyerObj?.program || '',
      profilePictureUrl: buyerObj?.profilePictureUrl || ''
    };

    // Validate essential customer info
    if (!customerInfo.name || customerInfo.name === 'Unknown Customer') {
      showToast('Customer information is incomplete', 'error');
      return;
    }

    // Create enhanced delivery request object
    const deliveryRequest = {
      id: `dr_${Date.now()}_${Math.random().toString(36).slice(2)}`,
      orderId: order.id || order.orderId,
      sellerId: auth.currentUser?.uid || (sessionStorage.getItem('uid') || null),
      sellerName: '', // Will be fetched async
      items: order.items || [{
        name: order.product || 'Unknown Product',
        quantity: order.quantity || 1,
        price: order.price || 0
      }],
      customer: customerInfo,
      deliveryLocation: order.location || order.address || 'Marketplace Location',
      deliveryFee: order.delivery || order.deliveryFee || 0,
      totalOrderValue: order.total || 0,
      status: 'open',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      expiresAt: new Date(Date.now() + (windowSeconds * 1000)).toISOString(),
      bids: [],
      requestActive: true,
      // Additional metadata for better filtering
      urgency: 'standard',
      estimatedPreparationTime: 15,
      specialInstructions: order.instructions || ''
    };

    // Show loading state
    const originalButton = document.querySelector(`[data-order-id="${orderId}"] .btn-edit`);
    if (originalButton) {
      originalButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Posting...';
      originalButton.disabled = true;
    }

    // ‚úÖ CRITICAL: Save to Firestore FIRST
    try {
      const docRef = doc(firestore, "deliveryRequests", deliveryRequest.id);
      await setDoc(docRef, {
        ...deliveryRequest,
        createdAt: new Date(),
        updatedAt: new Date(),
        expiresAt: new Date(Date.now() + (windowSeconds * 1000))
      });
      
      console.log('‚úÖ Delivery request saved to Firestore:', deliveryRequest.id);
      
      // Async fetch seller info for better display
      try {
        const sellerInfo = await getSellerInfo(auth.currentUser?.uid);
        if (sellerInfo && sellerInfo.name) {
          deliveryRequest.sellerName = sellerInfo.name;
          deliveryRequest.sellerRating = sellerInfo.rating || 4.5;

          // Update the delivery request in Firestore with seller info
          await updateDoc(docRef, {
            sellerName: sellerInfo.name,
            sellerRating: sellerInfo.rating || 4.5,
            updatedAt: new Date().toISOString()
          });
        }
      } catch (e) {
        console.warn('Could not fetch seller info:', e);
      }
      
    } catch (error) {
      console.error('‚ùå Failed to save delivery request to Firestore:', error);
      showToast('Failed to post delivery request to cloud', 'error');
      
      // Restore button state
      if (originalButton) {
        originalButton.innerHTML = 'Ask for Delivery';
        originalButton.disabled = false;
      }
      return;
    }

    // Update the original order
    order.requestActive = true;
    order.deliveryRequestId = deliveryRequest.id;
    order.deliveryRequestPostedAt = new Date().toISOString();
    order.ownerIsDelivering = false;

    pushOrderHistory(
      order,
      auth.currentUser?.uid || null,
      'seller',
      'asked_for_delivery',
      `Delivery request posted to public bidding area. Request ID: ${deliveryRequest.id}`
    );

    // Save updated order
    orders[orderIndex] = order;
    localStorage.setItem(ordersKey(), JSON.stringify(orders));

    // Also save to Firestore users collection for backup
    try {
      const uid = auth.currentUser?.uid;
      if (uid) {
        const userDocRef = doc(firestore, "users", uid);
        await updateDoc(userDocRef, {
          updatedAt: new Date().toISOString(),
          lastDeliveryRequest: deliveryRequest.id,
          [`deliveryRequests.${deliveryRequest.id}`]: {
            orderId: deliveryRequest.orderId,
            postedAt: new Date().toISOString(),
            status: 'open'
          }
        });
      }
    } catch (error) {
      console.warn('Failed to update user document:', error);
    }

    // Update local public requests cache
    const publicRequests = await getPublicDeliveryRequests();
    publicRequests.push(deliveryRequest);
    localStorage.setItem(publicDeliveryRequestsKey(), JSON.stringify(publicRequests));

    // Restore button state and show success
    setTimeout(() => {
      renderOrders();
      showToast('üéâ Delivery request posted! Couriers can now bid on your order', 'success');

      // Auto-open the bidders modal after a short delay
      setTimeout(() => {
        showBiddersModal(order);
      }, 1000);
    }, 500);

    console.info('‚úÖ askForDelivery completed:', {
      orderId: order.id,
      requestId: deliveryRequest.id,
      customer: customerInfo.name,
      deliveryFee: deliveryRequest.deliveryFee
    });

  } catch (error) {
    console.error('‚ùå askForDelivery failed:', error);
    showToast('Failed to post delivery request. Please try again.', 'error');

    // Restore button state on error
    renderOrders();
  }
}

    /**
     * cancelDeliveryRequest(orderId)
     * Seller cancels request and opts to self-deliver. This makes the order private (seller will deliver).
     */
    /**
     * cancelDeliveryRequest(orderId)
     * Seller cancels the active delivery request ‚Äî returns the order to the "no request" state
     * so the UI will show the "Ask for Delivery" button again.
     */
    /**
     * cancelDeliveryRequest(orderId)
     * Seller cancels the active delivery request ‚Äî clears any bidders so the request is fully reset.
     */
    /**
     * Enhanced Cancel Delivery Request function
     */
    async function cancelDeliveryRequest(orderId) {
      try {
        console.log('üîÑ cancelDeliveryRequest called for order:', orderId);

        if (!confirm('Are you sure you want to cancel this delivery request? This will remove it from the public bidding area and notify any bidders.')) {
          return;
        }

        orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
        const orderIndex = orders.findIndex(o =>
          String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
        );

        if (orderIndex === -1) {
          showToast('Order not found', 'error');
          return;
        }

        const order = normalizeOrderFields(orders[orderIndex]);

        // Remove from public delivery requests
        const publicRequests = await getPublicDeliveryRequests();
        const deliveryRequest = publicRequests.find(req =>
          req.id === order.deliveryRequestId || req.orderId === orderId
        );

        // ‚úÖ NEW - Delete from Firestore
        try {
          if (order.deliveryRequestId) {
            const docRef = doc(firestore, "deliveryRequests", order.deliveryRequestId);
            await deleteDoc(docRef);
            console.log('‚úÖ Deleted delivery request from Firestore');
          }
        } catch (error) {
          console.error('‚ùå Failed to delete delivery request:', error);
        }

        // Notify bidders (in a real app, you'd send push notifications)
        const bidderCount = deliveryRequest ? (deliveryRequest.bids || []).length : 0;

        // Reset order delivery fields
        order.requestActive = false;
        order.deliveryRequestExpiry = null;
        order.ownerIsDelivering = false;
        order.deliveryRequestId = null;
        order.bidders = [];
        order.bids = [];

        pushOrderHistory(
          order,
          auth.currentUser?.uid || null,
          'seller',
          'cancelled_delivery_request',
          `Removed from public bidding area. ${bidderCount} bidder(s) were notified.`
        );

        // Save updated order
        orders[orderIndex] = order;
        localStorage.setItem(ordersKey(), JSON.stringify(orders));
        localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';

        // Force refresh and show confirmation
        window.dispatchEvent(new Event('publicDeliveryRequestsUpdated'));
        renderOrders();

        if (bidderCount > 0) {
          showToast(`Delivery request cancelled. ${bidderCount} bidder(s) were removed.`, 'success');
        } else {
          showToast('Delivery request cancelled successfully', 'success');
        }

        console.info('‚úÖ cancelDeliveryRequest completed:', {
          orderId: order.id,
          bidderCount: bidderCount
        });

      } catch (error) {
        console.error('‚ùå cancelDeliveryRequest failed:', error);
        showToast('Failed to cancel delivery request', 'error');
      }
    }

    // Listen for public delivery request updates
    window.addEventListener('publicDeliveryRequestsUpdated', () => {
      if (typeof refreshOrdersFromLocal === 'function') {
        refreshOrdersFromLocal();
      }
      if (typeof renderOrders === 'function') {
        renderOrders();
      }
    });

    /**
     * addBid(orderId, courierObj)
     * courierObj: { id, name, profilePictureUrl? }
     */

    function addBid(orderId, courierObj) {
      orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
      const idx = orders.findIndex(o => String(o.id) === String(orderId) || String(o.orderId) === String(orderId));
      if (idx === -1) return false;
      const order = normalizeOrderFields(orders[idx]);

      // only allow bids when seller has an open request and there is no assignment / seller-self-delivering
      if (!order.requestActive || order.assignedTo || order.ownerIsDelivering) {
        return false;
      }

      order.bidders = order.bidders || [];
      if (!order.bidders.find(b => String(b.id) === String(courierObj.id))) {
        order.bidders.push({
          id: courierObj.id,
          name: courierObj.name || 'Courier',
          profilePictureUrl: courierObj.profilePictureUrl || '',
          requestedAt: nowISO()
        });
        pushOrderHistory(order, courierObj.id, 'courier', 'bid', `Courier ${courierObj.name || courierObj.id} requested to deliver`);
        orders[idx] = order;
        localStorage.setItem(ordersKey(), JSON.stringify(orders));
        localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
        // notify UI
        renderOrders();
        return true;
      }
      return false;
    }

    (() => {
      const orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
      if (!Array.isArray(orders)) return console.log('no orders array found');
      let changed = false;
      orders.forEach(o => {
        if (o && Object.prototype.hasOwnProperty.call(o, 'deliveryRequestExpiry')) {
          delete o.deliveryRequestExpiry;
          changed = true;
        }
      });
      if (changed) {
        localStorage.setItem(ordersKey(), JSON.stringify(orders));
        localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
        window.dispatchEvent(new Event('localOrdersUpdated'));
        console.log('Removed deliveryRequestExpiry from stored orders');
      } else {
        console.log('No deliveryRequestExpiry fields found');
      }
    })();

    /**
     * removeBid(orderId, courierId)
     */
    function removeBid(orderId, courierId) {
      orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
      const idx = orders.findIndex(o => String(o.id) === String(orderId) || String(o.orderId) === String(orderId));
      if (idx === -1) return false;
      const order = normalizeOrderFields(orders[idx]);
      const prevLen = order.bidders.length || 0;
      order.bidders = (order.bidders || []).filter(b => String(b.id) !== String(courierId));
      if ((order.bidders || []).length !== prevLen) {
        pushOrderHistory(order, courierId, 'courier', 'cancel_bid', 'Courier cancelled bid');
        orders[idx] = order;
        localStorage.setItem(ordersKey(), JSON.stringify(orders));
        localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
        renderOrders();
        return true;
      }
      return false;
    }

    // safe number helper (if not already in file)
    function _safeNum(v) { const n = Number(v); return Number.isFinite(n) ? n : 0; }

    /**
     * assignCourier(orderId, courierId, courierName)
     * Seller action ‚Äî assigns courier AND locks bid/earnings + computes seller profit.
     * Paste this to replace the existing assignCourier function in testsell.html
     */
    /**
     * assignCourier - Enhanced to immediately lock assignment and sync globally
     */
    async function assignCourier(orderId, courierId, courierName) {
      console.log('üîÑ assignCourier called:', { orderId, courierId, courierName });

      // üî• CRITICAL FIX: Get public delivery requests FIRST before anything else
      const publicRequests = await getPublicDeliveryRequests();
      console.log('üîç Public requests BEFORE assignment:', publicRequests);

      // Find the delivery request for this order
      const deliveryRequest = publicRequests.find(req =>
        String(req.orderId) === String(orderId) || String(req.id) === String(orderId)
      );

      console.log('üí∞ Delivery request found:', deliveryRequest);

      let chosenBid = null;
      if (deliveryRequest && deliveryRequest.bids) {
        chosenBid = deliveryRequest.bids.find(b => String(b.bidderId) === String(courierId));
        console.log('üéØ Chosen bid data:', chosenBid);
      }

      // load orders, find the right order
      orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
      const idx = orders.findIndex(o => String(o.id) === String(orderId) || String(o.orderId) === String(orderId));
      if (idx === -1) return showToast('Order not found', 'error');

      // normalize object
      const order = normalizeOrderFields(orders[idx]);
      console.log('üì¶ Order before assignment:', order);

      // mark assignment basics
      order.assignedTo = String(courierId);
      order.assignedDeliveryId = String(courierId);
      order.assignedAt = nowISO();
      order.requestActive = false;
      order.deliveryRequestExpiry = null;
      order.ownerIsDelivering = false;
      // üéØ KEEP current status, don't change to "Assigned"
      // Just add delivery info WITHOUT changing status
      // order.status = 'Assigned';  // DELETE THIS
      // order.progressStep = 3;     // DELETE THIS

      // Instead, keep whatever status it already has
      if (!order.status) {
        order.status = 'Processing';  // Default if no status
      }
      // progressStep stays whatever it was
      order.deliveryPerson = courierName || String(courierId);

      // üî• CRITICAL FIX: Store the bid amount and ETA from the delivery request
      if (chosenBid) {
        console.log('üíæ Storing bid data from delivery request:', {
          amount: chosenBid.amount,
          eta: chosenBid.eta
        });

        order.assignedBidAmount = Number(chosenBid.amount || 0);
        order.courierEarnings = Number(chosenBid.amount || 0);
        order.assignedBidderId = String(courierId);

        if (chosenBid.eta) {
          const etaNum = Number(chosenBid.eta);
          if (!Number.isNaN(etaNum) && etaNum > 0) {
            order.assignedBidEta = etaNum;
          } else {
            order.assignedBidEta = chosenBid.eta;
          }
        }

        order.bidAcceptedAt = nowISO();
      } else {
        console.warn('‚ùå No bid found in delivery request for courier:', courierId);
        // Fallback: try to find in order.bids or order.bidders
        if (Array.isArray(order.bids) && order.bids.length) {
          const fallbackBid = order.bids.find(b => String(b.bidderId) === String(courierId));
          if (fallbackBid) {
            console.log('üîÑ Using fallback bid data from order.bids:', fallbackBid);
            order.assignedBidAmount = Number(fallbackBid.amount || 0);
            order.courierEarnings = Number(fallbackBid.amount || 0);
            order.assignedBidderId = String(courierId);
            if (fallbackBid.eta) order.assignedBidEta = fallbackBid.eta;
          }
        } else if (Array.isArray(order.bidders) && order.bidders.length) {
          const fallbackBidder = order.bidders.find(b => String(b.id) === String(courierId));
          if (fallbackBidder) {
            console.log('üîÑ Using fallback bid data from order.bidders:', fallbackBidder);
            order.assignedBidAmount = Number(fallbackBidder.amount || fallbackBidder.bidAmount || 0);
            order.courierEarnings = Number(fallbackBidder.amount || fallbackBidder.bidAmount || 0);
            order.assignedBidderId = String(courierId);
            if (fallbackBidder.eta) order.assignedBidEta = fallbackBidder.eta;
          }
        }
      }

      console.log('‚úÖ Order after storing bid data:', {
        assignedBidAmount: order.assignedBidAmount,
        assignedBidEta: order.assignedBidEta,
        courierEarnings: order.courierEarnings
      });

      // Compute seller leftover/profit
      const deliveryFee = _safeNum(order.deliveryFee || order.delivery || order.fee || 0);
      if (deliveryFee > 0 && order.assignedBidAmount) {
        const profit = deliveryFee - order.assignedBidAmount;
        order.deliveryProfit = Number(Math.max(0, profit).toFixed(2));
        order.sellerEarnings = Number(order.sellerEarnings || 0) + order.deliveryProfit;
      } else {
        order.deliveryProfit = Number(order.deliveryProfit || 0);
      }

      // history entry
      pushOrderHistory(order, auth?.currentUser?.uid || null, 'seller', 'assigned_courier',
        `Assigned courier ${courierName || courierId} ‚Ä¢ Amount: GHC ${order.assignedBidAmount || 0} ‚Ä¢ ETA: ${order.assignedBidEta || 'N/A'} min`
      );

      // üî• CRITICAL FIX: Remove from public delivery requests ONLY AFTER we've extracted the data
      // ‚úÖ NEW - Update Firestore
      try {
        if (deliveryRequest && deliveryRequest.id) {
          const docRef = doc(firestore, "deliveryRequests", deliveryRequest.id);
          await updateDoc(docRef, {
            status: 'assigned',
            assignedTo: courierId,
            assignedAt: new Date(),
            updatedAt: new Date()
          });
          console.log('‚úÖ Marked delivery request as assigned in Firestore');
        }
      } catch (error) {
        console.error('‚ùå Failed to update delivery request:', error);
      }
      console.log('üóëÔ∏è Removed from public requests');

      // Save to delivery guy's local storage
      try {
        const deliveryGuyOrdersKey = `orders__delivery__${courierId}`;
        const deliveryGuyOrders = JSON.parse(localStorage.getItem(deliveryGuyOrdersKey) || '[]') || [];

        const existingIdx = deliveryGuyOrders.findIndex(o =>
          String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
        );

        if (existingIdx === -1) {
          deliveryGuyOrders.push(order);
        } else {
          deliveryGuyOrders[existingIdx] = order;
        }

        localStorage.setItem(deliveryGuyOrdersKey, JSON.stringify(deliveryGuyOrders));
        localStorage.setItem(`orders_ping__delivery__${courierId}`, String(Date.now()));
        console.log('üíæ Saved to delivery guy storage');
      } catch (e) {
        console.warn('Failed to save to delivery guy storage:', e);
      }

      // üî• SYNC TO GLOBAL ORDERS
      const globalOrders = getGlobalOrders();
      const globalIdx = globalOrders.findIndex(globalOrder =>
        String(globalOrder.id) === String(orderId) || String(globalOrder.orderId) === String(orderId)
      );

      if (globalIdx !== -1) {
        globalOrders[globalIdx] = { ...globalOrders[globalIdx], ...order };
        saveGlobalOrders(globalOrders);
        console.log('üåê Synced to global orders');
      }

      // persist and notify UI
      orders[idx] = order;
      localStorage.setItem(ordersKey(), JSON.stringify(orders));
      localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';

      try { if (biddersModal) biddersModal.style.display = 'none'; } catch (e) { }

      // Force refresh
      window.dispatchEvent(new Event('publicDeliveryRequestsUpdated'));
      window.dispatchEvent(new Event('localOrdersUpdated'));

      renderOrders();

      console.log('üéâ Assignment completed with data:', {
        bidAmount: order.assignedBidAmount,
        bidETA: order.assignedBidEta,
        courierEarnings: order.courierEarnings
      });

      showToast(`‚úÖ ${courierName || courierId} assigned! Amount: GHC ${order.assignedBidAmount || 0}, ETA: ${order.assignedBidEta || 'N/A'} min`, 'success');
    }

    // Listen for real-time updates on delivery requests
// ‚úÖ FIXED: Setup real-time Firestore listeners
// ‚úÖ FIXED: Setup real-time Firestore listeners
// ‚úÖ FIXED: Setup real-time Firestore listeners for delivery requests
let deliveryListenerUnsubscribe = null;
// Modified function
function setupDeliveryRequestListeners() {
  try {
    // Clean up any existing listener first
    if (deliveryListenerUnsubscribe) {
      console.log('üßπ Cleaning up previous delivery listener');
      deliveryListenerUnsubscribe();
      deliveryListenerUnsubscribe = null;
    }
    
    const uid = auth.currentUser?.uid;
    if (!uid) {
      console.warn('No user ID - cannot setup listeners');
      return null;
    }
    
    console.log('üîÑ Setting up Firestore delivery request listeners for seller:', uid);
    
    const deliveryRequestsRef = collection(firestore, "deliveryRequests");
    const q = query(deliveryRequestsRef, 
      where("sellerId", "==", uid),
      where("status", "in", ["open", "assigned"])
    );
    
    // Set up real-time listener
    const unsubscribe = onSnapshot(q, 
      (snapshot) => {
        console.log('üì¢ Delivery request updated in Firestore');
        
        // Update localStorage cache
        const requests = [];
        snapshot.forEach((doc) => {
          const data = doc.data();
          requests.push({ 
            id: doc.id, 
            ...data,
            // Handle Firestore timestamps
            createdAt: data.createdAt?.toDate ? data.createdAt.toDate().toISOString() : data.createdAt,
            updatedAt: data.updatedAt?.toDate ? data.updatedAt.toDate().toISOString() : data.updatedAt,
            expiresAt: data.expiresAt?.toDate ? data.expiresAt.toDate().toISOString() : data.expiresAt
          });
        });
        
        localStorage.setItem(publicDeliveryRequestsKey(), JSON.stringify(requests));
        
        // Refresh UI
        window.dispatchEvent(new Event('publicDeliveryRequestsUpdated'));
        
        // Force refresh orders display
        if (typeof renderOrders === 'function') {
          console.log('üîÑ Triggering renderOrders from listener');
          setTimeout(() => {
            renderOrders();
          }, 500);
        }
      }, 
      (error) => {
        console.error('‚ùå Delivery request listener error:', error);
      }
    );
    
    // Store for cleanup
    deliveryListenerUnsubscribe = unsubscribe;
    
    console.log('‚úÖ Delivery request listeners setup complete');
    
    return unsubscribe;
    
  } catch (error) {
    console.error('‚ùå Failed to setup delivery request listeners:', error);
    return null;
  }
}

// Add cleanup on page unload (for page refreshes)
window.addEventListener('beforeunload', () => {
  if (deliveryListenerUnsubscribe) {
    console.log('üßπ Cleaning up delivery listener on page unload');
    deliveryListenerUnsubscribe();
    deliveryListenerUnsubscribe = null;
  }
});

// Add cleanup on logout (if you have a logout function)
function cleanupListeners() {
  if (deliveryListenerUnsubscribe) {
    console.log('üßπ Cleaning up delivery listener');
    deliveryListenerUnsubscribe();
    deliveryListenerUnsubscribe = null;
  }
}

// If you have authentication state change listener, clean up there too
onAuthStateChanged(auth, (user) => {
  if (!user) {
    cleanupListeners();
  }
});

// Call this in your init function or after auth
onAuthStateChanged(auth, (user) => {
  if (user) {
    setTimeout(setupDeliveryRequestListeners, 2000);
  }
});

    /* ---------- Bidders modal builder (injected) ---------- */
    let biddersModal = null;
    function ensureBiddersModal() {
      if (biddersModal) return biddersModal;
      biddersModal = document.createElement('div');
      biddersModal.className = 'modal';
      biddersModal.style.display = 'none';
      biddersModal.innerHTML = `<div class="modal-card" role="dialog" aria-modal="true"><h3 id="biddersTitle">Bidders</h3><div id="biddersList" style="max-height:360px;overflow:auto;margin-top:8px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="closeBidders" class="btn">Close</button></div></div>`;
      document.body.appendChild(biddersModal);
      biddersModal.querySelector('#closeBidders').addEventListener('click', () => biddersModal.style.display = 'none');
      return biddersModal;
    }

    function sanitizeDomId(s) {
      return String(s || '').replace(/[^a-z0-9\-_]/gi, '-');
    }

    async function showBiddersModal(order) {
  ensureBiddersModal();

  // Read from Firestore delivery requests ASYNC
  const publicRequests = await getPublicDeliveryRequests();
  const deliveryRequest = publicRequests.find(req =>
    req.orderId === order.id || req.orderId === order.orderId
  );

  const modal = biddersModal;
  const listEl = modal.querySelector('#biddersList');
  listEl.innerHTML = '';

  if (!deliveryRequest) {
    listEl.innerHTML = `<div class="small-muted">No active delivery request found for this order.</div>`;
    modal.style.display = 'flex';
    return;
  }

  const bids = deliveryRequest.bids || [];

  if (!bids.length) {
    listEl.innerHTML = `<div class="small-muted">No bidders yet.</div>`;
    modal.style.display = 'flex';
    return;
  }

  // Build bidder cards from public requests
  for (const bid of bids) {
    const bidId = String(bid.bidderId || '');
    const displayName = bid.bidderName || bidId || 'Courier';
    const avatar = bid.bidderAvatar || '../../images/no profile pic.jpg';
    const amountText = (typeof bid.amount !== 'undefined' && bid.amount !== null) ? `GHC ${Number(bid.amount).toFixed(2)}` : '';
    const etaText = bid.eta ? ` ‚Ä¢ ETA: ${escapeHtml(String(bid.eta))} min` : '';
    const placedText = bid.placedAt ? fmtDate(bid.placedAt) : '';

    const card = document.createElement('div');
    card.className = 'bid-card';
    card.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid #eee;gap:12px;';

    // Left section (avatar + info)
    const left = document.createElement('div');
    left.style.cssText = 'display:flex;align-items:center;gap:12px;flex:1;';
    left.innerHTML = `
  <img src="${escapeHtml(avatar)}" style="width:48px;height:48px;border-radius:8px;object-fit:cover" onerror="this.onerror=null;this.src='../../images/no profile pic.jpg'">
  <div style="min-width:0;flex:1;">
    <div style="font-weight:700">${escapeHtml(displayName)}</div>
    <div class="small-muted" style="font-size:12px">UID: ${escapeHtml(bidId)}</div>
    ${amountText || etaText ? `<div class="small-muted" style="margin-top:6px">${escapeHtml(amountText)}${escapeHtml(etaText)}</div>` : ''}
    ${bid.bidderPhone ? `<div class="small-muted" style="margin-top:4px">üìû ${escapeHtml(bid.bidderPhone)}</div>` : ''}
    ${bid.bidderEmail ? `<div class="small-muted">‚úâÔ∏è ${escapeHtml(bid.bidderEmail)}</div>` : ''}
    ${bid.bidderIndex ? `<div class="small-muted">Index: ${escapeHtml(bid.bidderIndex)}</div>` : ''}
    ${bid.bidderProgram ? `<div class="small-muted">Program: ${escapeHtml(bid.bidderProgram)}</div>` : ''}
    ${bid.bidderRoom ? `<div class="small-muted">Room: ${escapeHtml(bid.bidderRoom)}</div>` : ''}
    <div class="small-muted" style="margin-top:4px">Placed: ${escapeHtml(placedText)}</div>
  </div>
`;

    // Right section (buttons)
    const right = document.createElement('div');
    right.style.cssText = 'display:flex;align-items:center;gap:8px;flex-shrink:0;';

    const assignBtn = document.createElement('button');
    assignBtn.className = 'btn btn-accept';
    assignBtn.textContent = 'Assign';
    assignBtn.setAttribute('data-bid-id', bidId);
    assignBtn.setAttribute('data-order-id', String(order.id || order.orderId || ''));

    const removeBtn = document.createElement('button');
    removeBtn.className = 'btn btn-warn';
    removeBtn.textContent = 'Remove';
    removeBtn.setAttribute('data-bid-id', bidId);
    removeBtn.setAttribute('data-request-id', deliveryRequest.id);

    right.appendChild(assignBtn);
    right.appendChild(removeBtn);
    card.appendChild(left);
    card.appendChild(right);
    listEl.appendChild(card);

    // Event handlers
    assignBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (!confirm(`Assign ${displayName} to this order? This will immediately assign them and they can start delivery.`)) return;

      let friendlyName = displayName;
      try {
        const userProfile = await getSellerInfo(bidId);
        if (userProfile && userProfile.name) friendlyName = userProfile.name;
      } catch (err) { /* ignore */ }

      // üî• IMMEDIATELY ASSIGN AND UPDATE STATUS
      assignCourier(order.id || order.orderId, bidId, friendlyName);

      // üî• UPDATE ORDER STATUS TO "Assigned" so delivery guy can start immediately
      changeOrderStatus(order, 'Assigned');

      modal.style.display = 'none';
      showToast(`‚úÖ ${friendlyName} assigned and can start delivery now!`, 'success');
    });
    
    removeBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (!confirm(`Remove ${displayName}'s bid from this delivery request?`)) return;

      // Remove bid from public requests
      const updatedRequests = publicRequests.map(req => {
        if (req.id === deliveryRequest.id) {
          return {
            ...req,
            bids: req.bids.filter(b => String(b.bidderId) !== String(bidId))
          };
        }
        return req;
      });

      // Save to Firestore
      try {
        await savePublicDeliveryRequests(updatedRequests);
      } catch (error) {
        console.error('Failed to save to Firestore:', error);
      }

      showToast('Bid removed from delivery request', 'success');
      showBiddersModal(order); // Refresh modal
    });
  }

  modal.style.display = 'flex';
}

    /* ---------- Show Assigned Courier Details Modal ---------- */
    /* ---------- Show Assigned Courier Details Modal ---------- */
    async function showAssignedCourierDetails(order) {
      // Create or get the modal
      let assignedModal = document.getElementById('assignedCourierModal');
      if (!assignedModal) {
        assignedModal = document.createElement('div');
        assignedModal.id = 'assignedCourierModal';
        assignedModal.className = 'modal';
        assignedModal.innerHTML = `
      <div class="modal-card" role="dialog" aria-modal="true">
        <h3>Assigned Courier Details</h3>
        <div id="assignedCourierContent" style="max-height:400px;overflow:auto"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
          <button id="closeAssignedModal" class="btn btn-warn">Close</button>
        </div>
      </div>
    `;
        document.body.appendChild(assignedModal);

        // Close button handler
        assignedModal.querySelector('#closeAssignedModal').addEventListener('click', () => {
          assignedModal.style.display = 'none';
        });
      }

      const contentEl = assignedModal.querySelector('#assignedCourierContent');
      contentEl.innerHTML = '<div style="text-align:center;padding:20px"><i class="fas fa-spinner fa-spin"></i> Loading courier details...</div>';

      assignedModal.style.display = 'flex';

      try {
        // Get the assigned courier ID
        const assignedTo = order.assignedTo || order.assignedDeliveryId;

        if (!assignedTo) {
          contentEl.innerHTML = '<div style="text-align:center;color:var(--muted)">No courier assignment information found.</div>';
          return;
        }

        // Fetch courier details
        const courierProfile = await getSellerInfo(assignedTo);

        // üî• Calculate financial breakdown
        const deliveryFee = Number(order.deliveryFee || order.delivery || 0);
        const courierEarnings = Number(order.courierEarnings || order.assignedBidAmount || 0);
        const sellerProfit = Number(order.deliveryProfit || (deliveryFee - courierEarnings));
        const platformFee = 0; // You can add platform fees if needed

        // üî• Get timing information
        const promisedETA = order.assignedBidEta || 'Not specified';
        const assignedTime = order.assignedAt;
        const currentTime = new Date();
        const assignedDate = new Date(assignedTime);
        const timeSinceAssignment = Math.round((currentTime - assignedDate) / (1000 * 60)); // minutes

        if (!courierProfile) {
          contentEl.innerHTML = `
        <div style="text-align:center">
          <div style="color:var(--muted);margin-bottom:12px">Courier details not available</div>
          <div class="small-muted">Courier ID: ${escapeHtml(assignedTo)}</div>
          <div class="small-muted">Assigned at: ${fmtDate(order.assignedAt)}</div>
        </div>
      `;
          return;
        }

        // Display courier details with financial and timing info
        contentEl.innerHTML = `
      <div style="text-align:center;margin-bottom:20px">
        <img src="${courierProfile.profilePictureUrl || '../../images/no profile pic.jpg'}" 
             style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #10b981">
        <h3 style="margin:12px 0 4px 0">${escapeHtml(courierProfile.name || 'Unknown Courier')}</h3>
        <div class="small-muted">Courier ID: ${escapeHtml(assignedTo)}</div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
        <div style="text-align:center;padding:12px;background:var(--light-bg);border-radius:8px">
          <div class="small-muted">Phone</div>
          <div style="font-weight:600">${courierProfile.phone ? escapeHtml(courierProfile.phone) : 'Not provided'}</div>
        </div>
        <div style="text-align:center;padding:12px;background:var(--light-bg);border-radius:8px">
          <div class="small-muted">Email</div>
          <div style="font-weight:600">${courierProfile.email ? escapeHtml(courierProfile.email) : 'Not provided'}</div>
        </div>
      </div>

      <!-- üî• FINANCIAL BREAKDOWN SECTION -->
      <div style="margin-bottom:16px;padding:16px;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0">
        <strong style="display:block;margin-bottom:12px;color:#1e40af;">üí∞ Delivery Fee Breakdown</strong>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px">
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Total Delivery Fee</div>
            <div style="font-weight:700;color:#1e40af;font-size:1.1rem">GHC ${deliveryFee.toFixed(2)}</div>
          </div>
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Courier's Share</div>
            <div style="font-weight:700;color:#10b981;font-size:1.1rem">GHC ${courierEarnings.toFixed(2)}</div>
          </div>
        </div>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Your Profit</div>
            <div style="font-weight:700;color:#f59e0b;font-size:1.1rem">GHC ${sellerProfit.toFixed(2)}</div>
          </div>
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Platform Fee</div>
            <div style="font-weight:700;color:#64748b;font-size:1.1rem">GHC ${platformFee.toFixed(2)}</div>
          </div>
        </div>
        
        <div style="margin-top:12px;padding:10px;background:#dbeafe;border-radius:6px">
          <div class="small-muted" style="font-size:12px;color:#1e40af">Courier requested <strong>GHC ${courierEarnings.toFixed(2)}</strong> out of the GHC ${deliveryFee.toFixed(2)} delivery fee</div>
        </div>
      </div>

      <!-- üî• TIMING INFORMATION SECTION -->
      <div style="margin-bottom:16px;padding:16px;background:#fffbeb;border-radius:8px;border:1px solid #fcd34d">
        <strong style="display:block;margin-bottom:12px;color:#d97706;">‚è∞ Delivery Timing</strong>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px">
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Promised ETA</div>
            <div style="font-weight:700;color:#d97706;font-size:1.1rem">
              ${typeof promisedETA === 'number' ? `${promisedETA} min` : escapeHtml(promisedETA)}
            </div>
            <div class="small-muted" style="font-size:10px">Estimated delivery time</div>
          </div>
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Time Since Assigned</div>
            <div style="font-weight:700;color:#dc2626;font-size:1.1rem">${timeSinceAssignment} min</div>
            <div class="small-muted" style="font-size:10px">Currently active</div>
          </div>
        </div>
        
        <div style="margin-top:8px">
          <div class="small-muted">Assigned at: ${fmtDate(assignedTime)}</div>
          ${typeof promisedETA === 'number' ?
            `<div class="small-muted">Expected completion: ${fmtDate(new Date(assignedDate.getTime() + (promisedETA * 60000)))}</div>` :
            ''
          }
        </div>
      </div>

      <div style="margin-bottom:16px">
        <strong>Contact Information:</strong>
        <div style="margin-top:8px">
          ${courierProfile.phone ? `<div class="small-muted">üìû Phone: ${escapeHtml(courierProfile.phone)}</div>` : ''}
          ${courierProfile.email ? `<div class="small-muted">‚úâÔ∏è Email: ${escapeHtml(courierProfile.email)}</div>` : ''}
          ${courierProfile.index ? `<div class="small-muted">üÜî Index: ${escapeHtml(courierProfile.index)}</div>` : ''}
          ${courierProfile.program ? `<div class="small-muted">üéì Program: ${escapeHtml(courierProfile.program)}</div>` : ''}
          ${courierProfile.room ? `<div class="small-muted">üè† Room: ${escapeHtml(courierProfile.room)}</div>` : ''}
        </div>
      </div>

      <div style="background:#f0f9ff;padding:12px;border-radius:8px;border-left:4px solid #2563eb">
        <strong>Delivery Status:</strong>
        <div style="margin-top:4px">
          <span class="status-badge ${statusClass(order.status)}">${escapeHtml(order.status || 'Assigned')}</span>
          <div class="small-muted" style="margin-top:4px">
            ${order.status === 'Assigned' ? 'The courier has been assigned and can start delivery.' :
            order.status === 'Delivering' ? 'The courier is currently delivering the order.' :
              order.status === 'At Door' ? 'The courier has arrived at the delivery location.' :
                'Delivery in progress.'}
          </div>
        </div>
      </div>

      <!-- üî• PERFORMANCE METRICS (if available) -->
      ${order.performance ? `
        <div style="margin-top:16px;padding:12px;background:#ecfdf5;border-radius:8px;border-left:4px solid #10b981">
          <strong style="color:#065f46;">üìä Performance Metrics</strong>
          <div style="margin-top:8px">
            <div class="small-muted">On-time Performance: <strong>${(order.performance * 100).toFixed(0)}%</strong></div>
            ${order.actualDeliveryTime ? `<div class="small-muted">Actual Delivery Time: <strong>${order.actualDeliveryTime} min</strong></div>` : ''}
            ${order.onTime !== undefined ? `<div class="small-muted">On-time Status: <strong>${order.onTime ? '‚úÖ On Time' : '‚ùå Late'}</strong></div>` : ''}
          </div>
        </div>
      ` : ''}
    `;

      } catch (error) {
        console.error('Error loading assigned courier details:', error);
        contentEl.innerHTML = '<div style="text-align:center;color:var(--danger)">Error loading courier details. Please try again.</div>';
      }
    }

    /* ---------- Order details HTML (unchanged but show bidders summary) ---------- */
    // Replace your existing renderOrderDetailsHtml with this improved version
    async function renderOrderDetailsHtml(o) {
      // build base (buyer/items/summary) like before
      const baseHtml = (function () {
        const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
        const buyerName = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
        const buyerPhone = escapeHtml(buyerObj?.phone || o.phone || '');
        const buyerEmail = escapeHtml(buyerObj?.email || o.email || '');
        const buyerRoom = escapeHtml(buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '');
        const buyerIndex = escapeHtml(buyerObj?.index || o.index || '');
        const buyerProgram = escapeHtml(buyerObj?.program || '');
        const buyerAvatar = buyerObj?.profilePictureUrl || '';

        const items = Array.isArray(o.items) ? o.items : (o.product ? [{ name: o.product, price: o.price || 0, quantity: o.quantity || 1, image: orderThumbnail(o) }] : []);
        const itemsHtml = items.map(it => {
          const imgSrc = it.image || orderThumbnail(o) || 'https://via.placeholder.com/90';
          return `<div class="order-item" style="display:flex;gap:10px;align-items:center;margin-bottom:10px">
        <img class="item-thumb" src="${escapeHtml(imgSrc)}" alt="${escapeHtml(it.name || '')}" style="width:72px;height:72px;object-fit:cover;border-radius:6px">
        <div>
          <div style="font-weight:700">${escapeHtml(it.name || '')}</div>
          <div class="small-muted">Price: GHC ${(Number(it.price) || 0).toFixed(2)} ‚Ä¢ Qty: ${it.quantity || 1}</div>
        </div>
      </div>`;
        }).join('');

        const subtotal = o.subtotal || items.reduce((s, i) => s + ((Number(i.price) || 0) * (Number(i.quantity) || 1)), 0);
        const deliveryFee = o.delivery || o.deliveryFee || 0;
        const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
        const deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);
        const sellerRevenue = subtotal + deliveryProfit;
        const placed = o.appearedAt || o.date || '';

        const assignedPlaceholderId = `assigned-info-${sanitizeDomId(o.id || o.orderId)}`;

        return `<div class="order-details" style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between">
      <div style="flex:1">
        <div style="font-weight:700">Items</div>
        <div class="order-items" style="margin-top:8px">${itemsHtml}</div>
      </div>
      <div style="width:320px">
        <div style="font-weight:700">Summary</div>
        <div class="small-muted">Placed: ${fmtDate(placed)}</div>
        <div class="small-muted">Subtotal: GHC ${Number(subtotal || 0).toFixed(2)}</div>
        <div class="small-muted">Delivery Fee: GHC ${Number(deliveryFee || 0).toFixed(2)}</div>
        ${courierEarnings > 0 ? `<div class="small-muted">Courier Earnings: GHC ${Number(courierEarnings || 0).toFixed(2)}</div>` : ''}
        ${deliveryProfit > 0 ? `<div class="small-muted" style="color:var(--success);font-weight:600">Your Delivery Profit: GHC ${Number(deliveryProfit || 0).toFixed(2)}</div>` : ''}
        <div style="margin-top:8px;font-weight:800;color:var(--success)">Your Revenue: GHC ${Number(sellerRevenue || 0).toFixed(2)}</div>
        ${o.deliveryPerson ? `<div class="small-muted">Courier: ${escapeHtml(o.deliveryPerson)}</div>` : ''}
        <div id="${assignedPlaceholderId}" class="small-muted" style="margin-top:6px"></div>
        <div class="small-muted" style="margin-top:6px">Progress step: ${o.progressStep || getProgressStep(o.status)}</div>
        <hr style="margin:10px 0;border:none;border-top:1px solid #eee">
        <div style="font-weight:700">Buyer</div>
        ${buyerAvatar ? `<div style="margin-top:6px;margin-bottom:6px"><img src="${escapeHtml(buyerAvatar)}" alt="${buyerName}" style="width:64px;height:64px;border-radius:8px;object-fit:cover"></div>` : ''}
        <div class="small-muted" style="margin-top:6px">${buyerName}</div>
        ${buyerPhone ? `<div class="small-muted">üìû ${buyerPhone}</div>` : ''}
        ${buyerEmail ? `<div class="small-muted">‚úâÔ∏è ${buyerEmail}</div>` : ''}
        ${buyerRoom ? `<div class="small-muted">üè† ${buyerRoom}</div>` : ''}
        ${buyerIndex ? `<div class="small-muted">üÜî ${buyerIndex}</div>` : ''}
        ${buyerProgram ? `<div class="small-muted">üéì ${buyerProgram}</div>` : ''}
      </div>
    </div>`;
      })();

      // Get bids from public delivery requests
      const publicRequests = await getPublicDeliveryRequests();
      const deliveryRequest = publicRequests.find(req =>
        req.orderId === o.id || req.orderId === o.orderId
      );

      const bids = deliveryRequest ? (deliveryRequest.bids || []) : [];
      const isAssigned = !!(o.assignedTo || o.assignedDeliveryId);

      // üî• ONLY show bidders if NOT assigned
      let biddersHtml = '';
      if (!isAssigned && bids.length) {
        biddersHtml = `<div style="margin-top:16px;padding:16px;background:var(--light-bg);border-radius:8px;">
    <strong style="display:block;margin-bottom:12px;">Bidders (${bids.length})</strong>
    <div style="display:flex;flex-direction:column;gap:12px;">
      ${bids.map(bid => {
          const displayName = escapeHtml(bid.bidderName || bid.bidderId || 'Courier');
          const avatar = escapeHtml(bid.bidderAvatar || '../../images/no profile pic.jpg');
          const amountText = (typeof bid.amount !== 'undefined' && bid.amount !== null) ? `GHC ${Number(bid.amount).toFixed(2)}` : '';
          const etaText = bid.eta ? ` ‚Ä¢ ETA: ${escapeHtml(String(bid.eta))} min` : '';
          const placed = fmtDate(bid.placedAt || '');

          return `
          <div style="display:flex;align-items:center;gap:12px;padding:12px;background:white;border-radius:8px;border:1px solid #eee;">
            <img src="${avatar}" style="width:48px;height:48px;border-radius:6px;object-fit:cover">
            <div style="flex:1">
              <div style="font-weight:700">${displayName}</div>
              <div class="small-muted">UID: ${escapeHtml(bid.bidderId || '')}</div>
              ${amountText || etaText ? `<div class="small-muted" style="margin-top:4px">${escapeHtml(amountText)}${escapeHtml(etaText)}</div>` : ''}
              ${bid.bidderPhone ? `<div class="small-muted">üìû ${escapeHtml(bid.bidderPhone)}</div>` : ''}
              ${bid.bidderEmail ? `<div class="small-muted">‚úâÔ∏è ${escapeHtml(bid.bidderEmail)}</div>` : ''}
              <div class="small-muted" style="margin-top:4px">Placed: ${escapeHtml(placed)}</div>
            </div>
            <div style="display:flex;gap:8px;flex-shrink:0;">
              <button class="btn btn-accept btn-sm" 
                      data-bid-id="${escapeHtml(bid.bidderId || '')}" 
                      data-order-id="${escapeHtml(o.id || o.orderId || '')}">
                Assign
              </button>
            </div>
          </div>
        `;
        }).join('')}
    </div>
  </div>`;
      } else if (!isAssigned) {
        biddersHtml = `<div style="margin-top:16px;padding:12px;background:var(--light-bg);border-radius:8px;text-align:center;" class="small-muted">
    No bidders yet
  </div>`;
      } else {
        // üî• Show assigned courier info instead of bidders
        const assignedTo = o.assignedTo || o.assignedDeliveryId;
        biddersHtml = `<div style="margin-top:16px;padding:16px;background:#f0f9ff;border-radius:8px;border-left:4px solid #10b981;">
    <strong style="display:block;margin-bottom:12px;color:#10b981;">‚úÖ Assigned to Courier</strong>
    <div style="display:flex;align-items:center;gap:12px;">
      <i class="fas fa-user-check" style="font-size:1.5rem;color:#10b981;"></i>
      <div>
        <div style="font-weight:700">${escapeHtml(o.deliveryPerson || assignedTo || 'Courier')}</div>
        <div class="small-muted">Courier ID: ${escapeHtml(assignedTo || 'Unknown')}</div>
        <div class="small-muted">Assigned: ${fmtDate(o.assignedAt)}</div>
        <button class="btn btn-accept btn-sm" style="margin-top:8px" onclick="showAssignedCourierDetails(${JSON.stringify(o).replace(/"/g, '&quot;')})">
          View Courier Details
        </button>
      </div>
    </div>
  </div>`;
      }

      return biddersHtml + baseHtml;
    }


    /* ---------- Render Orders ---------- */
    let lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';

    // üî• ADD THIS FUNCTION - Syncs global order status to seller storage
    function syncSellerOrdersFromGlobal() {
      try {
        const globalOrders = getGlobalOrders();
        const sellerOrdersKey = ordersKey();
        let sellerOrders = JSON.parse(localStorage.getItem(sellerOrdersKey) || '[]');

        let changed = false;

        // Update each seller order with latest status from global
        sellerOrders.forEach((sellerOrder, index) => {
          const globalOrder = globalOrders.find(g =>
            String(g.id) === String(sellerOrder.id) ||
            String(g.orderId) === String(sellerOrder.orderId)
          );

          if (globalOrder && sellerOrder.status !== globalOrder.status) {
            sellerOrders[index].status = globalOrder.status;
            sellerOrders[index].progressStep = globalOrder.progressStep;
            sellerOrders[index].deliveredAt = globalOrder.deliveredAt;
            sellerOrders[index].deliveryPerson = globalOrder.deliveryPerson;
            changed = true;
          }
        });

        if (changed) {
          localStorage.setItem(sellerOrdersKey, JSON.stringify(sellerOrders));
        }
      } catch (error) {
        console.log('Sync error:', error);
      }
    }

    
    /* ---------- Completed / History rendering ---------- */
    function renderCompletedOrders() {
      if (!completedTbody) return;
      completedTbody.innerHTML = '';
      completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];

      const sTerm = (historySearch?.value || '').toLowerCase();
      if (!completedOrders.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="7" style="text-align:center;color:var(--muted)">No completed orders yet</td>`;
        completedTbody.appendChild(tr);
        return;
      }

      const list = completedOrders.slice().reverse().filter(o => {
        const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
        const buyerSearch = `${buyerObj?.name || o.buyerName || o.buyer || o.customer || ''} ${buyerObj?.phone || o.phone || ''}`;
        const combined = `${buyerSearch} ${JSON.stringify(o.items || o.product || '')}`;
        return (!sTerm || combined.toLowerCase().includes(sTerm) || String(o.id || '').includes(sTerm));
      });

      list.forEach(o => {
        const tr = document.createElement('tr');

        // üéØ Add visual indicator for rejected orders
        const isRejected = o.status === 'Rejected';
        const isDelivered = o.status === 'Delivered' || o.status === 'Picked Up';

        if (isRejected) {
          tr.style.backgroundColor = 'rgba(239, 68, 68, 0.05)';
          tr.style.borderLeft = '4px solid var(--danger)';
        }

        const thumbUrl = orderThumbnail(o) || 'https://via.placeholder.com/90';
        const itemsSummary = Array.isArray(o.items) ? o.items.map(i => i.name).join(', ') : (o.product || '-');
        const qty = Array.isArray(o.items) ? o.items.reduce((s, i) => s + (i.quantity || 1), 0) : (o.quantity || 1);

        // üéØ CORRECT LOGIC: Calculate revenue based on status
        let sellerRevenue = 0;
        let revenueDisplay = '';
        let statusIndicator = '';

        if (isRejected) {
          sellerRevenue = 0;
          revenueDisplay = `<span style="color:var(--danger);text-decoration:line-through">GHC 0.00</span>`;
          statusIndicator = `<span class="status-badge s-rejected" style="margin-left:8px;font-size:0.7rem">REJECTED</span>`;
        } else if (isDelivered) {
          const productRevenue = o.subtotal || 0;
          const deliveryFee = o.delivery || o.deliveryFee || 0;
          const sellerDelivered = !o.assignedTo && !o.assignedDeliveryId;

          if (sellerDelivered) {
            sellerRevenue = productRevenue + deliveryFee;
          } else {
            const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
            const deliveryProfit = deliveryFee - courierEarnings;
            sellerRevenue = productRevenue + deliveryProfit;
          }
          revenueDisplay = `<span style="color:var(--success);font-weight:600">GHC ${Number(sellerRevenue || 0).toFixed(2)}</span>`;
          statusIndicator = o.status === 'Picked Up'
            ? `<span class="status-badge s-delivered" style="margin-left:8px;font-size:0.7rem">PICKUP</span>`
            : `<span class="status-badge s-delivered" style="margin-left:8px;font-size:0.7rem">DELIVERED</span>`;
        }

        // buyer fields
        const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
        const buyerNameDisplay = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
        const buyerPhoneDisplay = escapeHtml(buyerObj?.phone || o.phone || '');

        // üéØ Show correct timestamp
        const actionTimestamp = isRejected ? o.rejectedAt : (o.deliveredAt || o.delivered || o.completedAt || o.pickedUpAt || '');
        const actionText = isRejected ? 'Rejected' : (o.status === 'Picked Up' ? 'Picked Up' : 'Delivered');

        tr.innerHTML = `
      <td>
        ${escapeHtml(o.id || o.orderId || '')}
        ${statusIndicator}
      </td>
      <td>
        ${buyerNameDisplay}
        ${buyerPhoneDisplay ? `<div class="small-muted">üìû ${buyerPhoneDisplay}</div>` : ''}
        ${isRejected ? '<div class="small-muted" style="color:var(--danger);font-size:0.75rem">‚ùå Order Rejected</div>' :
            (!o.assignedTo && !o.assignedDeliveryId) ? '<div class="small-muted" style="color:var(--primary);font-size:0.75rem">üöó Self-delivered</div>' : ''}
      </td>
      <td style="display:flex;align-items:center;max-width:320px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">
        <img src="${thumbUrl}" class="row-thumb" alt="thumb">
        <div style="min-width:0">
          <div style="font-weight:700">${escapeHtml(itemsSummary)}</div>
        </div>
      </td>
      <td>${qty}</td>
      <td>${revenueDisplay}</td>
      <td>
        ${fmtDate(actionTimestamp)}
        <div class="small-muted" style="font-size:0.75rem">${actionText}</div>
      </td>
      <td class="actions"></td>
    `;

        const actTd = tr.querySelector('.actions');
        actTd.appendChild(actionBtn('Details', 'btn-muted', () => toggleCompletedDetailsFor(o)));

        completedTbody.appendChild(tr);

        const detailsTr = document.createElement('tr');
        detailsTr.className = 'completed-details-row';
        detailsTr.style.display = 'none';
        const td = document.createElement('td');
        td.colSpan = 7;
        td.innerHTML = renderCompletedOrderDetailsHtml(o);
        detailsTr.appendChild(td);
        completedTbody.appendChild(detailsTr);
      });
    }

    function toggleCompletedDetailsFor(orderObj) {
      const rows = Array.from(completedTbody.querySelectorAll('tr'));
      for (let i = 0; i < rows.length; i += 2) {
        const main = rows[i], details = rows[i + 1]; if (!main) continue;
        const idCell = main.cells[0]?.textContent || '';
        if (idCell.includes(String(orderObj.id || orderObj.orderId || ''))) {
          details.style.display = details.style.display === 'table-row' ? 'none' : 'table-row';
          return;
        }
      }
    }

    function renderCompletedOrderDetailsHtml(o) {
      const items = Array.isArray(o.items) ? o.items : (o.product ? [{ name: o.product, price: o.price || 0, quantity: o.quantity || 1 }] : []);
      const itemsHtml = items.map(it => `<div class="order-item" style="display:flex;gap:10px;align-items:center;margin-bottom:10px"><img class="item-thumb" src="${it.image || orderThumbnail(o) || 'https://via.placeholder.com/90'}" style="width:72px;height:72px;object-fit:cover;border-radius:6px"><div><div style="font-weight:700">${escapeHtml(it.name)}</div><div class="small-muted">Price: GHC ${(it.price || 0).toFixed(2)} ‚Ä¢ Qty: ${it.quantity || 1}</div></div></div>`).join('');

      const subtotal = o.subtotal || items.reduce((s, i) => s + (i.price || 0) * (i.quantity || 1), 0);
      const deliveryFee = o.delivery || (o.deliveryFee || 0);
      const totalOrderValue = subtotal + deliveryFee;

      // üéØ FIX: Handle REJECTED vs DELIVERED orders differently
      const isRejected = o.status === 'Rejected';
      const isDelivered = o.status === 'Delivered' || o.status === 'Picked Up';

      let revenueHtml = '';
      let statusBadge = '';

      if (isRejected) {
        // REJECTED ORDER - Show $0 revenue
        revenueHtml = `
      <div style="margin-top:8px">
        <div class="small-muted">Order Value: <span style="text-decoration:line-through;color:var(--danger)">GHC ${Number(totalOrderValue || 0).toFixed(2)}</span></div>
        <div class="small-muted" style="color:var(--danger);font-weight:600">Rejected Revenue: GHC 0.00</div>
      </div>
    `;
        statusBadge = `<span class="status-badge s-rejected" style="margin-left:8px">REJECTED</span>`;
      } else if (isDelivered) {
        // DELIVERED ORDER - Show actual revenue calculation
        const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
        const deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);
        const sellerRevenue = subtotal + deliveryProfit;

        revenueHtml = `
      <div style="margin-top:8px">
        <div class="small-muted">Order Value: GHC ${Number(totalOrderValue || 0).toFixed(2)}</div>
        <div class="small-muted">Subtotal: GHC ${Number(subtotal || 0).toFixed(2)}</div>
        <div class="small-muted">Delivery Fee: GHC ${Number(deliveryFee || 0).toFixed(2)}</div>
        ${courierEarnings > 0 ? `<div class="small-muted">Courier Earnings: GHC ${Number(courierEarnings || 0).toFixed(2)}</div>` : ''}
        ${deliveryProfit > 0 ? `<div class="small-muted" style="color:var(--success);font-weight:600">Delivery Profit: GHC ${Number(deliveryProfit || 0).toFixed(2)}</div>` : ''}
        <div style="margin-top:8px;font-weight:800;color:var(--success)">Your Revenue: GHC ${Number(sellerRevenue || 0).toFixed(2)}</div>
      </div>
    `;
        statusBadge = `<span class="status-badge s-delivered" style="margin-left:8px">DELIVERED</span>`;
      }

      // buyer fields
      const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
      const buyerName = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
      const buyerPhone = escapeHtml(buyerObj?.phone || o.phone || '');
      const buyerRoom = escapeHtml(buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '');
      const buyerEmail = escapeHtml(buyerObj?.email || o.email || '');
      const buyerIndex = escapeHtml(buyerObj?.index || o.index || '');
      const buyerProgram = escapeHtml(buyerObj?.program || '');
      const buyerAvatar = buyerObj?.profilePictureUrl || '';

      // üéØ FIX: Show correct timestamp based on status
      const actionTimestamp = isRejected ? o.rejectedAt : (o.deliveredAt || o.delivered || o.completedAt || o.pickedUpAt || '');
      const actionText = isRejected ? 'Rejected' : (o.status === 'Picked Up' ? 'Picked Up' : 'Delivered');

      return `<div class="order-details" style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between">
    <div style="flex:1">
      <div style="font-weight:700;display:flex;align-items:center">
        Items ${statusBadge}
      </div>
      <div class="order-items" style="margin-top:8px">${itemsHtml}</div>
    </div>
    <div style="width:320px">
      <div style="font-weight:700">Order Summary</div>
      <div class="small-muted">Placed: ${fmtDate(o.date || o.appearedAt)}</div>
      <div class="small-muted">${actionText}: ${fmtDate(actionTimestamp)}</div>
      
      ${revenueHtml}
      
      ${o.deliveryPerson ? `<div class="small-muted">Courier: ${escapeHtml(o.deliveryPerson)}</div>` : ''}
      
      <hr style="margin:10px 0;border:none;border-top:1px solid #eee">
      
      <div style="font-weight:700">Buyer Information</div>
      ${buyerAvatar ? `<div style="margin-top:6px;margin-bottom:6px"><img src="${buyerAvatar}" alt="${buyerName}" style="width:64px;height:64px;border-radius:8px;object-fit:cover"></div>` : ''}
      <div class="small-muted" style="margin-top:6px">${buyerName}</div>
      ${buyerPhone ? `<div class="small-muted">üìû ${buyerPhone}</div>` : ''}
      ${buyerEmail ? `<div class="small-muted">‚úâÔ∏è ${buyerEmail}</div>` : ''}
      ${buyerRoom ? `<div class="small-muted">üè† ${buyerRoom}</div>` : ''}
      ${buyerIndex ? `<div class="small-muted">üÜî ${buyerIndex}</div>` : ''}
      ${buyerProgram ? `<div class="small-muted">üéì ${buyerProgram}</div>` : ''}
      
      ${isRejected ? `
        <hr style="margin:10px 0;border:none;border-top:1px solid var(--danger)">
        <div style="color:var(--danger);font-size:0.85rem">
          <i class="fas fa-exclamation-triangle"></i> This order was rejected. No revenue was earned.
        </div>
      ` : ''}
    </div>
  </div>`;
    }

    /* ---------- Small helpers & UI actions ---------- */
    function actionBtn(label, cls, cb) {
      const b = document.createElement('button'); b.className = 'btn ' + (cls || 'btn-muted'); b.textContent = label;
      b.addEventListener('click', e => { e.stopPropagation(); cb(); });
      return b;
    }

    function toggleDetailsFor(orderObj) {
      const rows = Array.from(ordersTbody.querySelectorAll('tr'));
      for (let i = 0; i < rows.length; i += 2) {
        const main = rows[i], details = rows[i + 1]; if (!main) continue;
        const idCell = main.cells[0]?.textContent || '';
        if (idCell.includes(String(orderObj.id || orderObj.orderId || ''))) {
          details.style.display = details.style.display === 'table-row' ? 'none' : 'table-row';
          return;
        }
      }
    }

    /* ---------- Pickup Order Flow ---------- */
    function handlePickupOrder(orderRef) {
      try {
        const orderId = typeof orderRef === 'object' ? (orderRef.id || orderRef.orderId) : String(orderRef);

        if (!confirm(`Mark order #${orderId} as ready for pickup? Buyer will be notified to come collect.`)) return;

        // Update order status to "Ready for Pickup"
        changeOrderStatus(orderRef, 'Ready for Pickup');

        showToast('Order marked ready for pickup!', 'success');

      } catch (err) {
        console.error('handlePickupOrder failed:', err);
        showToast('Error marking order ready for pickup', 'error');
      }
    }

    function openPickupConfirmationModal(order) {
      let pickupModal = document.getElementById('pickupConfirmationModal');
      if (!pickupModal) {
        pickupModal = document.createElement('div');
        pickupModal.id = 'pickupConfirmationModal';
        pickupModal.className = 'modal';
        pickupModal.innerHTML = `
      <div class="modal-card">
        <h3>Confirm Pickup Completion</h3>
        <div style="margin-bottom:16px">
          <div class="small-muted">Ask the buyer for their pickup code:</div>
          <input id="pickupCodeInput" class="input" placeholder="Enter 6-digit code" style="width:100%;margin-top:8px">
          <div class="small-muted" style="margin-top:4px">Order #${order.id || order.orderId}</div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="cancelPickup" class="btn btn-warn">Cancel</button>
          <button id="confirmPickup" class="btn btn-accept">Confirm Pickup</button>
        </div>
      </div>
    `;
        document.body.appendChild(pickupModal);

        pickupModal.querySelector('#cancelPickup').addEventListener('click', () => {
          pickupModal.style.display = 'none';
        });

        pickupModal.querySelector('#confirmPickup').addEventListener('click', () => {
          confirmPickupCompletion(order);
        });
      }

      document.getElementById('pickupCodeInput').value = '';
      pickupModal.style.display = 'flex';
    }

    function confirmPickupCompletion(order) {
      try {
        const codeInput = document.getElementById('pickupCodeInput');
        const enteredCode = codeInput.value.trim();

        if (!enteredCode) {
          showToast('Please enter the pickup code', 'error');
          return;
        }

        // Verify pickup code
        if (enteredCode !== String(order.deliveryCode)) {
          showToast('Incorrect pickup code', 'error');
          return;
        }

        // ‚úÖ Code is correct - mark as "Picked Up"
        const globalOrders = getGlobalOrders();
        const globalIdx = globalOrders.findIndex(o =>
          String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
        );

        if (globalIdx === -1) {
          showToast('Order not found in global storage', 'error');
          return;
        }

        const globalOrder = globalOrders[globalIdx];
        const oldStatus = globalOrder.status;

        // Update to "Picked Up" (NOT "Delivered")
        globalOrder.status = 'Picked Up';
        globalOrder.progressStep = 5; // Final step for pickup orders
        globalOrder.pickedUpAt = new Date().toISOString();

        // Add to history
        if (!globalOrder.history) globalOrder.history = [];
        globalOrder.history.push({
          from: oldStatus,
          to: 'Picked Up',
          by: 'seller_pickup',
          at: globalOrder.pickedUpAt,
          note: 'Pickup completed with code verification'
        });

        // Save to global
        globalOrders[globalIdx] = globalOrder;
        saveGlobalOrders(globalOrders);

        // Notify buyer
        const buyerUid = globalOrder.buyer?.uid || globalOrder.buyerId;
        if (buyerUid) {
          localStorage.setItem(`orders_ping__buyer__${buyerUid}`, String(Date.now()));
        }

        // Update seller local and move to completed
        let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
        const sellerIdx = sellerOrders.findIndex(o =>
          String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
        );

        if (sellerIdx !== -1) {
          // Remove from active orders
          sellerOrders.splice(sellerIdx, 1);
          localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));

          // Add to completed orders
          const compKey = completedOrdersKey();
          const completed = JSON.parse(localStorage.getItem(compKey) || '[]');
          completed.unshift(globalOrder);
          localStorage.setItem(compKey, JSON.stringify(completed));
        }

        // Close modal
        const pickupModal = document.getElementById('pickupConfirmationModal');
        if (pickupModal) pickupModal.style.display = 'none';

        // Refresh UI
        renderOrders();
        renderCompletedOrders();
        renderAnalytics();

        showToast('Pickup completed successfully!', 'success');

      } catch (err) {
        console.error('confirmPickupCompletion failed:', err);
        showToast('Error confirming pickup', 'error');
      }
    }

    /* ---------- Change Order Status (seller-driven; decrement at Processing) ---------- */

    /* ---------- Change Order Status (MINIMAL FIX) ---------- */
    /* ---------- Change Order Status (MINIMAL FIX) ---------- */
    async function changeOrderStatus(orderRef, newStatus) {
  try {
    console.log('üéØ changeOrderStatus called:', { orderRef, newStatus });

    const orderId = typeof orderRef === 'object' ? (orderRef.id || orderRef.orderId) : String(orderRef);
    console.log('üìã Order ID:', orderId);

    // SIMPLE: Just update global orders
    const globalOrders = getGlobalOrders();
    console.log('üì¶ Global orders count:', globalOrders.length);

    const orderIndex = globalOrders.findIndex(o =>
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );

    console.log('üîç Order found at index:', orderIndex);

    if (orderIndex !== -1) {
      const oldOrder = globalOrders[orderIndex];
      globalOrders[orderIndex].status = newStatus;
      globalOrders[orderIndex].progressStep = getProgressStep(newStatus);
      globalOrders[orderIndex].statusUpdatedAt = nowISO();

      // üÜï CRITICAL: Track the courier who's assigned
      const assignedCourierId = oldOrder.assignedTo || oldOrder.assignedDeliveryId;
      const buyerUid = globalOrders[orderIndex]?.buyer?.uid;

      // Save global first
      saveGlobalOrders(globalOrders);

      console.log('‚úÖ Updated global order status to:', newStatus);

      // Create an array of sync operations to execute sequentially
      const syncOperations = [];

      // üÜï SYNC TO DELIVERY GUY'S STORAGE
      if (assignedCourierId) {
        syncOperations.push(() => syncToDeliveryGuy(globalOrders[orderIndex], assignedCourierId));
      }

      // üÜï SYNC TO BUYER'S STORAGE
      if (buyerUid) {
        syncOperations.push(() => syncToBuyer(globalOrders[orderIndex]));
      }

      // Execute all sync operations sequentially
      for (const syncOp of syncOperations) {
        try {
          // If syncToDeliveryGuy/syncToBuyer returns a Promise, await it
          // If not, wrap it in a Promise to ensure sequential execution
          const result = syncOp();
          if (result && typeof result.then === 'function') {
            await result;
          } else {
            // Give async operations time to complete even if they don't return promises
            await new Promise(resolve => setTimeout(resolve, 50));
          }
        } catch (syncErr) {
          console.warn('‚ö†Ô∏è Sync operation warning:', syncErr);
          // Continue with other operations even if one fails
        }
      }

      // üö® AUTO-REDUCE PRODUCT STOCK WHEN ORDER GOES TO PROCESSING
      if (newStatus.toLowerCase() === 'processing') {
        console.log('üîÑ Calling reduceProductStock for processing order...');
        reduceProductStock(globalOrders[orderIndex]);
      }

      // Notify buyer
      if (buyerUid) {
        localStorage.setItem(`orders_ping__buyer__${buyerUid}`, Date.now().toString());
        console.log('üì¢ Notified buyer:', buyerUid);
      }

      // üÜï NOTIFY DELIVERY GUY
      if (assignedCourierId) {
        localStorage.setItem(`orders_ping__delivery__${assignedCourierId}`, Date.now().toString());
        console.log('üì¢ Notified delivery guy:', assignedCourierId);
      }
    }

    // Update seller local (optional)
    let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
    const sellerIndex = sellerOrders.findIndex(o =>
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );
    if (sellerIndex !== -1) {
      sellerOrders[sellerIndex].status = newStatus;
      sellerOrders[sellerIndex].progressStep = getProgressStep(newStatus);
      localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));
      console.log('‚úÖ Updated seller local order');
    }

    // Only render after all sync operations are complete
    renderOrders();
    showToast(`Order ‚Üí ${newStatus}`, 'success');

    console.log('üéâ changeOrderStatus completed successfully');

  } catch (err) {
    console.error('‚ùå changeOrderStatus error:', err);
    showToast('Update failed', 'error');
  }
}

// Helper function to check if a function returns a Promise
function returnsPromise(fn) {
  const result = fn();
  return result && typeof result.then === 'function';
}

    /* ---------- NEW: Sync to Delivery Guy ---------- */
    function syncToDeliveryGuy(order, courierUid) {
      try {
        if (!courierUid) return;

        const deliveryOrdersKey = `orders__delivery__${courierUid}`;
        let deliveryOrders = JSON.parse(localStorage.getItem(deliveryOrdersKey) || '[]');

        const orderIndex = deliveryOrders.findIndex(o =>
          String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
        );

        if (orderIndex !== -1) {
          // Update existing order
          deliveryOrders[orderIndex] = {
            ...deliveryOrders[orderIndex],
            status: order.status,
            progressStep: order.progressStep,
            statusUpdatedAt: order.statusUpdatedAt,
            // Preserve delivery-specific fields
            assignedTo: deliveryOrders[orderIndex].assignedTo || order.assignedTo,
            assignedDeliveryId: deliveryOrders[orderIndex].assignedDeliveryId || order.assignedDeliveryId,
            courierEarnings: deliveryOrders[orderIndex].courierEarnings || order.courierEarnings,
            assignedBidAmount: deliveryOrders[orderIndex].assignedBidAmount || order.assignedBidAmount,
            // Update history
            history: [
              ...(deliveryOrders[orderIndex].history || []),
              {
                action: 'status_updated_by_seller',
                from: deliveryOrders[orderIndex].status,
                to: order.status,
                at: order.statusUpdatedAt,
                by: 'seller'
              }
            ]
          };
        } else {
          // Add new order (this shouldn't happen but just in case)
          deliveryOrders.unshift(order);
        }

        localStorage.setItem(deliveryOrdersKey, JSON.stringify(deliveryOrders));
        console.log('‚úÖ Synced to delivery guy storage:', courierUid);

      } catch (error) {
        console.error('‚ùå Failed to sync to delivery guy:', error);
      }
    }

    /* ---------- NEW: Sync to Buyer ---------- */
    function syncToBuyer(order) {
      try {
        const buyerUid = order.buyer?.uid || order.buyerId;
        if (!buyerUid) return;

        const buyerOrdersKey = `orders__buyer__${buyerUid}`;
        let buyerOrders = JSON.parse(localStorage.getItem(buyerOrdersKey) || '[]');

        const orderIndex = buyerOrders.findIndex(o =>
          String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
        );

        if (orderIndex !== -1) {
          // Update existing order
          buyerOrders[orderIndex] = {
            ...buyerOrders[orderIndex],
            status: order.status,
            progressStep: order.progressStep,
            statusUpdatedAt: order.statusUpdatedAt
          };
        }

        localStorage.setItem(buyerOrdersKey, JSON.stringify(buyerOrders));
        console.log('‚úÖ Synced to buyer storage:', buyerUid);

      } catch (error) {
        console.error('‚ùå Failed to sync to buyer:', error);
      }
    }

    /* ---------- Reject (moves order to completedOrders as 'Rejected') ---------- */
    /* ---------- Reject Order (UPDATES GLOBAL) ---------- */
    /* ---------- Reject Order (UPDATES GLOBAL + DELIVERY GUY) ---------- */
    /* ---------- Enhanced Reject Order Function ---------- */
    function rejectOrder(orderRef) {
      try {
        console.log('üéØ rejectOrder called:', orderRef);

        const orderId = typeof orderRef === 'object' ? (orderRef.id || orderRef.orderId) : String(orderRef);

        // Get confirmation with financial warning
        const subtotal = orderRef.subtotal || 0;
        const deliveryFee = orderRef.delivery || orderRef.deliveryFee || 0;
        const totalValue = subtotal + deliveryFee;

        const confirmMsg = totalValue > 0
          ? `Reject this order worth GHC ${totalValue.toFixed(2)}? This will cancel the transaction. The buyer will be refunded.`
          : 'Reject this order? It will be moved to history as Rejected.';

        if (!confirm(confirmMsg)) return;

        // 1. UPDATE GLOBAL ORDERS
        const globalOrders = getGlobalOrders();
        const globalIdx = globalOrders.findIndex(o =>
          String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
        );

        if (globalIdx === -1) {
          showToast('Order not found in global storage', 'error');
          return;
        }

        const globalOrder = globalOrders[globalIdx];
        const oldStatus = globalOrder.status || 'Pending';
        const rejectedAt = new Date().toISOString();

        console.log('üì¶ Updating global order to Rejected');

        // üî• CRITICAL FIX: Preserve ALL financial data
        const enhancedOrder = {
          ...globalOrder,
          status: 'Rejected',
          progressStep: 0,
          rejectedAt,
          // üéØ FINANCIAL DATA PRESERVATION
          subtotal: globalOrder.subtotal || 0,
          delivery: globalOrder.delivery || globalOrder.deliveryFee || 0,
          total: globalOrder.total || (globalOrder.subtotal + (globalOrder.delivery || globalOrder.deliveryFee || 0)),
          // üéØ ZERO REVENUE FOR REJECTED ORDERS
          sellerRevenue: 0,
          deliveryProfit: 0,
          courierEarnings: 0,
          // History with financial context
          history: [
            ...(globalOrder.history || []),
            {
              from: oldStatus,
              to: 'Rejected',
              by: 'seller',
              at: rejectedAt,
              financials: {
                orderValue: globalOrder.total || 0,
                subtotal: globalOrder.subtotal || 0,
                deliveryFee: globalOrder.delivery || 0,
                sellerRevenue: 0,
                note: 'Order rejected - no revenue earned'
              }
            }
          ]
        };

        globalOrders[globalIdx] = enhancedOrder;
        saveGlobalOrders(globalOrders);
        console.log('‚úÖ Updated global order with financial data');

        // 2. UPDATE DELIVERY GUY (if assigned)
        try {
          const assignedTo = enhancedOrder.assignedTo || enhancedOrder.assignedDeliveryId;
          if (assignedTo) {
            const deliveryGuyOrdersKey = `orders__delivery__${assignedTo}`;
            const deliveryGuyOrders = JSON.parse(localStorage.getItem(deliveryGuyOrdersKey) || '[]');

            const deliveryIdx = deliveryGuyOrders.findIndex(o =>
              String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
            );

            if (deliveryIdx !== -1) {
              deliveryGuyOrders[deliveryIdx] = {
                ...deliveryGuyOrders[deliveryIdx],
                ...enhancedOrder
              };

              localStorage.setItem(deliveryGuyOrdersKey, JSON.stringify(deliveryGuyOrders));
              localStorage.setItem(`orders_ping__delivery__${assignedTo}`, String(Date.now()));
              console.log('‚úÖ Updated delivery guy storage');
            }
          }
        } catch (err) {
          console.warn('Delivery guy update failed', err);
        }

        // 3. UPDATE BUYER
        try {
          const buyerUid = enhancedOrder.buyer?.uid || enhancedOrder.buyerId || null;
          if (buyerUid) {
            const buyerOrdersKey = `orders__buyer__${buyerUid}`;
            const buyerOrders = JSON.parse(localStorage.getItem(buyerOrdersKey) || '[]');
            const bIdx = buyerOrders.findIndex(o => String(o.id) === String(orderId));

            if (bIdx !== -1) {
              buyerOrders[bIdx] = {
                ...buyerOrders[bIdx],
                ...enhancedOrder
              };
              console.log('‚úÖ Updated buyer order');
            } else {
              buyerOrders.unshift(enhancedOrder);
              console.log('‚úÖ Added rejected order to buyer');
            }

            localStorage.setItem(buyerOrdersKey, JSON.stringify(buyerOrders));
            localStorage.setItem(`orders_ping__buyer__${buyerUid}`, String(Date.now()));
            console.log('üì¢ Notified buyer');
          }
        } catch (err) {
          console.warn('Buyer update failed', err);
        }

        // 4. UPDATE SELLER LOCAL - Add to completed orders with clear rejection label
        try {
          let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
          const sIdx = sellerOrders.findIndex(o =>
            String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
          );
          if (sIdx !== -1) {
            sellerOrders.splice(sIdx, 1); // Remove from active seller orders
            localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));
            console.log('‚úÖ Removed from seller active orders');
          }

          // Add to seller completed history with REJECTED label
          const compKey = completedOrdersKey();
          const completed = JSON.parse(localStorage.getItem(compKey) || '[]');
          completed.unshift({
            ...enhancedOrder,
            // Add visual indicator for rejected orders
            _isRejected: true,
            _rejectedTimestamp: rejectedAt
          });
          localStorage.setItem(compKey, JSON.stringify(completed));
          console.log('‚úÖ Added to seller completed orders with rejection flag');
        } catch (e) {
          console.warn('Seller local update failed', e);
        }

        // 5. REFRESH UI
        renderOrders();
        if (typeof renderCompletedOrders === 'function') renderCompletedOrders();
        if (typeof renderAnalytics === 'function') renderAnalytics();

        showToast(`Order rejected. Value: GHC ${totalValue.toFixed(2)} was cancelled.`, 'warn');
        console.log('üéâ rejectOrder completed with financial tracking');

      } catch (err) {
        console.error('‚ùå rejectOrder failed', err);
        showToast('Error rejecting order', 'error');
      }
    }

    /* ---------- Complete Order (move to completedOrders and count revenue) ---------- */
    function completeOrder(orderObj) {
      orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
      completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];

      const idx = orders.findIndex(o => (String(o.id) && String(o.id) === String(orderObj.id)) || (String(o.orderId) && String(o.orderId) === String(orderObj.orderId)));
      if (idx === -1) {
        showToast('Order not found to complete', 'error');
        return;
      }

      const order = { ...orders[idx], status: 'Delivered', progressStep: getProgressStep('delivered'), deliveredAt: nowISO() };

      // push to completedOrders and remove from active orders
      completedOrders.push(order);
      orders.splice(idx, 1);

      localStorage.setItem(ordersKey(), JSON.stringify(orders));
      localStorage.setItem(completedOrdersKey(), JSON.stringify(completedOrders));

      // update trackers so polling/storage logic stays consistent
      lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
      localStorage._lastCompletedJson = localStorage.getItem(completedOrdersKey()) || '[]';

      renderOrders();
      renderProducts();
      renderCompletedOrders();
      renderAnalytics();
      showToast(`Order ${order.id || order.orderId} completed & moved to history`, 'success');

      // notify other tabs
      window.dispatchEvent(new CustomEvent('orderDelivered', { detail: { orderId: order.id || order.orderId } }));
    }

    /* ---------- Delivery Code Modal (code shown to buyer only) ---------- */
    let currentDeliveryOrder = null;
    function openConfirmCodeModal(order) {
      const orderId = order.id || order.orderId;

      // üî• CHECK IF ORDER IS LOCKED (same as delivery page)
      const lockKey = `delivery_lock__${getUid()}__${orderId}`;
      try {
        const lockState = JSON.parse(localStorage.getItem(lockKey) || '{}');
        const lockUntil = lockState.lockUntil || 0;

        if (lockUntil > Date.now()) {
          const minutesLeft = Math.ceil((lockUntil - Date.now()) / 60000);
          showToast(
            `üö´ Order locked for ${minutesLeft} minutes - Courier failed delivery code too many times`,
            'error'
          );
          return; // üö´ BLOCK SELLER TOO
        }
      } catch (e) {
        console.warn('Lock check failed:', e);
      }

      currentDeliveryOrder = order;
      if (deliveryCodeInput) deliveryCodeInput.value = '';
      codeModal.style.display = 'flex';
    }

    confirmDeliveryBtn && confirmDeliveryBtn.addEventListener('click', async () => {
      if (!currentDeliveryOrder) return;

      // üî• CLEAR THE LOCK ON SUCCESS (same key as delivery page)
      const orderId = currentDeliveryOrder.id || currentDeliveryOrder.orderId;
      try {
        const lockKey = `delivery_lock__${getUid()}__${orderId}`;
        localStorage.removeItem(lockKey);
      } catch (e) {
        console.warn('Failed to clear lock:', e);
      }

      // Reload from GLOBAL storage to ensure we have latest version
      const globalOrders = getGlobalOrders();
      const globalIdx = globalOrders.findIndex(o =>
        (o.id && o.id === currentDeliveryOrder.id) ||
        (o.orderId && o.orderId === currentDeliveryOrder.orderId)
      );

      if (globalIdx === -1) {
        showToast('Order not found in global storage', 'error');
        return;
      }

      const stored = globalOrders[globalIdx];

      // --- Verify delivery code ---
      if (deliveryCodeInput.value.trim() === String(stored.deliveryCode)) {
        // ‚úÖ Mark as delivered in GLOBAL
        stored.status = 'Delivered';
        stored.progressStep = 6;
        stored.deliveredAt = new Date().toISOString();

        // Add to history
        if (!stored.history) stored.history = [];
        stored.history.push({
          from: stored.status,
          to: 'Delivered',
          by: 'seller',
          at: stored.deliveredAt
        });

        // Save to global
        globalOrders[globalIdx] = stored;
        saveGlobalOrders(globalOrders);

        // --- üî• CRITICAL FIX: Sync to Delivery Guy's Storage ---
        try {
          const assignedCourierId = stored.assignedTo || stored.assignedDeliveryId;
          if (assignedCourierId) {
            const deliveryGuyOrdersKey = `orders__delivery__${assignedCourierId}`;
            const deliveryGuyOrders = JSON.parse(localStorage.getItem(deliveryGuyOrdersKey) || '[]');

            const deliveryIdx = deliveryGuyOrders.findIndex(o =>
              String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
            );

            if (deliveryIdx !== -1) {
              // Update the delivery guy's copy
              deliveryGuyOrders[deliveryIdx] = {
                ...deliveryGuyOrders[deliveryIdx],
                status: 'Delivered',
                progressStep: 6,
                deliveredAt: stored.deliveredAt,
                // Preserve earnings data
                courierEarnings: deliveryGuyOrders[deliveryIdx].courierEarnings || stored.courierEarnings,
                assignedBidAmount: deliveryGuyOrders[deliveryIdx].assignedBidAmount || stored.assignedBidAmount,
                // Add history entry
                history: [
                  ...(deliveryGuyOrders[deliveryIdx].history || []),
                  {
                    action: 'delivery_confirmed_by_seller',
                    at: stored.deliveredAt,
                    note: 'Seller confirmed delivery with code'
                  }
                ]
              };

              // Save back to delivery guy's storage
              localStorage.setItem(deliveryGuyOrdersKey, JSON.stringify(deliveryGuyOrders));

              // üö® NOTIFY DELIVERY GUY TO REFRESH
              localStorage.setItem(`orders_ping__delivery__${assignedCourierId}`, Date.now().toString());

              console.log('‚úÖ Synced "Delivered" status to delivery guy:', assignedCourierId);
            }
          }
        } catch (error) {
          console.warn('Failed to sync to delivery guy:', error);
        }

        // --- Sync to buyer ---
        try {
          const buyerUid = stored?.buyer?.uid || stored?.buyerId || null;
          if (buyerUid) {
            // Update buyer's local orders
            const buyerOrdersKey = `orders__buyer__${buyerUid}`;
            const buyerOrders = JSON.parse(localStorage.getItem(buyerOrdersKey) || '[]');
            const bIdx = buyerOrders.findIndex(o => String(o.id) === String(stored.id));

            if (bIdx !== -1) {
              buyerOrders[bIdx].status = 'Delivered';
              buyerOrders[bIdx].progressStep = 6;
              buyerOrders[bIdx].deliveredAt = stored.deliveredAt;
            }
            localStorage.setItem(buyerOrdersKey, JSON.stringify(buyerOrders));

            // Ping buyer
            localStorage.setItem(`orders_ping__buyer__${buyerUid}`, String(Date.now()));
          }
        } catch (err) {
          console.warn('Buyer delivery sync failed', err);
        }

        // --- Update seller local storage ---
        try {
          let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
          const sIdx = sellerOrders.findIndex(o =>
            String(o.id) === String(stored.id) || String(o.orderId) === String(stored.orderId)
          );
          if (sIdx !== -1) {
            sellerOrders[sIdx].status = 'Delivered';
            sellerOrders[sIdx].progressStep = 6;
            localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));
          }
        } catch (e) {
          console.warn('Seller local update failed', e);
        }

        // --- Continue with normal completeOrder logic ---
        completeOrder(stored);
        codeModal.style.display = 'none';
        currentDeliveryOrder = null;
        showToast('Order marked as Delivered!', 'success');

      } else {
        // ‚ùå Wrong code entered
        showToast('Incorrect code', 'error');
        stored.attempts = (Number(stored.attempts) || 0) + 1;

        // Add to history
        if (!stored.history) stored.history = [];
        stored.history.push({
          action: 'failed_code_attempt',
          attempts: stored.attempts,
          at: new Date().toISOString()
        });

        // Save back to global
        globalOrders[globalIdx] = stored;
        saveGlobalOrders(globalOrders);

        if (stored.attempts >= 3) {
          changeOrderStatus(stored, 'Rejected');
          showToast('Too many failed attempts ‚Äî order marked Rejected', 'warn');
        }
      }
    });

    cancelDeliveryBtn && cancelDeliveryBtn.addEventListener('click', () => {
      // Close modal, keep order untouched so seller can retry entering code
      codeModal.style.display = 'none';
      currentDeliveryOrder = null;
      showToast('Delivery confirmation cancelled ‚Äî you can re-open modal to try again', 'info');
    });
    /* ---------- Analytics ---------- */
    /* ---------- Enhanced Analytics Function ---------- */
    function renderAnalytics() {
      completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];
      orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
      products = JSON.parse(localStorage.getItem(productsKey()) || '[]') || [];

      // üéØ ENHANCED: Track different types of revenue
      let totalProductRevenue = 0;
      let totalDeliveryProfit = 0;
      let totalCourierEarnings = 0;
      let totalDeliveryFeesCollected = 0;
      let totalCancelledValue = 0;

      let deliveredCount = 0;
      let rejectedCount = 0;
      let pendingCount = 0;

      completedOrders.forEach(o => {
        const isRejected = o.status === 'Rejected';
        const isDelivered = o.status === 'Delivered' || o.status === 'Picked Up';

        if (isRejected) {
          rejectedCount++;
          const orderValue = o.subtotal + (o.delivery || o.deliveryFee || 0);
          totalCancelledValue += orderValue;
        } else if (isDelivered) {
          deliveredCount++;
          const productRevenue = o.subtotal || 0;
          const deliveryFee = o.delivery || o.deliveryFee || 0;
          const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
          const deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);

          totalProductRevenue += productRevenue;
          totalDeliveryProfit += deliveryProfit;
          totalCourierEarnings += courierEarnings;
          totalDeliveryFeesCollected += deliveryFee;
        }
      });

      const totalSales = totalProductRevenue + totalDeliveryProfit;
      const pending = orders.filter(o => (o.status || '').toLowerCase() === 'pending').length;
      pendingCount = pending;

      const active = products.filter(p => p.status === 'Active').length;
      const stock = products.reduce((s, p) => s + (Number(p.quantity) || 0), 0);
      const totalOrdersCount = (orders.length || 0) + (completedOrders.length || 0);

      // Update the analytics display with more details
      qs('#cardTotal').innerHTML = `GHC ${Number(totalSales || 0).toFixed(2)}<br><span class="small-muted" style="font-size:0.75rem">(${deliveredCount} delivered)</span>`;
      qs('#cardOrders').innerHTML = `${totalOrdersCount}<br><span class="small-muted" style="font-size:0.75rem">${rejectedCount} rejected</span>`;
      qs('#cardPending').innerHTML = `${pendingCount}<br><span class="small-muted" style="font-size:0.75rem">active</span>`;
      qs('#cardActive').innerHTML = `${active}<br><span class="small-muted" style="font-size:0.75rem">listings</span>`;
      qs('#cardStock').innerHTML = `${stock}<br><span class="small-muted" style="font-size:0.75rem">units</span>`;

      // Optional: Add a new card for cancelled value
      const cancelledCard = document.createElement('div');
      cancelledCard.innerHTML = `
    <strong>Cancelled Value</strong>
    <div class="small-muted" style="color:var(--danger)">GHC ${Number(totalCancelledValue || 0).toFixed(2)}</div>
  `;

      const analyticsGrid = document.querySelector('#sectionAnalytics .analytics-grid') ||
        document.querySelector('#sectionAnalytics > div');
      if (analyticsGrid && !document.querySelector('#cancelledValueCard')) {
        cancelledCard.id = 'cancelledValueCard';
        analyticsGrid.appendChild(cancelledCard);
      }
    }

    /* ---------- CSV export for completedOrders ---------- */
    function exportCompletedCSV() {
      // Get completed orders including rejected ones
      completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];

      if (!completedOrders.length) {
        showToast('No completed orders to export', 'warn');
        return;
      }

      const rows = [];

      // Enhanced headers with more financial and delivery details
      rows.push([
        'Order ID', 'Status', 'Buyer Name', 'Buyer Email', 'Buyer Phone',
        'Room', 'Index', 'Program', 'Items Summary', 'Item Details',
        'Quantity', 'Subtotal', 'Delivery Fee', 'Courier Earnings',
        'Delivery Profit', 'Seller Revenue', 'Total Order Value',
        'Order Status', 'Placed At', 'Delivered At', 'Rejected At', 'Picked Up At',
        'Assigned Courier', 'Delivery Type', 'Delivery Code', 'Thumbnail URLs',
        'Order Notes', 'Payment Method', 'Seller Profit/Loss'
      ]);

      // Track summary statistics
      let totalDeliveredRevenue = 0;
      let totalRejectedValue = 0;
      let deliveredCount = 0;
      let rejectedCount = 0;
      let pickupCount = 0;
      let deliveryCount = 0;

      completedOrders.forEach(o => {
        const items = Array.isArray(o.items) ? o.items : (o.product ? [{ name: o.product, price: o.price || 0, quantity: o.quantity || 1, image: orderThumbnail(o) }] : []);

        // Enhanced item information
        const itemsSummary = items.map(i => i.name).join('; ');
        const itemDetails = items.map(i =>
          `${i.name} (Qty: ${i.quantity || 1}, Price: GHC ${(i.price || 0).toFixed(2)})`
        ).join(' | ');

        const qty = items.reduce((s, i) => s + (Number(i.quantity) || 0), 0);
        const subtotal = o.subtotal || items.reduce((s, i) => s + (Number(i.price) || 0) * (Number(i.quantity) || 1), 0);
        const deliveryFee = o.delivery || o.deliveryFee || 0;
        const totalOrderValue = o.total || (subtotal + deliveryFee);

        // Determine order status
        const isRejected = o.status === 'Rejected';
        const isDelivered = o.status === 'Delivered';
        const isPickedUp = o.status === 'Picked Up';
        const deliveryType = o.deliveryType || (isPickedUp ? 'pickup' : 'delivery');

        // Calculate financials based on status
        let courierEarnings = 0;
        let deliveryProfit = 0;
        let sellerRevenue = 0;
        let sellerProfitLoss = '';

        if (isRejected) {
          // REJECTED ORDER
          sellerRevenue = 0;
          courierEarnings = 0;
          deliveryProfit = 0;
          sellerProfitLoss = 'REJECTED (GHC 0.00)';
          totalRejectedValue += totalOrderValue;
          rejectedCount++;
        } else if (isDelivered || isPickedUp) {
          // DELIVERED OR PICKED UP ORDER
          courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
          deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);
          sellerRevenue = subtotal + deliveryProfit;
          sellerProfitLoss = `PROFIT: GHC ${sellerRevenue.toFixed(2)}`;
          totalDeliveredRevenue += sellerRevenue;
          deliveredCount++;

          if (isPickedUp) {
            pickupCount++;
          } else {
            deliveryCount++;
          }
        } else {
          // OTHER STATUS (shouldn't happen in completed)
          sellerRevenue = 0;
          courierEarnings = 0;
          deliveryProfit = 0;
          sellerProfitLoss = 'UNKNOWN';
        }

        const thumbs = items.map(i => i.image || '').filter(Boolean).join('|');

        // Enhanced buyer information
        const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
        const buyerName = buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Unknown';
        const buyerPhone = buyerObj?.phone || o.phone || '';
        const buyerEmail = buyerObj?.email || o.email || '';
        const buyerRoom = buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '';
        const buyerIndex = buyerObj?.index || o.index || '';
        const buyerProgram = buyerObj?.program || '';

        // Enhanced order metadata
        const status = o.status || 'Unknown';
        const assignedCourier = o.deliveryPerson || o.assignedTo || '';
        const deliveryCode = o.deliveryCode || '';
        const orderNotes = (o.notes || o.specialInstructions || '').replace(/,/g, ';'); // Replace commas to avoid CSV issues
        const paymentMethod = o.paymentMethod || 'Unknown';

        // Format dates properly
        const formatDateForCSV = (dateString) => {
          if (!dateString) return '';
          try {
            return new Date(dateString).toLocaleString('en-GB', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false
            });
          } catch {
            return dateString;
          }
        };

        // Create CSV row with all data
        rows.push([
          String(o.id || o.orderId || 'N/A'),
          status,
          buyerName,
          buyerEmail,
          buyerPhone,
          buyerRoom,
          buyerIndex,
          buyerProgram,
          itemsSummary,
          itemDetails,
          String(qty),
          Number(subtotal || 0).toFixed(2),
          Number(deliveryFee || 0).toFixed(2),
          Number(courierEarnings || 0).toFixed(2),
          Number(deliveryProfit || 0).toFixed(2),
          Number(sellerRevenue || 0).toFixed(2),
          Number(totalOrderValue || 0).toFixed(2),
          o.status,
          formatDateForCSV(o.date || o.appearedAt || o.createdAt),
          isDelivered ? formatDateForCSV(o.deliveredAt || o.delivered || o.completedAt) : '',
          isRejected ? formatDateForCSV(o.rejectedAt) : '',
          isPickedUp ? formatDateForCSV(o.pickedUpAt) : '',
          assignedCourier,
          deliveryType,
          deliveryCode,
          thumbs,
          orderNotes,
          paymentMethod,
          sellerProfitLoss
        ]);
      });

      // Add summary rows at the end
      rows.push([]); // Empty row for separation
      rows.push(['SUMMARY', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']);
      rows.push(['Total Orders:', completedOrders.length]);
      rows.push(['Delivered Orders:', deliveredCount]);
      rows.push(['Rejected Orders:', rejectedCount]);
      rows.push(['Pickup Orders:', pickupCount]);
      rows.push(['Delivery Orders:', deliveryCount]);
      rows.push(['Total Delivered Revenue:', `GHC ${totalDeliveredRevenue.toFixed(2)}`]);
      rows.push(['Total Rejected Value:', `GHC ${totalRejectedValue.toFixed(2)}`]);
      rows.push(['Average Revenue per Order:', `GHC ${(totalDeliveredRevenue / (deliveredCount || 1)).toFixed(2)}`]);
      rows.push(['Export Date:', new Date().toLocaleString()]);

      // Enhanced CSV formatting with better handling of special characters
      const csv = rows.map(r => r.map(cell => {
        if (cell === null || typeof cell === 'undefined') return '';

        const cellString = String(cell);

        // Escape cells that contain commas, quotes, or newlines
        if (/[",\n\r]/.test(cellString)) {
          return `"${cellString.replace(/"/g, '""')}"`;
        }

        return cellString;
      }).join(',')).join('\n');

      // Create and trigger download with better error handling
      try {
        const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' }); // BOM for Excel compatibility
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        const ts = new Date().toISOString()
          .replace(/[:.]/g, '-')
          .replace('T', '_')
          .slice(0, 19); // Better timestamp format: YYYY-MM-DD_HH-MM-SS

        a.download = `Marketplace_Orders_${ts}.csv`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        // Enhanced success message with summary
        showToast(`‚úÖ Exported ${completedOrders.length} orders (${deliveredCount} delivered, ${rejectedCount} rejected)`, 'success');

        // Log export summary for debugging
        console.log('üìä CSV Export Summary:', {
          totalOrders: completedOrders.length,
          deliveredCount,
          rejectedCount,
          pickupCount,
          deliveryCount,
          totalDeliveredRevenue: totalDeliveredRevenue.toFixed(2),
          totalRejectedValue: totalRejectedValue.toFixed(2),
          averageRevenue: (totalDeliveredRevenue / (deliveredCount || 1)).toFixed(2),
          timestamp: new Date().toISOString()
        });

      } catch (error) {
        console.error('CSV export failed:', error);
        showToast('Failed to export CSV. Please try again.', 'error');
      }
    }


    /* ---------- Event Listeners ---------- */
    productSearch && productSearch.addEventListener('input', renderProducts);
    productStatusFilter && productStatusFilter.addEventListener('change', renderProducts);
    productCategoryFilter && productCategoryFilter.addEventListener('change', renderProducts);
    orderSearch && orderSearch.addEventListener('input', renderOrders);
    orderFilter && orderFilter.addEventListener('change', renderOrders);
    historySearch && historySearch.addEventListener('input', renderCompletedOrders);
    exportCsvBtn && exportCsvBtn.addEventListener('click', exportCompletedCSV);

    window.addEventListener('storage', (e) => {
      if (e.key === ordersKey()) {
        const prev = JSON.parse(lastOrdersJson || '[]');
        const cur = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
        const prevLen = Array.isArray(prev) ? prev.length : 0;
        const curLen = Array.isArray(cur) ? cur.length : 0;
        lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
        renderOrders(curLen > prevLen);
      } else if (e.key === productsKey()) {
        products = JSON.parse(localStorage.getItem(productsKey()) || '[]');
        renderProducts(); renderAnalytics();
      } else if (e.key === completedOrdersKey()) {
        renderCompletedOrders(); renderAnalytics();
        renderOrders();
      }
    });
    // When global orders change, refresh the page
    // When global orders change, refresh the page
    window.addEventListener('storage', (e) => {
      if (e.key === ORDERS_GLOBAL) {
        console.log('üîÑ Global orders updated - syncing to seller');
        syncSellerOrdersFromGlobal();
        renderOrders(); // Refresh the display
        showToast('Order status updated from delivery!', 'success');
      }
    });

    // React to events dispatched by delivery page (immediate sync)
    window.addEventListener('localOrdersUpdated', () => { renderOrders(); renderCompletedOrders(); renderAnalytics(); });
    window.addEventListener('orderDelivered', (e) => {
      renderOrders(); renderCompletedOrders(); renderAnalytics();
      // small toast referencing delivered orderId if present
      try { const id = e?.detail?.orderId; if (id) showToast(`Order ${id} delivered`, 'success'); } catch (e) { }
    });

    /* ---------- Polling fallback ---------- */
    (function startPollingFallback() {
      setInterval(() => {
        try {
          const curOrdersJson = localStorage.getItem(ordersKey()) || '[]';
          if (curOrdersJson !== lastOrdersJson) {
            const prev = JSON.parse(lastOrdersJson || '[]');
            const cur = JSON.parse(curOrdersJson || '[]');
            const prevLen = Array.isArray(prev) ? prev.length : 0;
            const curLen = Array.isArray(cur) ? cur.length : 0;
            lastOrdersJson = curOrdersJson;
            renderOrders(curLen > prevLen);
          }
          const curCompleted = localStorage.getItem(completedOrdersKey()) || '[]';
          if (curCompleted !== (localStorage._lastCompletedJson || '[]')) {
            localStorage._lastCompletedJson = curCompleted;
            renderCompletedOrders();
            renderAnalytics();
            renderOrders();
          }
          const curProducts = localStorage.getItem(productsKey()) || '[]';
          if (curProducts !== (localStorage._lastProductsJson || '[]')) {
            localStorage._lastProductsJson = curProducts;
            products = JSON.parse(curProducts || '[]');
            renderProducts();
            renderAnalytics();
          }
        } catch (err) {
          console.warn('poll error', err);
        }
      }, 1000);
    })();

    /* ---------- Init ---------- */
    /* ---------- Init ---------- */
async function init() {
  console.log('üöÄ Initializing seller dashboard...');
  
   // ‚úÖ Setup delivery request listeners
  setTimeout(() => {
    setupDeliveryRequestListeners();
  }, 2000);
  
  // ‚úÖ CRITICAL: Always load from Firestore first
  await loadProductsFromFirestore();
  
  // Load orders (these can still use localStorage for now)
  orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
  completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];

  populateCategorySelects();

  let changed = false;
  orders.forEach((o, idx) => {
    orders[idx] = normalizeOrderFields(o);
    if (typeof orders[idx].progressStep === 'undefined') { 
      orders[idx].progressStep = getProgressStep(orders[idx].status); 
      changed = true; 
    }
    if (!orders[idx].deliveryCode) { 
      assignDeliveryCode(orders[idx]); 
      changed = true; 
    }
    if (!orders[idx].appearedAt) { 
      ensureAppearedAt(orders[idx]); 
      changed = true; 
    }
  });
  
  if (changed) localStorage.setItem(ordersKey(), JSON.stringify(orders));

  lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
  localStorage._lastCompletedJson = localStorage.getItem(completedOrdersKey()) || '[]';
  localStorage._lastProductsJson = localStorage.getItem(productsKey()) || '[]';

  // Render everything
  renderProducts();
  renderOrders();
  renderCompletedOrders();
  renderAnalytics();
  
  console.log('‚úÖ Dashboard initialized');
}

// ‚úÖ STEP 5: Auto-refresh products from Firestore every 30 seconds
setInterval(async () => {
  console.log('üîÑ Auto-refreshing products from Firestore...');
  await loadProductsFromFirestore();
  renderProducts();
  renderAnalytics();
}, 30000); // Every 30 seconds

// ‚úÖ STEP 6: Sync when page becomes visible again
document.addEventListener('visibilitychange', async () => {
  if (!document.hidden) {
    console.log('üëÄ Page visible - refreshing from Firestore...');
    await loadProductsFromFirestore();
    renderProducts();
    renderAnalytics();
  }
});

// ‚úÖ STEP 7: Listen for storage events from other tabs
window.addEventListener('storage', async (e) => {
  if (e.key === productsKey()) {
    console.log('üì¢ Products updated in another tab - syncing to Firestore...');
    scheduleSync(); // Auto-sync changes to Firestore
    
    // Also refresh from Firestore to get latest
    await loadProductsFromFirestore();
    renderProducts();
    renderAnalytics();
  }
});

    init();

    /* ---------- Console helpers ---------- */
    window.__sellerDash = {
      get products() { return JSON.parse(localStorage.getItem(productsKey()) || '[]'); },
      get orders() { return JSON.parse(localStorage.getItem(ordersKey()) || '[]'); },
      get completedOrders() { return JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]'); },
      renderProducts, renderOrders, renderCompletedOrders, changeOrderStatus, rejectOrder, completeOrder, exportCompletedCSV,
      // new helpers
      askForDelivery, cancelDeliveryRequest, addBid, removeBid, assignCourier, pushOrderHistory, normalizeOrderFields
    };

    // ============================================
    // ‚úÖ NEW STORAGE CLEANUP FUNCTION - ADD THIS
    // ============================================
    function optimizeStorageAndCleanup() {
      try {
        console.log('üîç Checking storage for cleanup...');

        // Get all current products
        const products = JSON.parse(localStorage.getItem(productsKey()) || '[]');

        // If we have more than 80 products, clean up
        if (products.length > 80) {
          console.log(`üßπ Storage cleanup needed: ${products.length} products found`);

          // Sort products by creation date (oldest first)
          const sorted = [...products].sort((a, b) => {
            const dateA = new Date(a.createdAt || 0);
            const dateB = new Date(b.createdAt || 0);
            return dateA - dateB; // Oldest first
          });

          // Keep only the newest 60 products
          const productsToKeep = sorted.slice(-60);

          // Save back to storage
          localStorage.setItem(productsKey(), JSON.stringify(productsToKeep));

          // Show message to user
          const removedCount = products.length - 60;
          showToast(`üîÑ Storage optimized! Removed ${removedCount} old products`, 'warn');

          console.log(`‚úÖ Cleanup completed: Removed ${removedCount} products`);
          return true;
        }

        console.log('‚úÖ Storage is within limits');
        return false;

      } catch (error) {
        console.warn('‚ùå Storage cleanup failed:', error);
        return false;
      }
    }

    // ============================================
    // ‚úÖ START AUTOMATIC CLEANUP - ADD THIS TOO
    // ============================================

    // üéØ ADD THIS TO YOUR EXISTING POLLING SECTION
    // Look for this code in your script:
    // ============================================
    // ‚úÖ FIXED: AUTOMATIC STORAGE CLEANUP
    // ============================================

    // Automatic storage cleanup every 30 seconds
    setInterval(() => {
      optimizeStorageAndCleanup();
    }, 30000); // Runs every 30 seconds

    // Run cleanup 5 seconds after page loads
    setTimeout(() => {
      optimizeStorageAndCleanup();
    }, 5000);

  </script>







</body>

</html>